<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>interview/木易杨</title>
    <url>/2020/03/11/interview/%E6%9C%A8%E6%98%93%E6%9D%A8/</url>
    <content><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><ul>
<li>垂直放置。</li>
<li>外边距折叠。</li>
<li>margin-left触碰容器左边缘border-left（对于从右到左的格式来说，则触碰到右边缘）</li>
<li>不与float 重叠</li>
<li>浮动元素计算高度</li>
</ul>
<p>实现：</p>
<ul>
<li>html 根元素</li>
<li>float 浮动</li>
<li>position absolute 和fixed</li>
<li>overflow 不为 visiable</li>
<li>display 为表格布局或者弹性布局</li>
</ul>
<h1 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h1><ul>
<li>absolute+transform: translate(-50%,-50%);</li>
<li>flex + align-items: center + justify-content:center;</li>
</ul>
<h1 id="opacity-0、visibility-hidden、display-none"><a href="#opacity-0、visibility-hidden、display-none" class="headerlink" title="opacity: 0、visibility: hidden、display: none"></a>opacity: 0、visibility: hidden、display: none</h1><ul>
<li>display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）（不会被子元素继承）（重排，性能较差）</li>
<li>visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）（子元素visibility: visible; 来取消隐藏）（重绘，性能较高）</li>
<li>opacity: 0（占据空间，可以点击）（场景：可以跟transition搭配）（不能通过 opacity: 1 来取消隐藏）（提升为新图层，不会触发重绘，性能较高）</li>
</ul>
<h1 id="内联width-480px-important样式覆盖"><a href="#内联width-480px-important样式覆盖" class="headerlink" title="内联width:480px!important样式覆盖"></a>内联width:480px!important样式覆盖</h1><ul>
<li>max-width:300px;覆盖</li>
<li>transform: scale(0.625, 1)</li>
<li>width:300px!important;</li>
<li>element.setAttribute(“style”,”width:300px!important;”)</li>
</ul>
<h1 id="1px问题"><a href="#1px问题" class="headerlink" title="1px问题"></a>1px问题</h1><p>伪类 + transform: scaleY(0.5);</p>
<h1 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h1><ul>
<li>content box/area的高由font-size决定的；</li>
<li>content box/area的宽等于其子行级盒子的外宽度(margin+border+padding+content width)之和。</li>
<li>inline-level box宽度大于父容器宽度时会被拆分成多个inline-level box</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2020/03/09/%E6%8E%98%E9%87%91/leetcode/</url>
    <content><![CDATA[<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><ul>
<li><p>splice(2,4) 从索引2开始，删除4个元素，把删除的部分以新数组返回</p>
</li>
<li><p>splice(n,0,x) 从索引n开始，不删除，把x添加到索引n的前面</p>
</li>
<li><p>push 向末尾追加</p>
</li>
<li><p>unshift 向开头追加</p>
</li>
<li><p>reverse 数组反序</p>
</li>
</ul>
<ul>
<li>concat 数组拼接</li>
<li>sort 数组排序 （默认字典序）<ul>
<li>sort((a,b)=&gt;{return a-b})</li>
</ul>
</li>
<li>V8 引擎 sort 函数数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。</li>
</ul>
<h2 id="bubble排序算法"><a href="#bubble排序算法" class="headerlink" title="bubble排序算法"></a>bubble排序算法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length<span class="number">-1</span> ;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">        [arr[j],arr[j<span class="number">-1</span>]] = [arr[j<span class="number">-1</span>],arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="insert排序算法"><a href="#insert排序算法" class="headerlink" title="insert排序算法"></a>insert排序算法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">        [arr[j],arr[j<span class="number">-1</span>]] = [arr[j<span class="number">-1</span>],arr[j]]</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="quick排序算法"><a href="#quick排序算法" class="headerlink" title="quick排序算法"></a>quick排序算法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr= arr.length &lt;=<span class="number">1</span>?arr:</span><br><span class="line">  quickSort(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; arr[<span class="number">0</span>])).concat(</span><br><span class="line">    arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item == arr[<span class="number">0</span>]),</span><br><span class="line">    quickSort(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; arr[<span class="number">0</span>]))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, begin = <span class="number">0</span>, end = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = begin</span><br><span class="line">  <span class="keyword">let</span> j = end</span><br><span class="line">  <span class="keyword">if</span> (j - i &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> value = arr[i]</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= value) &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= value) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  [arr[begin], arr[i]] = [arr[i], arr[begin]]</span><br><span class="line">  quickSort(arr, begin, i - <span class="number">1</span>)</span><br><span class="line">  quickSort(arr, i + <span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>Array.from(new Set(arr))</p>
<h2 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h2><p>Array.prototype.flat = function (){<br>  return [].concat(…this.map(item =&gt;(Array.isArray(item)?item.flat():[item])))<br>}</p>
<h2 id="负数放一边，正数放另一边-不开新数组，O-n-一次for循环-不要求排序"><a href="#负数放一边，正数放另一边-不开新数组，O-n-一次for循环-不要求排序" class="headerlink" title="负数放一边，正数放另一边,不开新数组，O(n)一次for循环 不要求排序"></a>负数放一边，正数放另一边,不开新数组，O(n)一次for循环 不要求排序</h2><p>输入:[-12,11,-13,-5,6,-7,5,-3,-6]<br>输出:[-12,-13,-5,-7,-3,-6,5,6,11]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [<span class="number">-12</span>,<span class="number">11</span>,<span class="number">-13</span>,<span class="number">-5</span>,<span class="number">6</span>,<span class="number">-7</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> j=<span class="number">0</span> <span class="comment">// 指向第一个遇到的正数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(input[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    [input[i],input[j]] = [input[j],input[i]]</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大于50的放一边，保证大于50的顺序"><a href="#大于50的放一边，保证大于50的顺序" class="headerlink" title="大于50的放一边，保证大于50的顺序"></a>大于50的放一边，保证大于50的顺序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [<span class="number">51</span>,<span class="number">32</span>,<span class="number">22</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">59</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> j=<span class="number">0</span> <span class="comment">// 指向第一个遇到的小于等于50的数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(input[i]&gt;<span class="number">50</span>)&#123;</span><br><span class="line">    [input[i],input[j]] = [input[j],input[i]]</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-121-买卖股票的最大利润"><a href="#leetcode-121-买卖股票的最大利润" class="headerlink" title="leetcode 121 买卖股票的最大利润"></a>leetcode 121 买卖股票的最大利润</h2><p>找每个点左边区间的最低点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length ===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> minPrice = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&lt;minPrice)&#123;</span><br><span class="line">      minPrice = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]-minPrice&gt;maxProfit) &#123;</span><br><span class="line">      maxProfit = arr[i]-minPrice</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-443-字符串压缩"><a href="#leetcode-443-字符串压缩" class="headerlink" title="leetcode 443 字符串压缩"></a>leetcode 443 字符串压缩</h2><p>输入： abcaaabbb<br>输出： abca3b3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringCompress</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">""</span></span><br><span class="line">  str = str.split(<span class="string">""</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;str.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i]===str[i+<span class="number">1</span>])&#123;</span><br><span class="line">      sum++</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i===str.length<span class="number">-2</span> || str[i]!==str[i+<span class="number">1</span>])&#123;</span><br><span class="line">      result+=str[i]+sum</span><br><span class="line">      sum=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-1-twosum"><a href="#leetcode-1-twosum" class="headerlink" title="leetcode 1 twosum"></a>leetcode 1 twosum</h2><p>输入：[2,3,11,7] target = 9<br>输出：[0,3]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">arr,target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> complement = target - arr[i]</span><br><span class="line">    <span class="keyword">if</span>(map.has(complement))&#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(complement),i]</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(arr[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-242-Valid-Anagram"><a href="#leetcode-242-Valid-Anagram" class="headerlink" title="leetcode 242 Valid Anagram"></a>leetcode 242 Valid Anagram</h2><p>输入：s = “anagram” t= “nagaram”<br>输出：true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validAnagram</span>(<span class="params">s1,s2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s1.length!== s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> slen = s1.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;slen;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.has(s1[i]))&#123;</span><br><span class="line">      map.set(s1[i],map.get(s1[i])+<span class="number">1</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      map.set(s1[i],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(map.has(s2[i]))&#123;</span><br><span class="line">      map.set(s2[i],map.get(s2[i])<span class="number">-1</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      map.set(s2[i],<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map.forEach(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// for(let number of map)&#123;</span></span><br><span class="line">  <span class="comment">//   if(number[1]) return false</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-3-字符串最长无重复字符子串"><a href="#leetcode-3-字符串最长无重复字符子串" class="headerlink" title="leetcode 3 字符串最长无重复字符子串"></a>leetcode 3 字符串最长无重复字符子串</h2><p>输入：”abcabcbb”<br>输出：3</p>
<p>输入： “bbbbbb”<br>输出：1</p>
<p>使用滑动窗口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slideWindow</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">  let res = []</span><br><span class="line">  if (s.length === 0) return 0</span><br><span class="line">  for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">set</span>.has(s[i])) &#123;</span><br><span class="line">      <span class="keyword">set</span>.add(s[i])</span><br><span class="line">        // maxLength = Math.max(maxLength, <span class="keyword">set</span>.size)</span><br><span class="line">      if (maxLength &lt; <span class="keyword">set</span>.size) &#123;</span><br><span class="line">        res = [...set]</span><br><span class="line">        maxLength = <span class="keyword">set</span>.size</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">set</span>.has(s[i])) &#123;</span><br><span class="line">        <span class="keyword">set</span>.delete(s[j])</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span>.add(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-125-验证回文"><a href="#leetcode-125-验证回文" class="headerlink" title="leetcode 125 验证回文"></a>leetcode 125 验证回文</h2><p>输入:”A man, a plan: a can alpanama”<br>输出：true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = str.toLowerCase().replace(<span class="regexp">/[^a-zA-z]/g</span>,<span class="string">""</span>)</span><br><span class="line">  <span class="keyword">if</span>(s.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = s.length <span class="number">-1</span></span><br><span class="line">  <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[left]!==s[right])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-20-括号配对"><a href="#leetcode-20-括号配对" class="headerlink" title="leetcode 20 括号配对"></a>leetcode 20 括号配对</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valide</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">const</span> mapping = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  mapping.set(<span class="string">')'</span>, <span class="string">'('</span>)</span><br><span class="line">  mapping.set(<span class="string">']'</span>, <span class="string">'['</span>)</span><br><span class="line">  mapping.set(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'('</span> || s[i] === <span class="string">'['</span> || s[i] === <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack[stack.length - <span class="number">1</span>] === mapping.get(s[i])) &#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length !== <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-56-合并区间"><a href="#leetcode-56-合并区间" class="headerlink" title="leetcode 56 合并区间"></a>leetcode 56 合并区间</h2><p>输入:[[1,3],[2,6],[8,10],[15,18]]<br>输出:[[1,6],[8,10],[15,18]]</p>
<p>根据区间起始位置排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;a[<span class="number">0</span>]-b[<span class="number">0</span>]&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> curr = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr[<span class="number">1</span>]&gt;=item[<span class="number">0</span>])&#123;</span><br><span class="line">      curr[<span class="number">1</span>] = <span class="built_in">Math</span>.max(curr[<span class="number">1</span>],item[<span class="number">1</span>])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.push(curr)</span><br><span class="line">      curr = item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(curr.length!==<span class="number">0</span>)&#123;</span><br><span class="line">    res.push(curr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-5-最长回文字串"><a href="#leetcode-5-最长回文字串" class="headerlink" title="leetcode 5 最长回文字串"></a>leetcode 5 最长回文字串</h2><p>输入:”babad”<br>输出：”bab”</p>
<p>从中心扩散</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestP</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.length&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">expandAroundCenter</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length &amp;&amp; s[left]===s[right])&#123;</span><br><span class="line">      <span class="keyword">if</span>(right-left+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">        maxLen = right - left +<span class="number">1</span></span><br><span class="line">        start = left</span><br><span class="line">      &#125;</span><br><span class="line">      left--</span><br><span class="line">      right++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    expandAroundCenter(i<span class="number">-1</span>,i+<span class="number">1</span>)</span><br><span class="line">    expandAroundCenter(i,i+<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substring(start,start+maxLen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-49-group-anagram"><a href="#leetcode-49-group-anagram" class="headerlink" title="leetcode 49 group anagram"></a>leetcode 49 group anagram</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupAnagram</span>(<span class="params">strs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(strs.length&lt;<span class="number">2</span>) <span class="keyword">return</span> strs </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> str <span class="keyword">of</span> strs)&#123;</span><br><span class="line">    <span class="keyword">const</span> characters = <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">      <span class="keyword">const</span> ascii = str.charCodeAt(i) - <span class="number">97</span></span><br><span class="line">      characters[ascii]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> key = characters.join(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span>(map.has(key))&#123;</span><br><span class="line">      map.set(key,[...map.get(key),str])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      map.set(key,[str])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result =[]</span><br><span class="line">  map.forEach(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;result.push(value)&#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-54-二元数组螺旋输出"><a href="#leetcode-54-二元数组螺旋输出" class="headerlink" title="leetcode 54 二元数组螺旋输出"></a>leetcode 54 二元数组螺旋输出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiralOrder</span> (<span class="params">matrix</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(matrix.length === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> bottom = matrix.length<span class="number">-1</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> direction = <span class="string">"right"</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right&amp;&amp; top&lt;=bottom)&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction === <span class="string">"right"</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =left;i&lt;=right;i++)&#123;</span><br><span class="line">        result.push(matrix[top][i])</span><br><span class="line">      &#125;</span><br><span class="line">      top++</span><br><span class="line">      direction =<span class="string">"down"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction === <span class="string">"down"</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =top;i&lt;=bottom;i++)&#123;</span><br><span class="line">        result.push(matrix[i][right])</span><br><span class="line">      &#125;</span><br><span class="line">      right--</span><br><span class="line">      direction =<span class="string">"left"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction === <span class="string">"left"</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =right;i&gt;=left;i--)&#123;</span><br><span class="line">        result.push(matrix[bottom][i])</span><br><span class="line">      &#125;</span><br><span class="line">      bottom--</span><br><span class="line">      direction =<span class="string">"top"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction === <span class="string">"top"</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =bottom;i&gt;=top;i--)&#123;</span><br><span class="line">        result.push(matrix[i][left])</span><br><span class="line">      &#125;</span><br><span class="line">      left++</span><br><span class="line">      direction =<span class="string">"right"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-73-矩阵0置"><a href="#leetcode-73-矩阵0置" class="headerlink" title="leetcode 73 矩阵0置"></a>leetcode 73 矩阵0置</h2><p>检查并标记第一行和第一列是否有0<br>使用第一行和第一列来标记其余行列是否含有0<br>最后处理第一行第一列标0</p>
<h2 id="leetcode-509-斐波那契数-动态规划-递归-记忆-topDown"><a href="#leetcode-509-斐波那契数-动态规划-递归-记忆-topDown" class="headerlink" title="leetcode 509 斐波那契数 动态规划(递归+记忆 topDown)"></a>leetcode 509 斐波那契数 动态规划(递归+记忆 topDown)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(N&lt;=<span class="number">1</span>) <span class="keyword">return</span> N</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> cache = []</span><br><span class="line">  cache[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">  cache[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[number]!== <span class="literal">undefined</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> cache[number]</span><br><span class="line">    &#125;</span><br><span class="line">    cache[number] = memoize(number<span class="number">-1</span>) + memoize(number<span class="number">-2</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[number]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = memoize(N)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15 三数之和"></a>leetcode 15 三数之和</h2><p>1.数组排序<br>2.从0遍历到倒数第二位 len-2<br>3.遇到重复数字跳过<br>4.start =i+1 end =len-1 i三者和&lt;=&gt;0?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span>  res = []</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">    <span class="keyword">let</span> nlen = nums.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nlen<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]===nums[i<span class="number">-1</span>])&#123;<span class="keyword">break</span>&#125;</span><br><span class="line">        <span class="keyword">let</span> start = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> end = nlen <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[start]+nums[end]===<span class="number">0</span>)&#123;</span><br><span class="line">                res.push([nums[i],nums[start],nums[end]])</span><br><span class="line">                start++</span><br><span class="line">                end--</span><br><span class="line">                <span class="keyword">while</span>(start&lt;end &amp;&amp; nums[start] === nums[start<span class="number">-1</span>])&#123;</span><br><span class="line">                    start++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(start&lt;end &amp;&amp; nums[end] === nums[end+<span class="number">1</span>])&#123;</span><br><span class="line">                    end--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[start]+nums[end] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-704-二分查找"><a href="#leetcode-704-二分查找" class="headerlink" title="leetcode 704 二分查找"></a>leetcode 704 二分查找</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left =<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left+(right-left)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]=== target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-153-旋转数组的二分搜索查找"><a href="#leetcode-153-旋转数组的二分搜索查找" class="headerlink" title="leetcode 153 旋转数组的二分搜索查找"></a>leetcode 153 旋转数组的二分搜索查找</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[right]&gt;nums[left])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left+(right-left)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid+<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid<span class="number">-1</span>]&gt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-217-存在重复元素"><a href="#leetcode-217-存在重复元素" class="headerlink" title="leetcode 217 存在重复元素"></a>leetcode 217 存在重复元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">    for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">set</span>.has(nums[i])) return true</span><br><span class="line">        <span class="keyword">set</span>.add(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-55-跳跃游戏"><a href="#leetcode-55-跳跃游戏" class="headerlink" title="leetcode 55 跳跃游戏"></a>leetcode 55 跳跃游戏</h2><p>top down</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nlen = nums.length</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(nlen).fill(<span class="number">0</span>)</span><br><span class="line">    dp[nlen<span class="number">-1</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[position]=== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[position]===<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> maxJump = <span class="built_in">Math</span>.min(nlen<span class="number">-1</span>,position+nums[position])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = position+<span class="number">1</span>;i&lt;=maxJump;i++)&#123;</span><br><span class="line">            <span class="keyword">const</span> jumpResult = jump(i)</span><br><span class="line">            <span class="keyword">if</span>(jumpResult === <span class="literal">true</span>)&#123;</span><br><span class="line">                dp[position] =<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[position] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = jump(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>buttom up</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nlen = nums.length</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(nlen).fill(<span class="number">0</span>)</span><br><span class="line">    dp[nlen<span class="number">-1</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nlen<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">const</span> maxJump = <span class="built_in">Math</span>.min(i+nums[i],nlen<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;=maxJump;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]===<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[<span class="number">0</span>] === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贪心</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxJump = nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]+i&gt;=maxJump)&#123;</span><br><span class="line">            maxJump = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxJump === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-198-打家劫舍"><a href="#leetcode-198-打家劫舍" class="headerlink" title="leetcode 198 打家劫舍"></a>leetcode 198 打家劫舍</h2><p>dp[i] 到第i家偷或不偷的最大价值<br>dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1])<br>返回dp[nums.length-1]</p>
<h2 id="leetcode-62-单独路径"><a href="#leetcode-62-单独路径" class="headerlink" title="leetcode 62 单独路径"></a>leetcode 62 单独路径</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memo = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        memo.push([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row =<span class="number">0</span>;row&lt;n;row++)&#123;</span><br><span class="line">        memo[row][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col=<span class="number">0</span>;col&lt;m;col++)&#123;</span><br><span class="line">        memo[<span class="number">0</span>][col] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row=<span class="number">1</span>;row&lt;n;row++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">1</span>;col&lt;m;col++)&#123;</span><br><span class="line">            memo[row][col] =  memo[row<span class="number">-1</span>][col] + memo[row][col<span class="number">-1</span>] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="headerlink" title="leetcode 53 最大子序和"></a>leetcode 53 最大子序和</h2><p>dp[i] 到第i位的子序和最大值 = Math.max(nums[i]+dp[i-1],nums[i])</p>
<h2 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode 349 两个数组的交集"></a>leetcode 349 两个数组的交集</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">nums1,nums2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">set</span> = new Set(nums2)</span><br><span class="line"></span><br><span class="line">  for(num of nums1)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">set</span>.has(num))&#123;</span><br><span class="line">      result.add(num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-152-乘积最大子序列"><a href="#leetcode-152-乘积最大子序列" class="headerlink" title="leetcode 152 乘积最大子序列"></a>leetcode 152 乘积最大子序列</h2><p>maxProductMemo[i] 到第i位 最大的乘积 = Math.max(nums[i],nums[i]<em>maxProductMemo[i-1],nums[i]</em>minProductMemo[i-1])<br>minProductMemo[i] 到第i位 最小的乘积 = Math.min(nums[i],nums[i]<em>maxProductMemo[i-1],nums[i]</em>minProductMemo[i-1])</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/二叉树</title>
    <url>/2020/03/05/interview/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[let BinarySearchTree = (function() {
  class Node {
    constructor(key) {
      this.key = key;
      this.left = null;
      this.right = null;
    }
  }

  class BinarySearchTree {
    constructor() {
      this.root = null;
    }

    insert(key) { //向二叉树插入一个新的键
      var newNode = new Node(key);

      if (this.root === null) {
        this.root = newNode;
      } else {
        this.insertNode(this.root, newNode);
      }
    }

    insertNode(node, newNode) {
      if (newNode.key < node.key) {
        if (node.left === null) {
          node.left = newNode;
        } else {
          this.insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
        } else {
          this.insertNode(node.right, newNode);
        }
      }
    }

    getRoot() { //获取根节点
      return this.root;
    }

    search(key) { //在二叉树查找一个键，如果节点存在，则返回true；如果不存在，则返回false。
      return this.searchNode(this.root, key);
    }

    searchNode(node, key) {
      if (node === null) {
        return false;
      }

      if (key < node.key) {
        return this.searchNode(node.left, key);

      } else if (key > node.key) {
        return this.searchNode(node.right, key);

      } else {
        return true;
      }
    }

    inOrderTraverse(callback) { //通过中序遍历方式遍历所有节点
      this.inOrderTraverseNode(this.root, callback);
    }

    inOrderTraverseNode(node, callback) {
      if (node !== null) {
        this.inOrderTraverseNode(node.left, callback);
        callback(node.key);
        this.inOrderTraverseNode(node.right, callback);
      }
    }

    preOrderTraverse(callback) { //通过先序遍历方式遍历所有节点。
      this.preOrderTraverseNode(this.root, callback);
    }

    preOrderTraverseNode(node, callback) {
      if (node !== null) {
        callback(node.key);
        this.preOrderTraverseNode(node.left, callback);
        this.preOrderTraverseNode(node.right, callback);
      }
    }

    postOrderTraverse(callback) { //通过后序遍历方式遍历所有节点。
      this.postOrderTraverseNode(this.root, callback);
    }

    postOrderTraverseNode(node, callback) {
      if (node !== null) {
        this.postOrderTraverseNode(node.left, callback);
        this.postOrderTraverseNode(node.right, callback);
        callback(node.key);
      }
    }

    min() { //返回二叉树中最小的键值
      return this.minNode(this.root);
    }

    minNode(node) {
      if (node) {
        while (node && node.left !== null) {
          node = node.left;
        }

        return node.key;
      }
      return null;
    }

    max() { //返回二叉树中最大的键值
      return this.maxNode(this.root);
    }

    maxNode(node) {
      if (node) {
        while (node && node.right !== null) {
          node = node.right;
        }

        return node.key;
      }
      return null;
    }

    remove(element) { //从书中移除某个键
      this.root = this.removeNode(this.root, element);
    }

    findMinNode(node) {
      while (node && node.left !== null) {
        node = node.left;
      }

      return node;
    }

    removeNode(node, element) {

      if (node === null) {
        return null;
      }

      if (element < node.key) {
        node.left = this.removeNode(node.left, element);
        return node;

      } else if (element > node.key) {
        node.right = this.removeNode(node.right, element);
        return node;

      } else {

        if (node.left === null && node.right === null) {
          node = null;
          return node;
        }


        if (node.left === null) {
          node = node.right;
          return node;

        } else if (node.right === null) {
          node = node.left;
          return node;
        }


        var aux = this.findMinNode(node.right);
        node.key = aux.key;
        node.right = this.removeNode(node.right, aux.key);
        return node;
      }
    };

  }
  return BinarySearchTree;
})()]]></content>
  </entry>
  <entry>
    <title>掘金/promise</title>
    <url>/2020/03/03/%E6%8E%98%E9%87%91/promise/</url>
    <content><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise的状态枚举</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="number">0</span>,</span><br><span class="line">  FULFILLED: <span class="number">1</span>,</span><br><span class="line">  REJECTED: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(task) &#123;</span><br><span class="line">    <span class="comment">// promise初始状态</span></span><br><span class="line">    <span class="keyword">this</span>.status = STATUS.PENDING;</span><br><span class="line">    <span class="comment">// resolve时返回的数据</span></span><br><span class="line">    <span class="keyword">this</span>.resolveData = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// reject时返回的数据</span></span><br><span class="line">    <span class="keyword">this</span>.rejectData = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// resolve和reject时执行的回调队列</span></span><br><span class="line">    <span class="comment">// promise的resolve和reject为异步响应时，即调用then时promise为</span></span><br><span class="line">    <span class="comment">// pending状态，则将传入then的函数加入该队列，等待promise resolve或</span></span><br><span class="line">    <span class="comment">// reject时执行该队列</span></span><br><span class="line">    <span class="keyword">this</span>.resolveList = [];</span><br><span class="line">    <span class="keyword">this</span>.rejectList = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * promise成功，执行resolveList回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.onResolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = STATUS.FULFILLED;</span><br><span class="line">          <span class="keyword">this</span>.resolveData = data;</span><br><span class="line">          <span class="keyword">this</span>.resolveList.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolveData)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * promise失败，执行rejectList回调</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>err </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">this</span>.onReject = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.REJECTED;</span><br><span class="line">        <span class="keyword">this</span>.rejectData = err;</span><br><span class="line">        <span class="keyword">this</span>.rejectList.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">          fn(<span class="keyword">this</span>.rejectData)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * promise解析, 根据then 返回数据类型不同封装不同的promise</span></span><br><span class="line"><span class="comment">     * 返回，以便实现then的链式调用及Promise的thenable特性 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*当前then return数据&#125;</span> </span>data </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*当前then的resolve&#125;</span> </span>resolve </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*当前then的reject&#125;</span> </span>reject </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.resolvePromise = <span class="function">(<span class="params">data, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// then return 的数据是一个promise</span></span><br><span class="line">      <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.status === STATUS.PENDING) &#123;</span><br><span class="line">          data.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resolvePromise(val, resolve, reject);</span><br><span class="line">          &#125;, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.status === STATUS.FULFILLED) &#123;</span><br><span class="line">          resolve(data.resolveData)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(data.rejectData)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// then return的是一个对象,若对象具有then方法，则可使用此方法作为新的then</span></span><br><span class="line">      <span class="comment">// Promise的thenable特性基于此</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data !== <span class="literal">null</span> &amp;&amp; data <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> then = data.then</span><br><span class="line">          <span class="keyword">if</span> (then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            then.call(data, (val) =&gt; &#123;</span><br><span class="line">              <span class="keyword">this</span>.resolvePromise(val, resolve, reject);</span><br><span class="line">            &#125;, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// then return 的是基本数据或undefined</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行传入的任务task</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      task(<span class="keyword">this</span>.onResolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.onReject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onReject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * then回调，返回一个promise</span></span><br><span class="line"><span class="comment">   * 说明：传入then的参数不是函数的话，直接忽略，及在返回的新promise中直接resolve或reject目前</span></span><br><span class="line"><span class="comment">   * promise的数据，传入then的参数是函数的话，则直接已目前promise的数据为参数执行该函数，并</span></span><br><span class="line"><span class="comment">   * 根据函数返回值情况确定新promise的状态</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*成功&#125;</span> </span>onFulfilled </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*失败&#125;</span> </span>onRejected </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise;</span><br><span class="line">    <span class="comment">// pending状态下将传入then的函数加入promise对应的回调队列</span></span><br><span class="line">    <span class="comment">// 等待promise状态改变后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.resolveList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 传入then的参数不是函数则忽略</span></span><br><span class="line">          <span class="keyword">if</span> (!(onFulfilled <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">            resolve(<span class="keyword">this</span>.resolveData)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data = onFulfilled(<span class="keyword">this</span>.resolveData)</span><br><span class="line">            <span class="keyword">this</span>.resolvePromise(data, resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.rejectList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 传入then的参数不是函数则忽略</span></span><br><span class="line">          <span class="keyword">if</span> (!(onRejected <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">            reject(<span class="keyword">this</span>.rejectData)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data = onRejected(<span class="keyword">this</span>.rejectData)</span><br><span class="line">            <span class="keyword">this</span>.resolvePromise(data, resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fulfilled状态下以promise的resolveData为参数执行传入then的</span></span><br><span class="line">    <span class="comment">// 成功回调函数，再根据此函数的返回值封装新的promise返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.FULFILLED) &#123;</span><br><span class="line">      promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 传入then的参数不是函数则忽略，直接resolve</span></span><br><span class="line">        <span class="keyword">if</span> (!(onFulfilled <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">          resolve(<span class="keyword">this</span>.resolveData)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> data = onFulfilled(<span class="keyword">this</span>.resolveData)</span><br><span class="line">          <span class="keyword">this</span>.resolvePromise(data, resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rejected状态类似fulfilled状态</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 传入then的参数不是函数则忽略，直接reject</span></span><br><span class="line">        <span class="keyword">if</span> (!(onRejected <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">          reject(<span class="keyword">this</span>.rejectData)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> data = onRejected(<span class="keyword">this</span>.rejectData)</span><br><span class="line">          <span class="keyword">this</span>.resolvePromise(data, resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * catch方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*reject函数&#125;</span> </span>rejectFn </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">catch</span> (rejectFn) &#123;</span><br><span class="line">    <span class="comment">//不是函数直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(rejectFn <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.rejectList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 没有错误信息则不执行catch中的函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.rejectData !== <span class="literal">null</span>) &#123;</span><br><span class="line">          rejectFn(<span class="keyword">this</span>.rejectData)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status = STATUS.REJECTED) &#123;</span><br><span class="line">      <span class="comment">// 没有错误信息则不执行catch中的函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.rejectData !== <span class="literal">null</span>) &#123;</span><br><span class="line">        rejectFn(<span class="keyword">this</span>.rejectData)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * resolve方法，</span></span><br><span class="line"><span class="comment">   * value为promise直接返回返回一个以value为resolveData的完成态promise</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * reject方法，类似resolve方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>value </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * all方法，返回一个新的promise</span></span><br><span class="line"><span class="comment">   * 参数为promise数组</span></span><br><span class="line"><span class="comment">   * 成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">promiseArray</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> all(promiseArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(promiseArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"parameter must be array"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (promiseArray.length === <span class="number">0</span>) &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promiseArray.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            item.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">              result[index] = res</span><br><span class="line">              i++</span><br><span class="line">              <span class="keyword">if</span> (i === promiseArray.length) &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果传入的不是promise，则直接作为结果填入结果数组中</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            result[index] = item</span><br><span class="line">            i++</span><br><span class="line">            <span class="keyword">if</span> (i === promiseArray.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * race方法，返回一个新的promise</span></span><br><span class="line"><span class="comment">   * 参数为promise数组</span></span><br><span class="line"><span class="comment">   * 返回最先执行完的promise的结果，不论resolve还是reject</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>promiseArray </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> race(promiseArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(promiseArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"parameter must be array"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标识符，有一个promise执行完成设为true，返回结果</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseArray.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          item.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">              flag = <span class="literal">true</span></span><br><span class="line">              resolve(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">              flag = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的不是promise，则直接作为结果</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">            resolve(item)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>掘金/整理1</title>
    <url>/2020/03/03/%E6%8E%98%E9%87%91/%E6%95%B4%E7%90%861/</url>
    <content><![CDATA[<h1 id="JS-基础知识点"><a href="#JS-基础知识点" class="headerlink" title="JS 基础知识点"></a>JS 基础知识点</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul>
<li><p>原始类型有哪几种？</p>
<ul>
<li>boolean null  undefined number  string  symbol bigint</li>
<li>undefined.toString() -&gt; TypeError<ul>
<li>原始类型存储的都是值，是没有函数可以调用</li>
</ul>
</li>
<li>‘1’.toString() -&gt; ‘1’<ul>
<li>强制类型转换</li>
</ul>
</li>
</ul>
</li>
<li><p>number是浮点类型的</p>
<ul>
<li>0.1 + 0.2 !== 0.3</li>
<li>使用 Math.abs(a-b) &lt; Number.EPSILON</li>
</ul>
</li>
<li><p>null 是对象嘛？</p>
<ul>
<li>不是 typeof null -&gt; object</li>
<li>js 32位系统000 开头代表是对象，然而 null 表示为全零<a id="more"></a>
<h2 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h2></li>
</ul>
</li>
<li><p>typeof 是否能正确判断类型？</p>
<ul>
<li>原始类型(除了 null) 正确</li>
<li>typeof [] // ‘object’</li>
<li>typeof {} // ‘object’</li>
<li>typeof console.log // ‘function’</li>
</ul>
</li>
<li><p>instanceof 能正确判断对象的原理是什么？</p>
<ul>
<li>原型链</li>
<li>instanceof 可以被[Symbol.hasInstance]改写不可靠</li>
</ul>
</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><p>转Boolean</p>
<ul>
<li>false： undefined， null， false， NaN， ‘’， 0， -0</li>
<li>true:其他(包括对象类型)</li>
</ul>
</li>
<li><p>对象转原始</p>
<ul>
<li>调用优先级：[Symbol.toPrimitive] &gt; valueOf(非字符串) &gt; toString</li>
</ul>
</li>
<li><p>‘+’运算</p>
<ul>
<li>遇字符串转字符串</li>
<li>否则转为数字或者字符串 <ul>
<li>4 + [1,2,3] // “41,2,3”</li>
<li>‘a’ + + ‘b’ // -&gt; “aNaN”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>new &gt; bind &gt; 对象调用 &gt; 直接调用</li>
</ul>
<h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><ul>
<li><p>== 比较值</p>
<ul>
<li>null == undefine</li>
<li>string/boolean 转number再比较<ul>
<li>1 == ‘1’     </li>
<li>‘1’ == true  </li>
</ul>
</li>
<li>对象转为基本类型再比较<ul>
<li>[] == ![] // true  <ul>
<li><code>![]</code>:boolean类型 false 转number 类型 0</li>
<li><code>[]</code>:对象类型 转string类型”” 转number类型 0 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>=== 比较值和类型</p>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>函数+词法环境</li>
<li>函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul>
<li>Object.assign({},source)</li>
<li>{ …source }</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>JSON.parse(JSON.stringify(object))<ul>
<li>函数、 undefined 或者 symbol出错</li>
<li>循环引用的对象出错</li>
</ul>
</li>
<li>lodash库</li>
<li>自定义实现：<ul>
<li><code>let isObject = o =&gt; {
return (typeof o === &#39;object&#39; || typeof o === &#39;function&#39;) &amp;&amp; o !== null
}</code>  </li>
<li><code>let isArray = Array.isArray(obj)</code></li>
</ul>
</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li>原型：共享的属性和方法</li>
<li>Object 是所有对象(包括函数)的爸爸，所有对象都可以通过 <strong>proto</strong> 找到它</li>
<li>Function 是所有函数的爸爸，所有函数都可以通过 <strong>proto</strong> 找到它<ul>
<li>Function.prototype.<strong>proto</strong> === Object.prototype</li>
<li></li>
</ul>
</li>
<li>Cat.prototype.<strong>isPrototypeOf</strong>(cat1):判断原型对象与实例关系</li>
<li>cat1.<strong>hasOwnProperty</strong>(“name”)：判断某一个属性到底是本地属性，还是继承自prototype对象的属性</li>
<li>“type” <strong>in</strong> cat1:某个实例是否含有某个(实例或原型)属性</li>
</ul>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="var、let-及-const"><a href="#var、let-及-const" class="headerlink" title="var、let 及 const"></a>var、let 及 const</h2><ul>
<li>什么是提升？<ul>
<li>变量还没有被声明，但是我们却可以使用这个未被声明的变量</li>
<li>函数会被提升，并且优先于变量提升</li>
</ul>
</li>
<li>什么是暂时性死区？</li>
<li>var、let 及 const 区别？<ul>
<li>全局作用域下let 和 const 变量不会挂载到 window|globle</li>
<li>暂时性死区（不能在声明前使用） </li>
<li>块级作用域<ul>
<li>const 声明必须赋值，赋值后不能重新赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><ul>
<li><strong>寄生组合式继承</strong>，父类的原型赋值给了子类，并且将构造函数设置为子类<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child &#123;<span class="attr">val</span>: <span class="number">1</span>&#125;</span><br><span class="line">  val: <span class="number">1</span></span><br><span class="line">  __proto__: Parent</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ Child(value)</span><br><span class="line">    __proto__: Object</span><br></pre></td></tr></table></figure>
<h2 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h2><ul>
<li>class 只是语法糖，本质还是函数。</li>
<li>使用 extends 表明继承自哪个父类</li>
<li>子类构造函数中必须调用 super，可以看成 Parent.call(this, value)。</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>解决了命名冲突、污染全局作用域的问题<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">exports.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.a </span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure>
<h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><ul>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持</li>
<li>CommonJS 是同步导入(服务端) :文件本地，后者是异步导入(浏览器)：下载文件影响渲染</li>
<li>CommonJS值拷贝，后者实时绑定同一内存地址</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul>
<li>Vue3.0 通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式</li>
<li>无需一层层递归为每个属性添加代理，一次即可完成以上操作</li>
</ul>
<h2 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map, filter, reduce"></a>map, filter, reduce</h2><ul>
<li>array.map(function(当前索引元素,索引,原数组), this绑定)</li>
<li>array.filter(function(当前索引元素,索引,原数组), this绑定)</li>
<li>array.reduce(function(累加值, 当前索引元素, 索引, 原数组), 初始值)</li>
</ul>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul>
<li><p>回调函数有什么缺点？<br>回调地狱、不能使用 try catch 捕获错误，不能直接 return</p>
</li>
<li><p>如何解决回调地狱问题？</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>状态机，控制函数的执行</p>
</li>
<li><p>Generator 返回一个迭代器</p>
<ul>
<li>第一次 next 时，传参会被忽略</li>
<li>第二次 next 时，传入的参数等于上一个 yield 的返回值，<ul>
<li>如果不传参，yield 永远返回 undefined<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li>构造 Promise 的时候，构造函数内部的代码是立即执行的</li>
<li>无法取消 Promise，错误需要通过回调函数捕获</li>
</ul>
<h2 id="async-及-await"><a href="#async-及-await" class="headerlink" title="async 及 await"></a>async 及 await</h2><ul>
<li>把*换成了async，把yield换成了await</li>
<li>一个函数如果加上 async ，那么该函数就会返回一个 Promise<ul>
<li>async 就是将函数返回值使用 Promise.resolve()包裹</li>
</ul>
</li>
<li>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</li>
<li>没有依赖性的话，完全可以使用 Promise.all 的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConstant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncConstant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function getAsyncConstant() &#123;</span></span><br><span class="line"><span class="comment">  return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">  return 1;</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>)=&gt;</span> &#123;</span><br><span class="line">    resolved(<span class="number">1</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function getPromise() &#123;</span></span><br><span class="line"><span class="comment">  return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">    return new Promise((resolved, rejected) =&gt; &#123;</span></span><br><span class="line"><span class="comment">      resolved(1);</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line"><span class="keyword">await</span> getConstant();</span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"><span class="keyword">await</span> getPromise();</span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"><span class="keyword">await</span> getAsyncConstant();</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function test() &#123;</span></span><br><span class="line"><span class="comment">return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">  a = 2;</span></span><br><span class="line"><span class="comment">  c = 1;</span></span><br><span class="line"><span class="comment">  return getConstant();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  d = 3;</span></span><br><span class="line"><span class="comment">  return getPromise();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  d = 4;</span></span><br><span class="line"><span class="comment">  return getAsyncConstant();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  return 2;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br></pre></td></tr></table></figure>

<h2 id="setTimeout、setInterval、requestAnimationFrame"><a href="#setTimeout、setInterval、requestAnimationFrame" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame"></a>setTimeout、setInterval、requestAnimationFrame</h2><ul>
<li>setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行<ul>
<li>setInterval对自己调用的代码是否报错漠不关心。</li>
<li>setInterval无视网络延迟</li>
<li>setInterval并不定时<ul>
<li>给setTimeout设置时间后，在最后调用自身,替代setInterval</li>
</ul>
</li>
</ul>
</li>
<li>浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定<ul>
<li>requestAnimationFrame页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停</li>
<li>使用setTimeout实现的动画，浪费CPU资源。</li>
</ul>
</li>
<li>requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次</li>
</ul>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p><a href="./promise">promise</a></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>进程是cpu<strong>资源分配</strong>的最小单位</li>
<li>线程是cpu<strong>调度</strong>的最小单位</li>
</ul>
<p>进程：工厂 线程：工人</p>
<ul>
<li>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</li>
<li>工厂之间的相互独立 -&gt; 进程之间相互独立</li>
<li>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</li>
<li>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</li>
<li>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</li>
</ul>
<h3 id="SharedWorker与WebWorker"><a href="#SharedWorker与WebWorker" class="headerlink" title="SharedWorker与WebWorker"></a>SharedWorker与WebWorker</h3><ul>
<li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</li>
<li>SharedWorker是浏览器所有页面共享的</li>
<li>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</li>
</ul>
<h3 id="url展示的过程"><a href="#url展示的过程" class="headerlink" title="url展示的过程"></a>url展示的过程</h3><ul>
<li>DNS 解析 域名 -&gt; ip （DNS缓存 浏览器/操作系统/hosts文件 -》本地配置的首选DNS服务器 -》运营商的DNS代我们的浏览器发起迭代DNS解析请求 -》com IP -》test.com IP -&gt; <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> IP</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
<li>css是由单独的下载线程异步下载的 </li>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建） </li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）  </li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面</li>
</ul>
</li>
</ul>
<ul>
<li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成</li>
<li>onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li>
</ul>
<h4 id="操作-DOM-性能很差"><a href="#操作-DOM-性能很差" class="headerlink" title="操作 DOM 性能很差?"></a>操作 DOM 性能很差?</h4><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。 -&gt;线程之间的通信<br>操作 DOM 可能还会带来重绘回流</p>
<p>分批次部分渲染 DOM -&gt; requestAnimationFrame<br>只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</p>
<h4 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染?"></a>阻塞渲染?</h4><p>浏览器在解析到 script 标签时，会暂停构建 DOM -&gt; script 标签放在 body 标签底部<br>defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行<br> async一旦下载完,渲染引擎就会中断渲染,执行这个脚本以后,再继续渲染</p>
<p><img src="http://segmentfault.com/img/bVcQV0" alt="async和defer"></p>
<h4 id="回流-和-重绘"><a href="#回流-和-重绘" class="headerlink" title="回流 和 重绘"></a>回流 和 重绘</h4><p>回流必定会发生重绘，重绘不一定会引发回流。</p>
<ul>
<li>减少重绘和回流<ul>
<li>使用 transform 替代 top</li>
<li>visibility 替换 display: none</li>
<li>不使用table布局</li>
<li>动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>
<li>CSS 选择符从右往左匹配查找，避免节点层级过多</li>
</ul>
</li>
</ul>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li>JS 是单线程的，先跑<strong>执行栈里</strong>的<strong>同步任务</strong>，然后再跑<strong>任务队列</strong>的<strong>异步任务</strong>。</li>
<li>当执行栈的栈空，js会读取任务队列，<ul>
<li>执行一个宏任务(先执行同步代码)–&gt;执行所有微任务–&gt;UI render</li>
<li>宏任务：主代码块 &gt; setTimeout / setInterval &gt; IO回调 &gt; requestAnimationFrame &gt; UIrender(重绘)</li>
<li>微任务：Promise回调</li>
</ul>
</li>
</ul>
<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="built_in">window</span></span><br><span class="line">  context.fn =<span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> fn(...args,...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context,args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = object.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> Constructor = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  obj.__proto__ = Constructor.prototype</span><br><span class="line">  <span class="keyword">const</span> result = Constructor.call(obj,...args)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span>? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof2</span>(<span class="params">Left,Right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = Right.prototype</span><br><span class="line">  <span class="keyword">let</span> proto = Left.__proto__</span><br><span class="line">  <span class="keyword">while</span>(proto)&#123;</span><br><span class="line">    <span class="keyword">if</span>(proto == prototype)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 != 0.3"></a>0.1 + 0.2 != 0.3</h2><ul>
<li>parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 </li>
<li>(0.1 + 0.2 - 0.3)&lt;Number.EPSILON</li>
</ul>
<h2 id="V8垃圾回收"><a href="#V8垃圾回收" class="headerlink" title="V8垃圾回收"></a>V8垃圾回收</h2><ul>
<li>GC算法采用分段式垃圾回收机制</li>
<li>新生代算法  From 空间满了和 To 空间交换</li>
<li>老生代算法 标记清除算法和标记压缩算法</li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><ul>
<li><p>window 往事件触发处传播，遇到注册的捕获事件会触发</p>
</li>
<li><p>传播到事件触发处时触发注册的事件</p>
</li>
<li><p>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</p>
</li>
<li><p>节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p>
</li>
</ul>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span> <span class="comment">//useCapture</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>stopPropagation 阻止事件冒泡</p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><ul>
<li>节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</li>
<li>使用event.target 判断子节点</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li>协议、域名或者端口有一个不同就是跨域</li>
<li>防止 CSRF 跨站请求伪造 攻击<ul>
<li>JSONP （只限于 get 请求）</li>
<li>CORS 服务端设Access-Control-Allow-Origin</li>
<li>document.domain <ul>
<li>二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</li>
<li>只需要给页面添加 document.domain = ‘test.com</li>
</ul>
</li>
<li>postMessage<ul>
<li>用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line">  <span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>)</span><br><span class="line">  <span class="comment">// 接收消息端</span></span><br><span class="line">  <span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  mc.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>document.cookie=”username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/“;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name,day</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">let</span> datems = date.getTime() + day*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span></span><br><span class="line">  date.setTime(datems)</span><br><span class="line">  <span class="built_in">document</span>.cookie=<span class="string">"name="</span>+name+<span class="string">";expires="</span>+date.toGMTString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"matt"</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>http-only    不能通过 JS 访问 Cookie，减少 XSS 攻击</li>
<li>secure    只能在协议为 HTTPS 的请求中携带</li>
<li>same-site    规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</li>
</ul>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><ul>
<li>数据请求分为发起网络请求、后端处理、浏览器响应三个步骤</li>
<li>直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致</li>
</ul>
<p>优先级：</p>
<ul>
<li>Service Worker （HTTPS）</li>
<li>Memory Cache<ul>
<li>内存缓存读取高效，可是缓存持续性短，随进程的释放而释放</li>
<li>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</li>
</ul>
</li>
<li>Disk Cache<ul>
<li>硬盘缓存</li>
</ul>
</li>
<li>Push Cache （HTTP2.0）<ul>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
</li>
</ul>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>HTTP Header：Expires 和 Cache-Control 。<br>强缓存表示在缓存期间不需要请求，state code 为 200。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h4><p>HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。</p>
<p>Cache-Control 可以在请求头或者响应头中设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>HTTP Header 实现：Last-Modified 和 ETag<br>如果缓存过期了，就需要发起请求验证资源是否有更新。</p>
<ol>
<li>客户端请求一个页面（A）。</li>
<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。</li>
<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</li>
</ol>
<h4 id="Last-Modified（响应头）-和-If-Modified-Since（请求头）"><a href="#Last-Modified（响应头）-和-If-Modified-Since（请求头）" class="headerlink" title="Last-Modified（响应头） 和 If-Modified-Since（请求头）"></a>Last-Modified（响应头） 和 If-Modified-Since（请求头）</h4><p>本地文件最后修改日期</p>
<h4 id="ETag-响应头-和-If-None-Match-（请求头）"><a href="#ETag-响应头-和-If-None-Match-（请求头）" class="headerlink" title="ETag(响应头) 和 If-None-Match （请求头）"></a>ETag(响应头) 和 If-None-Match （请求头）</h4><p>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>频繁变动的资源 ：<br>Cache-Control: no-cache 使浏览器每次都请求服务器<br>ETag /Last-Modified 来验证资源是否有效，减少响应体积</p>
<p>代码文件：<br>Cache-Control: max-age=31536000</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h2><p>持久型：攻击的代码被服务端写入进数据库<br>非持久型：修改 URL 参数的方式加入攻击代码，诱导用户访问链接</p>
<ul>
<li>解决：<ul>
<li>escape库 转义字符 js-xss </li>
<li>CSP（Content-Security-Policy）<br>建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。<ul>
<li>设置 HTTP Header 中的 Content-Security-Policy</li>
<li>设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h2><p>攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p>
<ul>
<li>解决：<ul>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie <ul>
<li>设置 SameSite 表示 Cookie 不随着跨域请求发送</li>
</ul>
</li>
<li>阻止第三方网站请求接口<ul>
<li>验证 Referer 来判断该请求是否为第三方网站发起的</li>
</ul>
</li>
<li>请求时附带验证信息，比如验证码或者 Token<ul>
<li>服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击</p>
<ul>
<li>解决：<ul>
<li>设置X-FRAME-OPTIONS响应头</li>
<li>js： top.location = self.location</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>HTTPS解决</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li><p>content方面</p>
<ul>
<li>减少HTTP请求：合并文件、CSS精灵、inline Image</li>
<li>减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名</li>
<li>减少DOM元素数量</li>
</ul>
</li>
<li><p>Server方面</p>
<ul>
<li>使用CDN</li>
<li>配置ETag</li>
<li>对组件使用Gzip压缩</li>
</ul>
</li>
<li><p>Cookie方面</p>
<ul>
<li>减小cookie大小</li>
</ul>
</li>
<li><p>css方面</p>
<ul>
<li>将样式表放到页面顶部</li>
<li>不使用CSS表达式</li>
<li>使用<link>不使用@import</li>
</ul>
</li>
<li><p>Javascript方面</p>
<ul>
<li>将脚本放到页面底部</li>
<li>将javascript和css从外部引入</li>
<li>压缩javascript和css</li>
<li>删除不需要的脚本</li>
<li>减少DOM访问</li>
</ul>
</li>
<li><p>图片方面</p>
<ul>
<li>雪碧图</li>
<li>矢量图 svg</li>
<li>小图片转base64</li>
</ul>
</li>
</ul>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行</p>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>一定时间段内没有再触发事件，事件处理函数才会执行一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(fn,time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>一定时间内只调用一次事件处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载<br><code>&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;</code></p>
<ol>
<li>将加载和执行分离开，不阻塞渲染和document的onload事件</li>
<li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出的情况</li>
</ol>
<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染<br><code>&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot;&gt;</code></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>静态资源尽量使用 CDN 加载</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象<br>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。<br><img src="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul>
<li>操作 DOM 是很慢的,操作 JS 对象会快很多</li>
<li>判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM</li>
</ul>
<h2 id="前端路由-vue-router"><a href="#前端路由-vue-router" class="headerlink" title="前端路由 vue router"></a>前端路由 vue router</h2><p>监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面</p>
<ul>
<li>Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li>
<li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li>
<li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li>
</ul>
<h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a> 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></p>
<p>window.addEventListener(‘hashchange’, () =&gt; {… })</p>
<h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><ul>
<li>不会引起页面的刷新，只会更新浏览器的历史记录</li>
<li>HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h1><h2 id="生命周期顺序"><a href="#生命周期顺序" class="headerlink" title="生命周期顺序"></a>生命周期顺序</h2>加载渲染过程</li>
</ul>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p>子组件全局状态更新过程</p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p>销毁过程</p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h2 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h2><p>创建-挂载-更新-销毁</p>
<ul>
<li>beforeCreate前，也就是new Vue的时候会初始化事件和生命周期；（获取不到 props 或者 data 中的数据）</li>
<li>beforeCreate和created之间会挂载Data，绑定事件；接下来会根据el挂载页面元素，如果没有设置el则生命周期结束，直到手动挂载；el挂载结束后，根据templete/outerHTML(el)渲染页面；</li>
<li>在beforeMount前虚拟DOM已经创建完成；</li>
<li>之后在mounted前，将vm.$el替换掉页面元素el;mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）；</li>
<li>之后发生数据变化时触发beforeUpdate和updated进行一些操作；</li>
<li>最后主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等；</li>
<li>destroyed时仅存在Dom节点，其他所有东西已自动销毁。</li>
</ul>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ul>
<li>父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件</li>
<li>v-model</li>
<li>.sync语法糖</li>
</ul>
<p>兄弟组件通信</p>
<ul>
<li>this.$parent.$children.name</li>
</ul>
<p>跨多层级组件通信<br>任意组件</p>
<ul>
<li>Vuex 或者 Event Bus</li>
</ul>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><ul>
<li>选项合并<ul>
<li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li>
<li>同名钩子函数将合并为一个数组，，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
</li>
</ul>
<h2 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h2><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</p>
<p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。  </p>
<h2 id="keep-alive-组件"><a href="#keep-alive-组件" class="headerlink" title="keep-alive 组件"></a>keep-alive 组件</h2><p>组件切换时保存一些组件的状态防止多次渲染<br>keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p>
<h2 id="v-show-与-v-if"><a href="#v-show-与-v-if" class="headerlink" title="v-show 与 v-if"></a>v-show 与 v-if</h2><p>v-show 只是在 display: none 和 display: block 之间切换<br>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件,在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>
<h2 id="data-对象还是函数"><a href="#data-对象还是函数" class="headerlink" title="data 对象还是函数"></a>data 对象还是函数</h2><p>组件复用时所有组件实例都会共享 data，对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。</p>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>window.onerror 代码运行错误<br>异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><ul>
<li>无法复用链接，完成即断开，重新慢启动和 TCP 3次握手 <ul>
<li>TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动</li>
<li>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，</li>
</ul>
</li>
<li>head of line blocking: 线头阻塞，导致请求之间互相影响 第一个请求阻塞后，后面的请求都需要等待<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2></li>
<li>长连接(默认 keep-alive)，复用。 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>
<li>host 字段指定对应的虚拟站点 同一个IP同一个端口不同的虚拟Web站点</li>
<li>新增功能:<ul>
<li>断点续传 要求服务器从文件XXXX字节处开始传送</li>
<li>身份认证</li>
<li>状态管理</li>
<li>cache 缓存<ul>
<li>Cache-Control</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Etag<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2></li>
</ul>
</li>
</ul>
</li>
<li>多路复用。 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 双向数据流</li>
<li>二进制分帧层。应用层http和传输层tcp之间 将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码</li>
<li>首部压缩。压缩http请求报文头部 首部压缩使得整个HTTP数据包小了很多，传输也就会更快</li>
<li>服务端推送。 一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>工厂模式：vue创建组件 createComponent</li>
<li>单例模式：全局缓存、全局状态管理 vuex单例 install</li>
<li>装饰器模式： ES7 中的装饰器语法</li>
<li>发布订阅模式：实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 get 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p>!important &gt; style 属性 &gt; id &gt; class &gt; tag</p>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><ul>
<li>absolute + transform</li>
<li>flex + justify-content + align-items</li>
<li>fixed margin:auto left:0 right:0 right:0 bottom：0</li>
</ul>
<h2 id="position-float-display"><a href="#position-float-display" class="headerlink" title="position float display"></a>position float display</h2><p>position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><ul>
<li><p>垂直放置</p>
</li>
<li><p>margin重叠</p>
</li>
<li><p>margin box与包含块border box的左边相接触</p>
</li>
<li><p>不与float重叠</p>
</li>
<li><p>浮动高度</p>
</li>
<li><p>不影响外部布局</p>
</li>
<li><p>根元素</p>
</li>
<li><p>float不默认</p>
</li>
<li><p>overflow不默认</p>
</li>
<li><p>postition：absolute 和fixed</p>
</li>
<li><p>display：inline-block 和flex</p>
</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><p>获取ua</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.userAgent</span><br><span class="line"><span class="keyword">var</span> isChrome = ua.indexOf(<span class="string">'Chrome'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isChrome)</span><br></pre></td></tr></table></figure>

<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>屏幕宽高<br>screen.width + screen.height<br>可见页面宽高<br>document.body.clientWidth + document.body.clientHeight</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>获取网址、协议、path、参数、hash 等<br>// 例如当前网址是 <a href="https://juejin.im/timeline/frontend?a=10&amp;b=10#some" target="_blank" rel="noopener">https://juejin.im/timeline/frontend?a=10&amp;b=10#some</a><br>console.log(location.href)  // <a href="https://juejin.im/timeline/frontend?a=10&amp;b=10#some" target="_blank" rel="noopener">https://juejin.im/timeline/frontend?a=10&amp;b=10#some</a><br>console.log(location.protocol) // https:<br>console.log(location.pathname) // /timeline/frontend<br>console.log(location.search) // ?a=10&amp;b=10<br>console.log(location.hash) // #some</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history.back()<br>history.forward()</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取-DOM-节点"><a href="#获取-DOM-节点" class="headerlink" title="获取 DOM 节点"></a>获取 DOM 节点</h2><p>var div1 = document.getElementById(‘div1’)<br>var divList = document.getElementsByTagName(‘div’)<br>var containerList = document.getElementsByClassName(‘container’)<br>var pList = document.querySelectorAll(‘p’)</p>
<h2 id="DOM-property"><a href="#DOM-property" class="headerlink" title="DOM property"></a>DOM property</h2><p>p可以有style属性，有className nodeName nodeType属性。注意，这些都是 JS 范畴的属性，符合 JS 语法标准的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(p.style.width)  <span class="comment">// 获取样式</span></span><br><span class="line">p.style.width = <span class="string">'100px'</span>  <span class="comment">// 修改样式</span></span><br><span class="line"><span class="built_in">console</span>.log(p.className)  <span class="comment">// 获取 class</span></span><br><span class="line">p.className = <span class="string">'p1'</span>  <span class="comment">// 修改 class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 nodeName 和 nodeType</span></span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName)</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeType)</span><br></pre></td></tr></table></figure>

<h2 id="HTML-attribute"><a href="#HTML-attribute" class="headerlink" title="HTML attribute"></a>HTML attribute</h2><p>attribute 就是对 HTML 属性的 get 和 set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</span><br><span class="line">p.getAttribute(<span class="string">'data-name'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'juejin'</span>)</span><br><span class="line">p.getAttribute(<span class="string">'style'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</span><br></pre></td></tr></table></figure>
<p>get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p>
<h2 id="常见DOM-API"><a href="#常见DOM-API" class="headerlink" title="常见DOM API"></a>常见DOM API</h2><h3 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h3><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：</p>
<p>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题 </p>
<h3 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h3><p>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<p>要注意几个特点：</p>
<p>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p>
<h3 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h3><p>document.getElementById<br>document.getElementsByTagName<br>document.getElementsByName<br>document.getElementsByClassName<br>document.querySelector和document.querySelectorAll:通过css选择器来查找元素，注意选择器要符合CSS选择器的规则,使用的深度优先搜索来获取元素</p>
<h3 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h3><ol>
<li>父关系型api</li>
</ol>
<p>parentNode：Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null<br>2. 兄弟关系型api</p>
<p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。<br>3. 子关系型api</p>
<p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。   </p>
<h3 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h3><p>setAttribute：根据名称和值修改元素的特性eg:element.setAttribute(name, value);<br>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串.</p>
<h3 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h3><p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：</p>
<p>var style = window.getComputedStyle(element[, pseudoElt]);<br>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式   </p>
<p>getBoundingClientRect   </p>
<p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：</p>
<p>var clientRect = element.getBoundingClientRect();<br>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接</p>
]]></content>
  </entry>
  <entry>
    <title>阮一峰/400</title>
    <url>/2020/02/25/%E9%98%AE%E4%B8%80%E5%B3%B0/400/</url>
    <content><![CDATA[<h2 id="node如何和MySQL进行通信"><a href="#node如何和MySQL进行通信" class="headerlink" title="node如何和MySQL进行通信"></a>node如何和MySQL进行通信</h2><p>var mysql  = require(‘mysql’);<br>//创建一个connection<br>var connection = mysql.createConnection({<br>  host     : ‘192.168.0.200’,       //主机<br>  user     : ‘root’,               //MySQL认证用户名<br>  password : ‘abcd’,        //MySQL认证用户密码<br>  port: ‘3306’,                   //端口号<br>});<br>connection.connect(()=&gt;{})<br>connection.query(‘sql’,()=&gt;{})<br>connection.end(()=&gt;{})</p>
]]></content>
  </entry>
  <entry>
    <title>interview/面试</title>
    <url>/2020/02/24/interview/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h1 id="JS获取当年当月最后一天日期"><a href="#JS获取当年当月最后一天日期" class="headerlink" title="JS获取当年当月最后一天日期"></a>JS获取当年当月最后一天日期</h1><p>var new_date = new Date(new_year,new_month,1); //取当年次月中的第一天<br>return (new Date(new_date.getTime()-1000<em>60</em>60*24)).getDate();//获取当月最后一天日期 </p>
<h1 id="为什么js里需要闭包"><a href="#为什么js里需要闭包" class="headerlink" title="为什么js里需要闭包"></a>为什么js里需要闭包</h1><ul>
<li>js也采用词法作用域是在函数定义时决定的，而不是函数调用时决定的。</li>
<li>C语言这种底层编程语言中，函数中的非静态变量是储存在CPU栈中的，当函数调用结束后堆栈中的空间也由编译器自动释放。</li>
<li>js闭包函数中的该函数被定义时所有外层的变量对象的引用被放在其上下文Scope属性作为一个作用域链包含，</li>
<li>所以定义了闭包的函数虽然销毁了，但是其变量对象依然被绑定在函数inner上，保留在内存中。不被GC</li>
</ul>
<h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP:"></a>TIP:</h2><ul>
<li>变量对象与活动对象的概念是ES3提出的老概念，从ES5开始就用词法环境和变量环境替代了</li>
<li>变量环境也是词法环境，它具备词法环境所有属性，一样有环境记录EnvironmentRecord（VO）与outer外部环境引入（作用域链）。</li>
<li>作用域链是处理标识符时进行变量查询的变量对象列表</li>
<li>在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值(变量提升)，var声明被设置为了undefined，函数被设置为了自身函数，而let  const被设置为未初始化（暂时性死区）</li>
<li>变量对象是与执行上下文相关的数据作用域</li>
<li>在函数上下文中，我们用活动对象来表示变量对象 对应于 词法记录</li>
</ul>
<h1 id="js解析引擎解析"><a href="#js解析引擎解析" class="headerlink" title="js解析引擎解析"></a>js解析引擎解析</h1><ul>
<li>js是脚本语言，浏览器解析js过程分为：语法检查阶段和运行阶段。</li>
<li>语法检查：<ul>
<li>字符流 - 记号流 - AST抽象语法树</li>
</ul>
</li>
<li>运行阶段：<ul>
<li>预解析： <ul>
<li>创建执行上下文 <ul>
<li>确定this</li>
<li>创建词法环境（存储函数声明与let const声明的变量）</li>
<li>创建变量环境 (存储var声明的变量)</li>
</ul>
</li>
<li>对VO/AO预赋值 （函数的形参 &gt; 函数声明 &gt; 变量声明）</li>
</ul>
</li>
<li>执行代码<ul>
<li>VO/AO重新赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="fetch跨域-cookie"><a href="#fetch跨域-cookie" class="headerlink" title="fetch跨域 cookie"></a>fetch跨域 cookie</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">              method: <span class="string">'GET'</span>,</span><br><span class="line">              headers: myHeaders,</span><br><span class="line">              credentials: <span class="string">"include"</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<p>在后台添加。允许浏览器<br><code>response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);</code><br><code>response.setHeader(‘Access-Control-Allow-Origin’, ‘http://localhost:8080’)//不能为*</code></p>
<h1 id="express-中间件"><a href="#express-中间件" class="headerlink" title="express 中间件"></a>express 中间件</h1><p>Express框架建立在node.js内置的http模块上。<br>Express框架的核心是对http模块的再包装。<br>Express框架等于在http模块之上，加了一个中间层。<br>应用层中间件、路由中间件、内置中间件、错误处理中间件和第三方中间件</p>
<h2 id="应用层中间件"><a href="#应用层中间件" class="headerlink" title="应用层中间件"></a>应用层中间件</h2><p>app.use（[path]，function）<br>path：是路由的url，默认参数‘/‘，意义是路由到这个路径时使用这个中间件<br>function：中间件函数<br>这个中间件函数可以理解为就是function(request,response,next)</p>
<h2 id="内置中间件express-static"><a href="#内置中间件express-static" class="headerlink" title="内置中间件express.static"></a>内置中间件express.static</h2><p>express.static(__dirname + ‘/public’) // express.static 是Express目前唯一内置的一个中间件。用来处理静态资源文件。</p>
<h2 id="路由中间件-express-Router"><a href="#路由中间件-express-Router" class="headerlink" title="路由中间件 express.Router();"></a>路由中间件 express.Router();</h2><h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><p>post请求，enctype属性一般设置为“application/x-www-form-urlencoded”，用于key1=val1&amp;key2=val2 的方式进行编码<br>如果设置成multipart/form-data，则多用于文件上传<br>如果设置成application/json,用于json序列化</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser=<span class="built_in">require</span>(<span class="string">"body-parser"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 解析以 application/json 和 application/x-www-form-urlencoded 提交的数据</span></span><br><span class="line"><span class="keyword">var</span> jsonParser = bodyParser.json();</span><br><span class="line"><span class="keyword">var</span> urlencodedParser = bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="动态路由-req-params"><a href="#动态路由-req-params" class="headerlink" title="动态路由 req.params"></a>动态路由 req.params</h3><h3 id="get传参-req-query-参数名"><a href="#get传参-req-query-参数名" class="headerlink" title="get传参 req.query.参数名"></a>get传参 req.query.参数名</h3><h2 id="cookie-parser"><a href="#cookie-parser" class="headerlink" title="cookie-parser"></a>cookie-parser</h2><p>const cookieParser=require(“cookie-parser”);</p>
<p>app.use(cookieParser());</p>
<p>res.cookie(“name”,’zhangsan’,{maxAge: 900000, httpOnly: true});<br>//res.cookie(名称,值,{配置信息})</p>
<h3 id="cookie加密-crypto"><a href="#cookie加密-crypto" class="headerlink" title="cookie加密 crypto"></a>cookie加密 crypto</h3><h2 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h2><h1 id="什么是事件委托吗？"><a href="#什么是事件委托吗？" class="headerlink" title="什么是事件委托吗？"></a>什么是事件委托吗？</h1><p>利用事件冒泡机制，给所有的li绑定点击事件，极为繁琐，这时候需要用到事件代理给ul绑定事件<br>element.addEventListener(event, function, useCapture)；<br>attachEvent()     //IE8及IE更早版本</p>
<ol>
<li>大量减少内存占用，减少事件注册。</li>
<li>新增元素实现动态绑定事件</li>
</ol>
<h2 id="2-对Promise了解吗？"><a href="#2-对Promise了解吗？" class="headerlink" title="2.对Promise了解吗？"></a>2.对Promise了解吗？</h2><p>promise构造函数是同步执行的，then方法是异步执行的，微任务</p>
<h2 id="3-window的onload事件和domcontentloaded谁先谁后？"><a href="#3-window的onload事件和domcontentloaded谁先谁后？" class="headerlink" title="3.window的onload事件和domcontentloaded谁先谁后？"></a>3.window的onload事件和domcontentloaded谁先谁后？</h2><ol>
<li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</li>
<li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</li>
</ol>
<h3 id="url展示的过程"><a href="#url展示的过程" class="headerlink" title="url展示的过程"></a>url展示的过程</h3><ul>
<li>DNS 解析 域名 -&gt; ip （DNS缓存 浏览器/操作系统/hosts文件 -》本地配置的首选DNS服务器 -》运营商的DNS代我们的浏览器发起迭代DNS解析请求 -》com IP -》test.com IP -&gt; <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> IP</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
<li>css是由单独的下载线程异步下载的 </li>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建） </li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）  </li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面</li>
</ul>
</li>
</ul>
<h1 id="vue的渲染过程"><a href="#vue的渲染过程" class="headerlink" title="vue的渲染过程"></a>vue的渲染过程</h1><p>把模板编译为render函数<br>实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom<br>对比虚拟dom，渲染到真实dom<br>组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3    </p>
<h1 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h1><p>（1）默认指向定义它时，所处上下文的对象的this指向。即ES6箭头函数里this的指向就是 <strong>上下文里对象this指向</strong>，偶尔没有上下文对象，this就指向window<br>（2）即使是call，apply，bind等方法也不能改变箭头函数this的指向</p>
<h1 id="for-in和-for-of"><a href="#for-in和-for-of" class="headerlink" title="for in和 for of"></a>for in和 for of</h1><p>for in会遍历数组所有的可枚举属性，包括原型。<br>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>
<p>for in来遍历对象的键名/索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">　　<span class="keyword">if</span>（myObject.hasOwnProperty(key))&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(key);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性</p>
<p>for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br></pre></td></tr></table></figure>

<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，<br>函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<h1 id="浏览器下事件循环-Event-Loop"><a href="#浏览器下事件循环-Event-Loop" class="headerlink" title="浏览器下事件循环(Event Loop)"></a>浏览器下事件循环(Event Loop)</h1><p>主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue （在执行微任务的时候，如果又有微任务进入队列，则在此次循环中执行）</li>
<li>更新 render （视图更新）</li>
<li>主线程重复执行上述步骤<br>上述为一轮事件循环</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/browser-deom1-excute-animate.gif" alt=""></p>
<h1 id="Http请求中的keep-alive"><a href="#Http请求中的keep-alive" class="headerlink" title="Http请求中的keep-alive"></a>Http请求中的keep-alive</h1><p>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。</p>
<h1 id="1-从输入URL到页面加载发生了什么？url展示"><a href="#1-从输入URL到页面加载发生了什么？url展示" class="headerlink" title="1. 从输入URL到页面加载发生了什么？url展示"></a>1. 从输入URL到页面加载发生了什么？url展示</h1><p>1、浏览器的地址栏输入URL并按下回车。<br>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。<br>3、DNS解析URL对应的IP。<br>4、根据IP建立TCP连接（三次握手）。<br>5、HTTP发起请求。<br>6、服务器处理请求，浏览器接收HTTP响应。<br>7、渲染页面，构建DOM树。<br>8、关闭TCP连接（四次挥手）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/22/167d5e19c54ae53e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h1 id="2-缓存相关的知识吧？"><a href="#2-缓存相关的知识吧？" class="headerlink" title="2. 缓存相关的知识吧？"></a>2. 缓存相关的知识吧？</h1><p>浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存（协商缓存）。<br>两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。</p>
<p>强制缓存判断HTTP首部字段：cache-control，Expires。</p>
<p>Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。</p>
<p>cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。</p>
<p>协商缓存通过HTTP的last-modified，Etag字段进行判断。</p>
<p>last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。</p>
<p>如果需要浏览器强缓存，我们可以这样设置：<br>res.setHeader(‘Cache-Control’, ‘public, max-age=xxx’);<br>复制代码如果需要协商缓存，则可以这样设置：<br>res.setHeader(‘Cache-Control’, ‘public, max-age=0’);<br>res.setHeader(‘Last-Modified’, xxx);<br>res.setHeader(‘ETag’, xxx);</p>
<h1 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手 四次挥手"></a>TCP 三次握手 四次挥手</h1><p><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li>1xx: 接受，继续处理</li>
<li><strong>200: 成功，并返回数据</strong></li>
<li>201: 已创建</li>
<li>202: 已接受</li>
<li>203: 成为，但未授权</li>
<li><strong>204: 成功，无内容</strong></li>
<li>205: 成功，重置内容</li>
<li>206: 成功，部分内容</li>
<li>301: 永久移动，重定向</li>
<li>302: 临时移动，可使用原有URI</li>
<li><strong>304: 资源未修改，可使用缓存</strong></li>
<li><strong>305: 需代理访问</strong></li>
<li>400: 请求语法错误</li>
<li>401: 要求身份认证</li>
<li><strong>403: 拒绝请求</strong></li>
<li><strong>404: 资源不存在</strong></li>
<li><strong>500: 服务器错误</strong><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h3></li>
</ul>
<ol>
<li>GET把参数包含在URL中，而POST将数据放在BODY中。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。</li>
<li>GET 会被历史保存记录，POST中的参数不会被保留</li>
<li>GET只能进行url编码，POST支持更多编码类型（请求头中的Content-Type属性表示编码方式）</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET能被缓存，而POST不能</li>
<li>GET是幂等(请求次数与资源无关)的。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。<br>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li>
</ol>
<ul>
<li>get: <ul>
<li>缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，</li>
<li>发送一个TCP请求 </li>
<li>幂等</li>
</ul>
</li>
<li>post: 安全、大数据、更多编码类型 发送两个TCP请求 </li>
<li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</li>
</ul>
<h1 id="X时Y分时的两针位置"><a href="#X时Y分时的两针位置" class="headerlink" title="X时Y分时的两针位置"></a>X时Y分时的两针位置</h1><p>θ=|6Y-(30X+0.5Y)|=|5.5Y-30X|,单位是度（°）；</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">    left = arr.slice(<span class="number">0</span>,index); <span class="comment">//得到下标从0~index-1的数组</span></span><br><span class="line">    right = arr.slice(index);  <span class="comment">//得到下标从index开始到末尾的数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left) , mergeSort(right));  里面采用递归</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left , right</span>) </span>&#123;   <span class="comment">//该函数与快排类似，但是仔细发现，每次left或者right都是要shift掉第一个元素，表示left或者right是会变化的，最后arr.concat，因为不知道left或者right其中一个哪个剩下元素，所以要将剩下的元素给加上</span></span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span>(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      arr.push(left.shift());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.concat(left , right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="js的bind、apply、call有什么区别"><a href="#js的bind、apply、call有什么区别" class="headerlink" title="js的bind、apply、call有什么区别"></a>js的bind、apply、call有什么区别</h1><ul>
<li>fn.call(obj,…args)转换成obj.fn(…args)</li>
<li>fn.call(obj,args) 转换成obj.fn(args)</li>
<li>return function F(){ return new fn() 或者return fn.apply(obj,args.concat(…arguments))}<a id="more"></a>
<h1 id="js的继承"><a href="#js的继承" class="headerlink" title="js的继承"></a>js的继承</h1></li>
<li>借用构造函数</li>
<li>原型链式继承</li>
<li>组合继承</li>
<li>组合寄生式继承</li>
</ul>
<h1 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h1><p>一，var定义的变量，作用域是整个封闭函数，是全域的；let定义的变量，作用域是在块级或者字块中；<br>二，变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。<br>      而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）；<br>三，只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；<br>四，let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）。<br>const用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是const声明的常量不可改变，声明时必须初始化（赋值）</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>没有this，arguments，没有prototype</p>
<h1 id="promise的then的第二个参数和catch的区别"><a href="#promise的then的第二个参数和catch的区别" class="headerlink" title="promise的then的第二个参数和catch的区别"></a>promise的then的第二个参数和catch的区别</h1><p>catch = then(null,rejected)</p>
<h1 id="手写一个promise怎么写"><a href="#手写一个promise怎么写" class="headerlink" title="手写一个promise怎么写"></a>手写一个promise怎么写</h1><p>value:null<br>成功stack：[]<br>失败stack：[]<br>this.then()=&gt;{两个栈push}<br>function resolve(value) =&gt; {成功栈遍历回调}<br>function reject(value) =&gt; {失败栈遍历回调}<br>fn(resovle,reject)</p>
<h1 id="Promise-all应用场景"><a href="#Promise-all应用场景" class="headerlink" title="Promise.all应用场景"></a>Promise.all应用场景</h1><p>返回new Promise(){}<br>遍历传入的Promise数组<br>Promise.resolve(promises[i])<br>.then(function(value) {<br>        countNum++;<br>        resolvedvalue[i] = value;<br>        if (countNum === promiseNum) {<br>          return resolve(resolvedvalue)<br>        }<br>      }, function(reason) {<br>        return reject(reason)<br>      })</p>
<h1 id="Promise-race应用场景"><a href="#Promise-race应用场景" class="headerlink" title="Promise.race应用场景"></a>Promise.race应用场景</h1><p>指定时间内没有获得结果，就将Promise的状态变为reject<br>Promise.race([<br>  fetch(‘/resource-that-may-take-a-while’),<br>  new Promise(function (resolve, reject) {<br>    setTimeout(() =&gt; reject(new Error(‘request timeout’)), 5000)<br>  })<br>]);</p>
<h1 id="promise和async-await的区别"><a href="#promise和async-await的区别" class="headerlink" title="promise和async/await的区别"></a>promise和async/await的区别</h1><p>async/await 在generater函数的基础上实现的状态机异步调用，执行到await的函数的时候暂时让出线程至函数调用完成</p>
<ul>
<li>把*换成了async，把yield换成了await</li>
<li>一个函数如果加上 async ，那么该函数就会返回一个 Promise<ul>
<li>async 就是将函数返回值使用 Promise.resolve()包裹</li>
</ul>
</li>
<li>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</li>
<li>没有依赖性的话，完全可以使用 Promise.all 的方式</li>
</ul>
<h1 id="状态码304"><a href="#状态码304" class="headerlink" title="状态码304"></a>状态码304</h1>]]></content>
  </entry>
  <entry>
    <title>Vue题目</title>
    <url>/2020/02/23/interview/vue/</url>
    <content><![CDATA[<h2 id="写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2><ul>
<li>考虑到DOM节点更改的性能问题，Vue使用vnode做虚拟dom节点进行更新</li>
<li>组件的更新，是通过每一个vue实例的watcher派发更新的，每一步更新都是更新一个vue实例对应的dom。因为update事件被推送到任务队列时，是按watcher的id从小到大进行排序，所以会先更新用户watcher，再更新父watcher，再更新子watcher</li>
<li>响应式数据的变化触发渲染watcher的updateComponment方法，执行vm._patch(vm._render,false)过程</li>
</ul>
<ol>
<li>_render() 生成当前vm实例 新的vnode</li>
<li>_update() 执行 patch方法，由于此时存在旧vnode，如果新旧vnode不同（key tag），会调用 patchVnode，如果是不同的vnode，createELm 创建新的dom，并删去旧的dom</li>
<li>patchVnode 主要是进行更新dom操作 <ul>
<li>新旧节点的孩子节点存在 且不同，调用diff算法</li>
<li>比较 新旧节点的文本，进行更新</li>
</ul>
</li>
<li>diff算法<a id="more"></a>
参考： <a href="https://segmentfault.com/a/1190000008782928" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008782928</a></li>
</ol>
<p>在diff算法中vue只对同级的vnode节点进行比较，oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。<br>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找newStartVnode.key匹配的节点(没有设置key的话需要执行findIdxInOld方法去比较newStartVnode和所有的oldCh），所以为节点设置key可以更高效的利用dom。</p>
<p>对于带状态的组件渲染，唯一的key值在每次渲染列表时都会完全替换所有组件，使其拥有正确状态（而不是就地更新）。</p>
<h1 id="Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n"><a href="#Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n" class="headerlink" title="Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?"></a>Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?</h1><ul>
<li>Vue的diff是同层级比较;</li>
<li>对于同一层级的一组子节点，通过分配唯一唯一id进行区分（key值）</li>
</ul>
<h1 id="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"><a href="#vuex中为什么把把异步操作封装在action，把同步操作放在mutations？" class="headerlink" title="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"></a>vuex中为什么把把异步操作封装在action，把同步操作放在mutations？</h1><p><a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="noopener">参考</a><br>尤雨溪：为了能用 devtools 追踪状态变化<br>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p>
<h1 id="双向绑定和-vuex-是否冲突？"><a href="#双向绑定和-vuex-是否冲突？" class="headerlink" title="双向绑定和 vuex 是否冲突？"></a>双向绑定和 vuex 是否冲突？</h1><p>在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案： 1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值 2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"message"</span>&gt; </span><br><span class="line">computed: &#123; </span><br><span class="line">    message: &#123; </span><br><span class="line">        <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message &#125;, <span class="keyword">set</span> (value) &#123; <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex的设计思想？"><a href="#Vuex的设计思想？" class="headerlink" title="Vuex的设计思想？"></a>Vuex的设计思想？</h1><p><img src="https://pic1.zhimg.com/80/v2-1b21813cd1d621658fe7402f0af4b104_hd.jpg" alt="vuex"><br>全局的 Store，包含着应用中的状态 State,这个 State 是单一的,子组件能通过 this.$store 访问到 state 。<br>Vuex 让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。</p>
<h2 id="Vuex初始化"><a href="#Vuex初始化" class="headerlink" title="Vuex初始化"></a>Vuex初始化</h2><p>state 的是按模块划分的，按模块的嵌套形成一颗状态树。注册对子module迭代执行初始化流程（path上附加上父路径）。<br>而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。</p>
<h2 id="mutations-只能执行同步操作"><a href="#mutations-只能执行同步操作" class="headerlink" title="mutations 只能执行同步操作"></a>mutations 只能执行同步操作</h2><p>store.commit(‘moduleA/incrementAge’)</p>
<ol>
<li>执行 store 的 commit函数</li>
<li>通过传入的 key值 来获得对应的用户自定义的mutaitons方法 <code>store._mutaitons[key]</code></li>
<li>在 store._withCommit 方法中 执行 mutations方法，为了保证对state的直接操作不会触发警告</li>
</ol>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commit (type, payload, options) &#123;</span><br><span class="line">  <span class="comment">// check object-style commit</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = type</span><br><span class="line">    type = type.type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      handler(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!options || !options.silent) &#123;</span><br><span class="line">    <span class="keyword">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="keyword">this</span>.state))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> subscribe 订阅（注册监听）store 的 mutation，调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听</p>
<h2 id="actions-可以异步操作"><a href="#actions-可以异步操作" class="headerlink" title="actions 可以异步操作"></a>actions 可以异步操作</h2><ol>
<li>dispatch根据传入的 key 值 获得 用户自定义的 actions</li>
<li>执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">      ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">      : entry[<span class="number">0</span>](payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="keyword">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2></li>
<li>this.$store.getters.xxxgetters访问回调函数，</li>
<li>getter执行结果绑定到this.$store上。<ul>
<li>resetStoreVM 函数重置一个<strong>私有的 _vm 对象</strong>，保留<strong>state树</strong>，以及用<strong>计算属性的方式</strong>存储了 store 的 getters<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; store._vm[key]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>将数组转换成{key, val: key}的对象，将对象转换成{ key, val: obj[key] }的对象返回结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapState</span> (<span class="params">states</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">        ? val.call(<span class="keyword">this</span>, <span class="keyword">this</span>.$store.state, <span class="keyword">this</span>.$store.getters)</span><br><span class="line">        : <span class="keyword">this</span>.$store.state[val]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</h1><p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
<ul>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；(尤雨溪：defineProperty可以检测数组下标，但是收益与性能不成正比)</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
</ul>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>ViewModel 通过双向数据绑定把 View 层和 Model层连接了起来，而View和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题</p>
<h1 id="Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？"><a href="#Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？" class="headerlink" title="Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？"></a>Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？</h1><p>双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view</p>
<p>vue.js 采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>要实现mvvm的双向绑定，就必须要实现以下几点： </p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 </li>
<li>实现一个指令解析器Compile(render+patch)，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br><img src="https://raw.githubusercontent.com/DMQ/mvvm/master/img/2.png" alt="MVVM"></li>
</ol>
<p>利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p>
<p>监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法</p>
<p>订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作</p>
<p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: </p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己 </li>
<li>自身必须有一个update()方法 </li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li>
</ol>
<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcher实例就能收到更新通知。</p>
<p>Component类中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>._ob = observe(options.data)</span><br></pre></td></tr></table></figure>
<h2 id="model-gt-view"><a href="#model-gt-view" class="headerlink" title="model -&gt; view"></a>model -&gt; view</h2><p>数据驱动视图<br>在 vue 2.x 中 通过 </p>
<ul>
<li><p>observe添加数据响应</p>
<ul>
<li>给数据添加一个Observer对象实例附加在obj.<strong>ob</strong>上</li>
<li>defineProperty 实现的数据劫持</li>
<li>闭包形式给数据添加Dep实例</li>
</ul>
</li>
<li><p><strong>getter 收集依赖</strong></p>
<ul>
<li><strong>const dep = new Dep() // 实例化一个Dep实例</strong></li>
<li><strong>在get函数中通过dep.depend做依赖收集</strong></li>
</ul>
</li>
<li><p>什么时候触发getter收集依赖？</p>
<ul>
<li>实例化一个渲染watcher=&gt; watcher的构造函数=&gt;this.get()，<ul>
<li>get函数把Dep.target赋值为当前渲染watcher并压栈（为了恢复)</li>
</ul>
</li>
<li>vm._render()生成渲染VNode,并且在这个过程对vm上的数据访问触发getter</li>
<li>(在此期间执行Dep.target.addDep(this)方法，将watcher订阅到这个数据持有的dep的subs中，为后续数据变化时通知到哪些subs做准备)</li>
<li>每次数据变化都会vm._render()方法会再次执行，并再次触发数据</li>
</ul>
</li>
<li><p><strong>setter 调用更新回调</strong></p>
<ul>
<li><strong>childOb = !shallow &amp;&amp; observe(newVal) // 如果shallow为false的情况，会对新设置的值变成一个响应式对象</strong></li>
<li><strong>dep.notify() // 通知所有订阅者</strong></li>
</ul>
</li>
<li><p>派发过程：当我们组件中对响应的数据做了修改，就会触发setter的逻辑，最后调用dep.notify()方法，遍历依赖收集中建立的subs，也就是Watcher的实例数组【subs数组在依赖收集getter中被添加，期间通过一些逻辑处理判断保证同一数据不会被添加多次】，然后调用每一个watcher的update方法。</p>
</li>
<li><p>update函数中有个 <strong>queueWatcher(this)</strong> 方法引入了队列的概念，是vue在做派发更新时优化的一个点，它并不会每次数据改变都会触发watcher回调，而是把这些watcher先添加到一个队列中，然后在nextTick后执行watcher的run函数</p>
</li>
</ul>
<p>队列排序保证：</p>
<ul>
<li>组件的更新由父到子。父组件创建早于子组件，watcher的创建也是</li>
<li>用户自定义watcher要早于渲染watcher执行，因为用户自定义watcher是在渲染watcher前创建的</li>
<li>如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过，所以父组件的watcher应该先执行。</li>
</ul>
<p>队列遍历：排序完成后，对队列进行遍历，拿到对应的watcher,执行watcher.run()。 </p>
<ol>
<li>通过this.get()得到它当前的值,判断新旧值不同执行watcher回调</li>
<li>渲染watcher而言，在执行this.get()方法求值的时候，会执行getter方法，重新patch</li>
</ol>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul>
<li>Dep.target 全局唯一Watcher</li>
<li>this.deps = []; this.depIds = new Set()</li>
<li>this.newDeps = [];this.newDepIds = new Set()    </li>
</ul>
<h2 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h2><p><img src="https://i.loli.net/2019/07/15/5d2c20df68a3346321.jpg" alt="数据绑定"></p>
<h2 id="view-gt-model"><a href="#view-gt-model" class="headerlink" title="view -&gt; model"></a>view -&gt; model</h2><p>通过 v-model 的方式,如果一个组件有多个 v-model ，你要自己写 v-on 和 data 的修改。</p>
<p>编译时：<br>v-model的相关信息保存在AST树的atrrsList数组和指令directive属性上，生成render函数时，这些属性上的信息通过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addProp(el, <span class="string">'value'</span>, <span class="string">`(<span class="subst">$&#123;value&#125;</span>)`</span>)</span><br><span class="line">addHandler(el, event, code, <span class="literal">null</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>方法添加到render的data中，v-model生成的代码作为语法糖，即通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，</p>
<figure class="highlight plain"><figcaption><span>v-model</span></figcaption><table><tr><td class="code"><pre><span class="line">&#x3D;&gt;</span><br><span class="line">&#96;&#96;&#96;&lt;input v-bind:value&#x3D;&quot;message&quot; @input&#x3D;&quot;message&#x3D;$event.target.value&quot;&gt;&#96;&#96;&#96; v-model 的实现，子组件的 value prop 以及派发的 input 事件名是可配的</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">model:&#123;</span><br><span class="line">    prop:&#39;msg&#39;,</span><br><span class="line">    event:&#39;change&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v-model-表单vs组件"><a href="#v-model-表单vs组件" class="headerlink" title="v-model 表单vs组件"></a>v-model 表单vs组件</h2><table>
<thead>
<tr>
<th></th>
<th>表单</th>
<th>组件</th>
</tr>
</thead>
<tbody><tr>
<td>编译prase阶段的AST树</td>
<td>生成directives属性</td>
<td>生成 model属性</td>
</tr>
<tr>
<td>编译codegen阶段的data</td>
<td>props和event</td>
<td>model = {callback: “function ($$v) {message=$$v}”, expression: “message”, value: “(message)”}</td>
</tr>
<tr>
<td>运行阶段</td>
<td>updateDOMListeners-&gt; addEventListener</td>
<td>initEvent -&gt; 将回调函数挂载在vm实例上，并配合$emit实现</td>
</tr>
</tbody></table>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>vdom 的真正意义是为了实现跨平台，服务端渲染，以及提供一个性能还算不错 Dom 更新策略。</p>
<h1 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop？"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop？" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop？"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop？</h1><p>原因很简单，一个父组件下不只有你一个子组件。 同样，使用这份 prop 数据的也不只有你一个子组件。 如果每个子组件都能修改 prop 的话，将会导致修改数据的源头不止一处。</p>
<p>所以我们需要将修改数据的源头统一为父组件，子组件像要改 prop 只能委托父组件帮它。从而保证数据修改源唯一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initProps()&#123;……</span><br><span class="line">defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果不是root根组件，并且不是更新子组件，那么说明更新的是props</span></span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(……）</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;……&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期顺序？"><a href="#生命周期顺序？" class="headerlink" title="生命周期顺序？"></a>生命周期顺序？</h1><p>加载渲染过程</p>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p>子组件全局状态更新过程</p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p>销毁过程</p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h2 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h2><p>创建-挂载-更新-销毁</p>
<ul>
<li>beforeCreate前，也就是new Vue的时候会初始化事件和生命周期；</li>
<li>beforeCreate和created之间会挂载Data，绑定事件；接下来会根据el挂载页面元素，如果没有设置el则生命周期结束，直到手动挂载；el挂载结束后，根据templete/outerHTML(el)渲染页面；</li>
<li>在beforeMount前虚拟DOM已经创建完成；</li>
<li>之后在mounted前，将vm.$el替换掉页面元素el;mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）；</li>
<li>之后发生数据变化时触发beforeUpdate和updated进行一些操作；</li>
<li>最后主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等；</li>
<li>destroyed时仅存在Dom节点，其他所有东西已自动销毁。</li>
</ul>
<h1 id="Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？"><a href="#Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？" class="headerlink" title="Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？"></a>Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？</h1><p>router-link 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 a 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p>
<p>&lt;router-link&gt; 比起写死的&lt;a href=”…” &gt; 会好一些，理由如下：</p>
<p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。<br>在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。<br>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写 (基路径) 了。</p>
<h1 id="v-for有必要添加事件代理吗？"><a href="#v-for有必要添加事件代理吗？" class="headerlink" title="v-for有必要添加事件代理吗？"></a>v-for有必要添加事件代理吗？</h1><p>没必要  </p>
<p>首先我们需要知道事件代理主要有什么作用？    </p>
<ul>
<li><p>事件代理能够避免我们逐个的去给元素新增和删除事件</p>
</li>
<li><p>事件代理比每一个元素都绑定一个事件性能要更好<br>从vue的角度上来看上面两点   </p>
</li>
<li><p>在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了</p>
</li>
<li><p>在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理</p>
</li>
</ul>
<h1 id="vue首屏白屏？"><a href="#vue首屏白屏？" class="headerlink" title="vue首屏白屏？"></a>vue首屏白屏？</h1><p>首页白屏的原因： 单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏</p>
<p>解决办法：</p>
<ul>
<li>优化 webpack 减少模块打包体积，code-split 按需加载</li>
<li>服务端渲染，在服务端事先拼装好首页所需的 html</li>
<li>首页加骨架屏</li>
<li>使用CDN减小代码体积加快请求速度</li>
<li>vue-router 路由懒加载</li>
<li>nginx楷gzip压缩</li>
</ul>
<h1 id="vue-是如何对数组方法进行变异的？"><a href="#vue-是如何对数组方法进行变异的？" class="headerlink" title="vue 是如何对数组方法进行变异的？"></a>vue 是如何对数组方法进行变异的？</h1><p>重写了数组中的那些方法，首先获取到这个数组的<strong>ob</strong>,也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化，然后手动调用notify，通知渲染watcher，执行update</p>
<p>Vue中默认的做法就是在数组实例与它的原型之间，插入了一个新的原型对象，这个原型方法实现了这些变异方法，也就拦截了真正数组原型上的方法（因为原型链的机制，找到了就不会继续往上找了）。 变异方法中增加了自定义逻辑，也调用了真正数组原型上的方法，即实现了目的，也不会对正常使用造成影响。</p>
<h1 id="观察者模式和发布-订阅模式有什么区别？"><a href="#观察者模式和发布-订阅模式有什么区别？" class="headerlink" title="观察者模式和发布-订阅模式有什么区别？"></a>观察者模式和发布-订阅模式有什么区别？</h1><p>观察者模式没中间商赚差价<br>发布订阅模式 有中间商赚差价</p>
<h1 id="github上的问题"><a href="#github上的问题" class="headerlink" title="github上的问题"></a>github上的问题</h1><h2 id="vue组件之间的通信都有哪些？"><a href="#vue组件之间的通信都有哪些？" class="headerlink" title="vue组件之间的通信都有哪些？"></a>vue组件之间的通信都有哪些？</h2><p>父子Coms: </p>
<ul>
<li>props</li>
<li>$emit/$on</li>
<li>( $parents/$children ) / $refs</li>
</ul>
<p>兄弟Coms:</p>
<ul>
<li>Vuex</li>
<li>Bus</li>
</ul>
<p>跨级Coms: </p>
<ul>
<li>( provide/inject )</li>
<li>( $attrs/$listeners )</li>
</ul>
<h1 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h1><p>1、Vue 是怎么知道数据改变？</p>
<ul>
<li>Object.defineProperty对get和set进行拦截</li>
</ul>
<p>2、Vue 在数据改变时，怎么知道通知哪些视图更新？</p>
<ul>
<li>data 中每个声明的属性<strong>ob</strong>，都会有一个Dep实例 专属的依赖收集器 subs</li>
<li>当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中</li>
<li>ObjectdefineProperty - get 依赖收集 dep.depned</li>
</ul>
<p>3、Vue 在数据改变时，视图怎么知道什么时候更新？</p>
<ul>
<li>Object.defineProperty - set</li>
<li>name 会遍历自己的 依赖收集器 subs，逐个通知 watcher</li>
<li>watcher render-&gt;patch 完成更新</li>
</ul>
<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"a"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testb</span> <span class="attr">:child-name</span>=<span class="string">"parentName"</span> &gt;</span><span class="tag">&lt;/<span class="name">testb</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、父组件 怎么传值给 子组件的 props?</p>
<ul>
<li>父组件的模板 会被解析成一个 模板渲染函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  <span class="comment">// 绑定大括号内代码的 变量访问作用域</span></span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">staticClass</span>:<span class="string">"a"</span>&#125;,[</span><br><span class="line">            _c(<span class="string">'testb'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"child-name"</span>:parentName&#125;&#125;)</span><br><span class="line">        ],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>模板函数会被执行，执行时会绑定 父组件为作用域</li>
<li>所以渲染函数内部所有的变量，都会从父组件对象 上去获取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">attrs</span>: &#123; child-name: parentVm.parentName &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件保存 props</li>
<li>props 会被 保存到 实例的_props 中，并且 会逐一复制到 实例上，并且每一个属性会被设置为响应式的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VueComponent&#123;</span><br><span class="line">  childName:&quot;aaa&quot;,</span><br><span class="line">  _props:&#123;</span><br><span class="line">    childName:&quot;aaa&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2、子组件如何读取props?</li>
<li>复制的时候，会对每个属性，同时设置 get 和 set 函数，进行 访问转接 和 赋值转接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._props[key]&#125;,    </span><br><span class="line"><span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>._props[key] = val&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问 props 其中一个值 vm.childName，其实访问的是 vm._props.childName</li>
<li>赋值 vm.childName= 5 ，其实是赋值 vm._props.childName= 5</li>
</ul>
<p>因此不会影响到父组件data</p>
<p>3、父组件 data 更新，子组件的props 如何更新</p>
<ul>
<li><p>parentName 会收集 父组件的 watcher</p>
</li>
<li><p>render函数中 _c(‘testb’,{attrs:{“child-name”:parentName}被收集依赖</p>
</li>
<li><p>渲染函数执行，开启新一轮的 props 赋值操作</p>
<p>基础类型的props不影响父组件 data，对象类型的props影响</p>
<h1 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h1><p>1、computed 也是响应式的？</p>
</li>
<li><p>给 computed 设置的 get 和 set 函数，会跟 Object.defineProperty 关联</p>
</li>
<li><p>读取computed 时，会执行你设置的 get 函数，还有一层缓存的操作</p>
</li>
</ul>
<p>2、computed 如何控制缓存？</p>
<ul>
<li>【脏数据标志位 dirty】，computed 通过 watcher.dirty 控制是否读取缓存</li>
<li>当 dirty 为 true 时，读取 computed 会重新计算<ul>
<li>computed 新建自己的watcher时，会设置 watcher.dirty = true</li>
<li>依赖的数据变化了，通知 computed 时，会设置 watcher.dirty = true</li>
</ul>
</li>
<li>当 dirty 为 false 时，读取 computed 会使用缓存<ul>
<li>computed 计算完成之后，会设置 watcher.dirty = false</li>
</ul>
</li>
</ul>
<p>3、依赖的 data 改变了，computed 如何更新？<br>computed 会让 【data依赖】 收集到 【依赖computed的watcher】，从而 data 变化时，会同时通知 computed 和 依赖computed的地方</p>
<ul>
<li>页面A 引用了 computed B，computed B 依赖了 data C</li>
<li>data C 开始变化后<ol>
<li>只会重置computed B的 脏数据标志位 dirty =true，不会计算值</li>
<li>通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算<br><img src="https://segmentfault.com/img/remote/1460000019605781?w=563&h=177" alt=""></li>
</ol>
</li>
</ul>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>1、 methods 怎么使用实例访问？</p>
<ul>
<li>遍历 methods 这个对象，然后逐个复制到 实例上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span>(<span class="params">vm, methods</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">        vm[key] = </span><br><span class="line">            methods[key] == <span class="literal">null</span> ? </span><br><span class="line">            noop : </span><br><span class="line">            bind(methods[key], vm);<span class="comment">// 使用bind固定作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"data"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;name:"matt"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、v-model 怎么给表单绑定数据？</p>
<ul>
<li>v-model 绑定的数据赋值给表单元素的 value 属性</li>
<li>value 是 v-model 解析成的原生属性，保存在属于该节点 input 的 domProps 对象存储器中</li>
<li>绑定值：创建dom input 之后-&gt;  遍历该 input 的 domProps ，逐个添加给 dom input -&gt; 插入dom input<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,[</span><br><span class="line">            _c(<span class="string">'input'</span>,</span><br><span class="line">                domProps:&#123;<span class="string">"value"</span>:name&#125; <span class="comment">// name重vm.name获取</span></span><br><span class="line">            )</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>2、v-model 绑定什么事件？</p>
<ul>
<li>change:select，checkbox，radio</li>
<li>input:默认  text、number 等 input 元素和 textarea</li>
</ul>
<p>3、v-model 怎么绑定事件？</p>
<ul>
<li>解析不同表单元素，配置相应的事件名和事件回调，在插入dom之前，addEventListener 绑定上事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, [</span><br><span class="line">        _c(<span class="string">'input'</span>, &#123;        </span><br><span class="line">            on: &#123;             <span class="comment">// 用于addEventListener</span></span><br><span class="line">              <span class="string">"input"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">                  name = $event.target.value</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> vnode.data.on) &#123;</span><br><span class="line">        vnode.elm.addEventListener(event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.addEventListener(<span class="string">"input"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;    </span><br><span class="line">    name = $event.target.value </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、v-model 如何进行双向更新？</p>
<ul>
<li>外部变化，触发事件回调，event.target.value 赋值给model绑定的数据；</li>
<li>内部变化<ul>
<li>v-model 绑定了 name ，name 会收集到 本组件的 watcher</li>
<li>内部修改 name 变化，通知收集器内的 watcher 更新 render-&gt; patch</li>
<li>render内name更新 渲染成新的DOM</li>
</ul>
</li>
</ul>
<h1 id="代理Data"><a href="#代理Data" class="headerlink" title="代理Data"></a>代理Data</h1><ul>
<li>proxy(vm,”_data”,key)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">"name"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>]&#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>] = val;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
好处：</li>
<li>直接通过 vm 访问到data中的name</li>
<li>相比于将data中数据拷贝赋值到vm上，代理的形式减少了数据维护（method是直接赋值的）</li>
<li>不影响依赖更新和收集</li>
</ul>
<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>1、监听的数据改变的时，watch 如何工作？</p>
<ul>
<li>watch 在一开始初始化的时读取监听数值的数据，数据添加到watch的watcher上，</li>
<li>watch设置handler会放在watch的更新函数中 更新时被调用</li>
</ul>
<p>2、设置 immediate 时，watch 如何工作？</p>
<ul>
<li>初始化 watch 时，在读取了 监听的数据的值 之后，便立即调用一遍你设置的监听回调</li>
</ul>
<p>3、设置了 deep 时，watch 如何工作？<br>深度监听对象内部变化</p>
<ul>
<li>(没有设置deep)因为读取了监听的 data 的属性，watch 的 watcher 被收集在 这个属性的 收集器中</li>
<li>(设置了deep)在读取 data 属性的时候，会递归遍历这个值，把内部所有属性逐个读取一遍，于是 属性和 它的对象值内每一个属性 都会收集到 watch 的 watcher</li>
</ul>
<h1 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h1><p>1、Vue.component 注册的 【全局组件】<br>2、Vue.filter 注册的 【全局过滤器】<br>3、Vue.directive 注册的 【全局指令】<br>4、Vue.mixin 注册的 【全局mixin】   </p>
<p>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并起来</p>
<h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>A. 组件选项<br>B. 组件mixin<br>C. 全局mixin<br>权重：选项 &gt; 组件 &gt; 全局  </p>
<p>1、什么时候合并？<br>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并。</p>
<p>2、怎么合并？</p>
<ul>
<li><p>合并成一个函数 (data，provide)：</p>
<ul>
<li>函数合并成一个函数时，选项 &gt; 组件 &gt; 全局  </li>
<li>data中数据重复的，优先级： 选项 &gt; 组件 &gt; 全局  </li>
</ul>
</li>
<li><p>数组叠加（生命周期函数，watch）：</p>
<ul>
<li>权重越大的越放后面，合并数组</li>
<li>执行时 生命周期，权重小的 先执行<br>[<br>全局 mixin - created/watch，<br>组件 mixin - created/watch，<br>组件 options - created/watch<br>]</li>
</ul>
</li>
<li><p>原型叠加（components，filters，directives）</p>
<ul>
<li>权重小的 被放到 权重大 的 的原型上</li>
<li>这样权重大的，访问快些，因为作用域链短了<ul>
<li>A: 组件选项的component</li>
<li>B: 组件mixin的component</li>
<li>C: 全局mixin的component</li>
</ul>
</li>
<li><code>A.__proto__ = B</code> 和<code>B.__proto__ = C</code>  </li>
</ul>
</li>
<li><p>覆盖叠加(props，methods，computed，inject)</p>
<ul>
<li>两个对象合并，如果有重复key，权重大的覆盖权重小的<ul>
<li>组件的 props 会替换 mixin 的props</li>
<li>组件的 methods 会替换 mixin 的methods</li>
<li>组件的 computed 会替换 mixin 的computed</li>
</ul>
</li>
</ul>
</li>
<li><p>直接替换（el，template，propData）</p>
</li>
</ul>
<h1 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;插入slot中:&#123;&#123;name&#125;&#125;&lt;<span class="regexp">/test&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">data()&#123;<span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">"matt"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test 组件</span></span><br><span class="line">&lt;main&gt;</span><br><span class="line">  我在子组件里</span><br><span class="line">  &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/m</span>ain&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，把 插槽当做 test 的子元素处理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span>,        </span><br><span class="line">        children: [<span class="string">'插入slot 中'</span>] <span class="comment">//插槽节点</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [<span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>)]<span class="comment">// slot 第一步解析得到的插槽节点拿到，然后返回</span></span><br><span class="line">    <span class="comment">// children: ['我在子组件里面','插入slot 中']</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、插槽内容怎么解析?插槽如何插子页面?</p>
<ul>
<li>父组件解析<ul>
<li>子组件的插槽解析成<strong>最终节点</strong></li>
<li>保存在子组件占位符节点children中</li>
</ul>
</li>
<li>子组件占位符节点的children转移给子组件选项_renderChildren上</li>
<li>子组件选项 _renderChildren转移给子组件实例$ slot上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件$slot上获取对应的插槽节点并返回，替换占位符   </li>
</ul>
</li>
</ul>
<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><ul>
<li>父组件解析<ul>
<li>子组件的插槽，包装成<strong>函数</strong></li>
<li>保存在子组件占位符节点scopedSlots中</li>
</ul>
</li>
<li>子组件占位符节点的scopedSlots转移给子组件实例上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件scopedSlots上获取对应的插槽函数并执行返回节点，替换占位符   </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;</span><br><span class="line">    &lt;template slot-scope=<span class="string">"slotProps"</span>&gt;插入插槽中&#123;&#123;slotProps&#125;&#125;&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>test&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件test 组件</span></span><br><span class="line"><span class="regexp">&lt;main&gt;</span></span><br><span class="line"><span class="regexp">  我在子组件里</span></span><br><span class="line"><span class="regexp">  &lt;slot :child="child"&gt;&lt;/</span>slot&gt;</span><br><span class="line">&lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件data</span></span><br><span class="line"><span class="regexp">data()&#123;</span></span><br><span class="line"><span class="regexp">  return &#123;child:11&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，<strong>把 插槽包装成一个函数，保存给节点</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span></span><br><span class="line">        scopeSlots:&#123;            </span><br><span class="line">            <span class="keyword">default</span>：<span class="function"><span class="keyword">function</span>(<span class="params">slotProps</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'插入slot 中'</span> + slotProps]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>,&#123;<span class="attr">child</span>:<span class="number">11</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>_t 内部执行:1. 传入的名字（’default’），拿到第一步解析插槽得到的函数 2.执行函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>, <span class="string">'插入slot 中 &#123;child:11&#125;'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="生命周期函数-钩子函数"><a href="#生命周期函数-钩子函数" class="headerlink" title="生命周期函数 钩子函数"></a>生命周期函数 钩子函数</h1><ul>
<li>把所有同类钩子先合并成数组，然后存放在 vm.$options<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$options=&#123;</span><br><span class="line">    created:[fn,fn,fn...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化设置一些标志位，表明是否已经完成某种钩子</li>
<li>callHoock <code>vm.$options[&quot;created&quot;][i].call(vm)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">opt</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>._init(opt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype._init(opt)&#123;</span><br><span class="line">    ... 合并选项</span><br><span class="line">    ... 设置初始值 ，事件 等数据</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>);</span><br><span class="line">    ... 初始化选项等数据</span><br><span class="line">    callHook(vm, <span class="string">'created'</span>);</span><br><span class="line">    ...获取挂载的DOM 父节点</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">    ...解析模板成渲染函数，并执行渲染函数，生成DOM插入页面</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件更新时会调用这个函数</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode, hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...重新调用渲染函数，对比旧节点和新节点，得到最小差异，然后只更新这部分页面</span><br><span class="line">    callHook(vm, <span class="string">'updated'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点被移除时会调用这个函数</span></span><br><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>);</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...实例被消除，移除所有 watcher</span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...DOM被移除</span><br><span class="line">    callHook(vm, <span class="string">'destroyed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>1、vnode 是什么及其作用?</p>
<ul>
<li><p>是什么？<strong>JavaScript 对象</strong></p>
</li>
<li><p>什么用？</p>
<ul>
<li>1、兼容node/浏览器。</li>
<li>2、减少操作 DOM。只需要在最后一步挂载更新DOM<br>2、vnode 什么时候生成? vm._render<br>3、vnode 怎么生成?<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"href"</span>:<span class="string">"xxxx"</span>&#125;&#125;,[<span class="string">"1111"</span>]).</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
vm._c = function(a, b, c, d) {    return createElement(vm, a, b, c, d, false);};</li>
</ul>
</li>
<li><p>如果(tag是正常html标签)<br>new VNode(tag, data, children, undefined:text, undefined:elm, context);</p>
</li>
<li><p>否则（tag是组件）<br>createComponent(Ctor, data, context, children, tag);}</p>
</li>
</ul>
<p>4、vnode 存放什么信息?</p>
<ul>
<li>data(1.节点属性，class，style等 2. 绑定事件 )</li>
<li>elm(真实dom节点)<ul>
<li>elm 会在需要创建DOM 时完成赋值，具体函数在 createElm 中</li>
<li>vnode.elm = document.createElement(tag)</li>
</ul>
</li>
<li>context 如果是页面就是页面实例，如果是组件就是组件实例</li>
<li>isStatic 静态节点 不需要对比和更新</li>
<li>组件相关属性<ul>
<li>parent 组件的占位符节点</li>
<li>componentInstance 组件生成的VueComponent实例</li>
<li>componentOptions 父子组件交流的证据（props 事件 slot）</li>
</ul>
</li>
</ul>
<p>5、vnode 存放在哪里?</p>
<ul>
<li>parent：组件的父节点中的占位符节点</li>
<li>$vnode：_vnode的parent</li>
<li>_vnode:当前节点的vnode，直接映射成当前真实DOM <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...初始化组件选项等</span><br><span class="line">    mountComponent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ....解析模板，生成渲染函数</span><br><span class="line">    <span class="comment">// 用于生成VNode，生成DOM，挂载DOM</span></span><br><span class="line">    updateComponent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render());</span><br><span class="line">    &#125;;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建 watcher，保存updateComponent为更新函数，新建的时候会立即执行一遍</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, expOrFn</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn ;    </span><br><span class="line">    <span class="keyword">this</span>.getter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前面解析得到的渲染函数，返回生成的 VNode</span></span><br><span class="line">Vue.prototype._render = () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据vnode，生成DOM 挂载</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;    </span><br><span class="line">    <span class="keyword">if</span> (不存在旧节点） &#123; ...使用vnode创建DOM并直接挂载 &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123; ...存在旧节点，开始比对旧节点和新节点，然后创建DOM并挂载 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="从模板到DOM的过程"><a href="#从模板到DOM的过程" class="headerlink" title="从模板到DOM的过程"></a>从模板到DOM的过程</h1><ul>
<li>init<ol>
<li>初始化选项</li>
<li>初始化实例</li>
</ol>
</li>
<li>mount<ol>
<li>解析模板，生成并保存渲染函数</li>
<li>新建watcher并立即执行更新函数vm._update(vm._render)</li>
<li>vm._render调用渲染函数生成Vnode，传给vm._update</li>
<li>vm.<em>update调用vm.<em>_patch</em></em>,根据vnode生成DOM并挂载</li>
</ol>
</li>
</ul>
<h1 id="component创建"><a href="#component创建" class="headerlink" title="component创建"></a>component创建</h1><p>1、页面解析模板得到 VNode 时：创建组件构造函数 + 生成外壳节点保存 父子关联的数据    </p>
<ul>
<li>创建外壳节点的流程：<ol>
<li>页面渲染函数执行   </li>
<li>_c(‘test’) 执行    </li>
<li>createElement 碰到 tag 是一个组件    </li>
<li>从父组件中，拿到 test 组件的options，传入createComponent （作用是创建构造函数和 VNode）    </li>
<li>createComponent 调用 Vue.extend 创建组件构造函数   </li>
<li>新建 VNode，并把构造函数和父组件给子组件的数据保存进去     </li>
<li>返回 VNode</li>
</ol>
</li>
</ul>
<p>2、页面开始挂载 DOM 时：新建建组件实例，解析组件内部模板，生成DOM挂载到父页面</p>
<ul>
<li>挂载DOM的过程<ol>
<li>父页面已经拿到了 VNode，其中会调用 createElm 根据 VNode 生成DOM，进行挂载</li>
<li>不断的递归遍历子节点，使用 createComponent 判断标签是否是组件</li>
<li>遇到组件，拿到组件外壳VNode 的data（data 保存有父组件给子组件的，事件，props，构造函数，钩子）</li>
<li>从 data 中拿到 hook，hook 中拿到 init 钩子，并执行 init 钩子</li>
<li>init 钩子中，调用 createComponentInstanceForVnode 调用组件构造函数，并返回组件</li>
<li>init 钩子中，使用上一步返回的实例，手动调用 vm.$mount 进行组件内部模板解析渲染，并挂载</li>
</ol>
</li>
</ul>
<h1 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h1><ul>
<li><p>自定义事件</p>
<ul>
<li>vm._events存放自定义事件</li>
<li>个人调用：vm.$on就是注册事件，vm.$emit 是 触发事件，vm.$off 就是 解绑事件</li>
<li>组件绑定： <code>&lt;test @test=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code></li>
</ul>
</li>
<li><p>DOM 事件</p>
<ul>
<li>addEventListeners 绑定事件</li>
<li>标签绑定：<code>&lt;div @click=&quot;this.alert(1)&quot;&gt;&lt;/div&gt;</code><ul>
<li>vm._vnode.data.on中存放DOM事件</li>
</ul>
</li>
<li>组件绑定：<code>&lt;test @click.native=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code><ul>
<li>vm._vnode.data.nativeOn中存放DOM事件</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么子组件触发事件之后，调用父组件的方法，而父组件的方法上下文对象还是父组件?<br>因为 methods 方法已经使用 bind 绑定啦，上下文对象固定了为父组件实例的</p>
</li>
</ul>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>nextTick就是设置一个回调，用于异步执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.list =[xx,xx,xx]</span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.isLoading=<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>异步执行，比如，就是把你设置的回调放在 setTimeout 中执行，这样就算异步了，等待当时同步代码执行完毕再执行。多个异步回调没有必要使用多个setTimeout。</p>
<p>nextTick：  </p>
<ol>
<li>存在 回调数组 里。每次调用 nextTick，便往数组里面 push 设置的回调</li>
<li>只注册一个 setTimeout，时间为0，用于遍历 回调数组，然后逐个执行子项</li>
<li>同步代码执行完毕，setTimeout 自然会执行</li>
</ol>
<p>Vue 2.5.3～2.6使用宏任务+微任务<br>Vue &lt;2.4和&gt;2.6 只使用微任务 Promise 没有的话兼容到setTimeout</p>
<ul>
<li><strong>nextTick 回调 + 过滤 watcher</strong> 使得Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次<br>多次修改同一个数据的时候，会准备 push进 回调数组 多个 watcher.update，但是只有第一次是push 成功的，其他的会被过滤掉（watcher.id相同），nextTick 的回调数组中只存在唯一一个 watcher.update</li>
</ul>
<h1 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h1><ul>
<li>parse: 接收 template 原始模板，按照模板的节点 和数据 生成对应的 ast</li>
<li>optimize:遍历递归每一个ast节点，标记静态的节点（没有绑定任何动态数据），这样就知道那部分不会变化，于是在页面需要更新时，减少去比对这部分DOM从而性能优化。</li>
<li>generate：<ul>
<li>把前两步生成完善的 ast 组装成 render 字符串</li>
<li>render = new Function(render字符串)</li>
</ul>
</li>
</ul>
<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><ul>
<li>Diff 的作用?<ul>
<li>减少更新量，找到最小差异部分DOM，只更新差异部分DOM</li>
</ul>
</li>
<li>Diff 的做法？<ul>
<li>同层级比较（只有两个新旧节点是相同Vnode节点的时候，才会去比较他们各自的子节点）</li>
<li>避免过渡优化 O(n<sup>3</sup>) -&gt; O(n)</li>
</ul>
</li>
</ul>
<h1 id="Diff-流程"><a href="#Diff-流程" class="headerlink" title="Diff 流程"></a>Diff 流程</h1><p>  在同层新旧Vnode节点中</p>
<p>1、先找到 不需要移动的相同节点，消耗最小</p>
<ul>
<li>两头 新旧的头指针 后移 一位</li>
<li>两尾 新旧的尾指针 前移 一位</li>
</ul>
<p>2、再找相同但是需要移动的节点，消耗第二小</p>
<ul>
<li>老头新尾 <strong>将old start 移动到old end的后面</strong>，old start +1 ，new end -1</li>
<li>老尾新头 <strong>将old end 移动到old start的前面</strong>，old end -1 ， new start +1  </li>
<li>都不匹配 在旧的vnode数组中查找 newStartVnode 的下标，没有key的话要比较tag<ul>
<li>相同则 patchVnode并移动到oldStart前</li>
<li>不相同 新建DOM节点oldStart前   </li>
</ul>
</li>
</ul>
<p>3、最后找不到，才会去新建删除节点，保底处理  </p>
<ul>
<li>旧Vnode 树 和 新Vnode树 进行比较的过程中<br>,不会对这两棵Vode树进行修改，而是以比较的结果直接对 真实DOM 进行修改</li>
</ul>
<h1 id="vue-router动态路由"><a href="#vue-router动态路由" class="headerlink" title="vue-router动态路由"></a>vue-router动态路由</h1><p>router.beforeEach((to, from, next) =&gt; {<br>  …axios获取路由节点信息<br>  router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表<br>  next({…to,replace: true})<br>}</p>
<h1 id="vue-动态组件"><a href="#vue-动态组件" class="headerlink" title="vue-动态组件"></a>vue-动态组件</h1><p><component :is="currentView"></component></p>
<h1 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h1><ul>
<li>将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序</li>
<li>优点：1.利于SEO 2.利于首屏加载</li>
<li>缺点：服务端压力较大，开发条件受限</li>
</ul>
<h1 id="路由的History"><a href="#路由的History" class="headerlink" title="路由的History"></a>路由的History</h1><ol>
<li>hash(默认) —— 即地址栏 URL 中的 # 符号比如这个 URL：<a href="http://www.abc.com/#/hello，hash" target="_blank" rel="noopener">http://www.abc.com/#/hello，hash</a> 的值为 #/hello。<br>特点在于：hash 虽然出现在 URL &gt;中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<ol>
<li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>pushState() 可额外设置 title 属性供后续使用。</li>
</ol>
</li>
</ol>
<p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，即使没有做到对路由的全覆盖，也不会返回 404 错误。<br>history 模式下，如果后端缺少对 /book/id 的路由处理，将返回 404 错误。刷新，f5</p>
<h1 id="Vuex数据流"><a href="#Vuex数据流" class="headerlink" title="Vuex数据流"></a>Vuex数据流</h1><p><img src="https://img-blog.csdnimg.cn/20190514091610755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkzNTU0Ng==,size_16,color_FFFFFF,t_70" alt=""><br>将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。</p>
<ul>
<li><p>vuex的store是如何挂载注入到组件中呢？<br>利用vue的mixin混入机制，在beforeCreate钩子前混入vuexInit方法，vuexInit方法实现了store注入vue组件实例，并注册了vuex store的引用属性$store。<br><img src="https://pic4.zhimg.com/80/v2-a8b969f8771a1fc13b7cedfdfe86f0e7_720w.jpg" alt=""></p>
</li>
<li><p>vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？<br>Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>编程</title>
    <url>/2020/02/23/interview/js%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="将字符串中每个单词的首字母大写化"><a href="#将字符串中每个单词的首字母大写化" class="headerlink" title="将字符串中每个单词的首字母大写化"></a>将字符串中每个单词的首字母大写化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> words = s.toLowerCase().split(<span class="regexp">/\s+/</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    words[i] = words[i].slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + words[i].slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> words.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase2</span>(<span class="params">s</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> s.toLowerCase().replace(<span class="regexp">/( |^)[a-z]/g</span>, (L) =&gt; L.toUpperCase());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新闻ul列表，插入3个，获取index"><a href="#新闻ul列表，插入3个，获取index" class="headerlink" title="新闻ul列表，插入3个，获取index"></a>新闻ul列表，插入3个，获取index</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'ulList'</span>);</span><br><span class="line"><span class="keyword">let</span> nodeList= ul.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> index = <span class="built_in">Array</span>.prototype.indexOf.call(nodeList,e.target);</span><br><span class="line">	<span class="built_in">console</span>.log(index) </span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> li=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">	li.style=<span class="string">"width:100px;height:100px;background:#2ea6df;"</span></span><br><span class="line">	li.setAttribute(<span class="string">"class"</span>,<span class="string">"active"</span>)</span><br><span class="line">	li.innerHTML =<span class="string">"abc"</span></span><br><span class="line">	ul.appendChild(li)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个大数相加"><a href="#两个大数相加" class="headerlink" title="两个大数相加"></a>两个大数相加</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBigNumber</span>(<span class="params">s1,s2</span>)</span>&#123;</span><br><span class="line">  s1 = s1.split(<span class="string">""</span>)</span><br><span class="line">  s2 = s2.split(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">""</span></span><br><span class="line">  <span class="keyword">let</span> temp = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(s1.length || s2.length || temp)&#123;</span><br><span class="line">    temp += ~~s1.pop() + ~~s2.pop()</span><br><span class="line">    res = (temp%<span class="number">10</span>) + res</span><br><span class="line">    temp = (temp &gt; <span class="number">9</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.replace(<span class="regexp">/^0+/</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给定两个字符串s1，s2，s2中出现的字符从s1中删除"><a href="#给定两个字符串s1，s2，s2中出现的字符从s1中删除" class="headerlink" title="给定两个字符串s1，s2，s2中出现的字符从s1中删除"></a>给定两个字符串s1，s2，s2中出现的字符从s1中删除</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">s1,s2</span>)</span>&#123;</span><br><span class="line">  s2=s2.split(<span class="string">""</span>)</span><br><span class="line">  s2.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    s1=s1.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(item),<span class="string">""</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> s1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否二叉树是否对称"><a href="#判断是否二叉树是否对称" class="headerlink" title="判断是否二叉树是否对称"></a>判断是否二叉树是否对称</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetric</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isSym(node.left,node.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSym</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span>(left.vale !== right.value ) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(left.left,right.right) &amp;&amp; <span class="built_in">arguments</span>.callee(left.right,right.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断一棵树是否为AVL树"><a href="#判断一棵树是否为AVL树" class="headerlink" title="判断一棵树是否为AVL树"></a>判断一棵树是否为AVL树</h2><pre><code></code></pre>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/vue-blog</title>
    <url>/2020/02/20/interview/vue-blog/</url>
    <content><![CDATA[<h1 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h1><p>1、Vue 是怎么知道数据改变？</p>
<ul>
<li>Object.defineProperty对get和set进行拦截</li>
</ul>
<p>2、Vue 在数据改变时，怎么知道通知哪些视图更新？</p>
<ul>
<li>data 中每个声明的属性<strong>ob</strong>，都会有一个Dep实例 专属的依赖收集器 subs</li>
<li>当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中</li>
<li>ObjectdefineProperty - get 依赖收集 dep.depned</li>
</ul>
<p>3、Vue 在数据改变时，视图怎么知道什么时候更新？</p>
<ul>
<li>Object.defineProperty - set</li>
<li>name 会遍历自己的 依赖收集器 subs，逐个通知 watcher</li>
<li>watcher render-&gt;patch 完成更新</li>
</ul>
<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"a"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testb</span> <span class="attr">:child-name</span>=<span class="string">"parentName"</span> &gt;</span><span class="tag">&lt;/<span class="name">testb</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、父组件 怎么传值给 子组件的 props?</p>
<ul>
<li>父组件的模板 会被解析成一个 模板渲染函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  <span class="comment">// 绑定大括号内代码的 变量访问作用域</span></span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">staticClass</span>:<span class="string">"a"</span>&#125;,[</span><br><span class="line">            _c(<span class="string">'testb'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"child-name"</span>:parentName&#125;&#125;)</span><br><span class="line">        ],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>模板函数会被执行，执行时会绑定 父组件为作用域</li>
<li>所以渲染函数内部所有的变量，都会从父组件对象 上去获取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">attrs</span>: &#123; child-name: parentVm.parentName &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件保存 props</li>
<li>props 会被 保存到 实例的_props 中，并且 会逐一复制到 实例上，并且每一个属性会被设置为响应式的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VueComponent&#123;</span><br><span class="line">  childName:&quot;aaa&quot;,</span><br><span class="line">  _props:&#123;</span><br><span class="line">    childName:&quot;aaa&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2、子组件如何读取props?</li>
<li>复制的时候，会对每个属性，同时设置 get 和 set 函数，进行 访问转接 和 赋值转接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._props[key]&#125;,    </span><br><span class="line"><span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>._props[key] = val&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问 props 其中一个值 vm.childName，其实访问的是 vm._props.childName</li>
<li>赋值 vm.childName= 5 ，其实是赋值 vm._props.childName= 5</li>
</ul>
<p>因此不会影响到父组件data</p>
<p>3、父组件 data 更新，子组件的props 如何更新</p>
<ul>
<li><p>parentName 会收集 父组件的 watcher</p>
</li>
<li><p>render函数中 _c(‘testb’,{attrs:{“child-name”:parentName}被收集依赖</p>
</li>
<li><p>渲染函数执行，开启新一轮的 props 赋值操作</p>
<p>基础类型的props不影响父组件 data，对象类型的props影响</p>
<h1 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h1><p>1、computed 也是响应式的？</p>
</li>
<li><p>给 computed 设置的 get 和 set 函数，会跟 Object.defineProperty 关联</p>
</li>
<li><p>读取computed 时，会执行你设置的 get 函数，还有一层缓存的操作</p>
</li>
</ul>
<p>2、computed 如何控制缓存？</p>
<ul>
<li>【脏数据标志位 dirty】，computed 通过 watcher.dirty 控制是否读取缓存</li>
<li>当 dirty 为 true 时，读取 computed 会重新计算<ul>
<li>computed 新建自己的watcher时，会设置 watcher.dirty = true</li>
<li>依赖的数据变化了，通知 computed 时，会设置 watcher.dirty = true</li>
</ul>
</li>
<li>当 dirty 为 false 时，读取 computed 会使用缓存<ul>
<li>computed 计算完成之后，会设置 watcher.dirty = false</li>
</ul>
</li>
</ul>
<p>3、依赖的 data 改变了，computed 如何更新？<br>computed 会让 【data依赖】 收集到 【依赖computed的watcher】，从而 data 变化时，会同时通知 computed 和 依赖computed的地方</p>
<ul>
<li>页面A 引用了 computed B，computed B 依赖了 data C</li>
<li>data C 开始变化后<ol>
<li>只会重置computed B的 脏数据标志位 dirty =true，不会计算值</li>
<li>通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算<br><img src="https://segmentfault.com/img/remote/1460000019605781?w=563&h=177" alt=""></li>
</ol>
</li>
</ul>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>1、 methods 怎么使用实例访问？</p>
<ul>
<li>遍历 methods 这个对象，然后逐个复制到 实例上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span>(<span class="params">vm, methods</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">        vm[key] = </span><br><span class="line">            methods[key] == <span class="literal">null</span> ? </span><br><span class="line">            noop : </span><br><span class="line">            bind(methods[key], vm);<span class="comment">// 使用bind固定作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"data"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;name:"matt"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、v-model 怎么给表单绑定数据？</p>
<ul>
<li>v-model 绑定的数据赋值给表单元素的 value 属性</li>
<li>value 是 v-model 解析成的原生属性，保存在属于该节点 input 的 domProps 对象存储器中</li>
<li>绑定值：创建dom input 之后-&gt;  遍历该 input 的 domProps ，逐个添加给 dom input -&gt; 插入dom input<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,[</span><br><span class="line">            _c(<span class="string">'input'</span>,</span><br><span class="line">                domProps:&#123;<span class="string">"value"</span>:name&#125; <span class="comment">// name重vm.name获取</span></span><br><span class="line">            )</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>2、v-model 绑定什么事件？</p>
<ul>
<li>change:select，checkbox，radio</li>
<li>input:默认  text、number 等 input 元素和 textarea</li>
</ul>
<p>3、v-model 怎么绑定事件？</p>
<ul>
<li>解析不同表单元素，配置相应的事件名和事件回调，在插入dom之前，addEventListener 绑定上事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, [</span><br><span class="line">        _c(<span class="string">'input'</span>, &#123;        </span><br><span class="line">            on: &#123;             <span class="comment">// 用于addEventListener</span></span><br><span class="line">              <span class="string">"input"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">                  name = $event.target.value</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> vnode.data.on) &#123;</span><br><span class="line">        vnode.elm.addEventListener(event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.addEventListener(<span class="string">"input"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;    </span><br><span class="line">    name = $event.target.value </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、v-model 如何进行双向更新？</p>
<ul>
<li>外部变化，触发事件回调，event.target.value 赋值给model绑定的数据；</li>
<li>内部变化<ul>
<li>v-model 绑定了 name ，name 会收集到 本组件的 watcher</li>
<li>内部修改 name 变化，通知收集器内的 watcher 更新 render-&gt; patch</li>
<li>render内name更新 渲染成新的DOM</li>
</ul>
</li>
</ul>
<h1 id="代理Data"><a href="#代理Data" class="headerlink" title="代理Data"></a>代理Data</h1><ul>
<li>proxy(vm,”_data”,key)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">"name"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>]&#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>] = val;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
好处：</li>
<li>直接通过 vm 访问到data中的name</li>
<li>相比于将data中数据拷贝赋值到vm上，代理的形式减少了数据维护（method是直接赋值的）</li>
<li>不影响依赖更新和收集</li>
</ul>
<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>1、监听的数据改变的时，watch 如何工作？</p>
<ul>
<li>watch 在一开始初始化的时读取监听数值的数据，数据添加到watch的watcher上，</li>
<li>watch设置handler会放在watch的更新函数中 更新时被调用</li>
</ul>
<p>2、设置 immediate 时，watch 如何工作？</p>
<ul>
<li>初始化 watch 时，在读取了 监听的数据的值 之后，便立即调用一遍你设置的监听回调</li>
</ul>
<p>3、设置了 deep 时，watch 如何工作？<br>深度监听对象内部变化</p>
<ul>
<li>(没有设置deep)因为读取了监听的 data 的属性，watch 的 watcher 被收集在 这个属性的 收集器中</li>
<li>(设置了deep)在读取 data 属性的时候，会递归遍历这个值，把内部所有属性逐个读取一遍，于是 属性和 它的对象值内每一个属性 都会收集到 watch 的 watcher</li>
</ul>
<h1 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h1><p>1、Vue.component 注册的 【全局组件】<br>2、Vue.filter 注册的 【全局过滤器】<br>3、Vue.directive 注册的 【全局指令】<br>4、Vue.mixin 注册的 【全局mixin】   </p>
<p>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并起来</p>
<h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>A. 组件选项<br>B. 组件mixin<br>C. 全局mixin<br>权重：选项 &gt; 组件 &gt; 全局  </p>
<p>1、什么时候合并？<br>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并。</p>
<p>2、怎么合并？</p>
<ul>
<li><p>合并成一个函数 (data，provide)：</p>
<ul>
<li>函数合并成一个函数时，选项 &gt; 组件 &gt; 全局  </li>
<li>data中数据重复的，优先级： 选项 &gt; 组件 &gt; 全局  </li>
</ul>
</li>
<li><p>数组叠加（生命周期函数，watch）：</p>
<ul>
<li>权重越大的越放后面，合并数组</li>
<li>执行时 生命周期，权重小的 先执行<br>[<br>全局 mixin - created/watch，<br>组件 mixin - created/watch，<br>组件 options - created/watch<br>]</li>
</ul>
</li>
<li><p>原型叠加（components，filters，directives）</p>
<ul>
<li>权重小的 被放到 权重大 的 的原型上</li>
<li>这样权重大的，访问快些，因为作用域链短了<ul>
<li>A: 组件选项的component</li>
<li>B: 组件mixin的component</li>
<li>C: 全局mixin的component</li>
</ul>
</li>
<li><code>A.__proto__ = B</code> 和<code>B.__proto__ = C</code>  </li>
</ul>
</li>
<li><p>覆盖叠加(props，methods，computed，inject)</p>
<ul>
<li>两个对象合并，如果有重复key，权重大的覆盖权重小的<ul>
<li>组件的 props 会替换 mixin 的props</li>
<li>组件的 methods 会替换 mixin 的methods</li>
<li>组件的 computed 会替换 mixin 的computed</li>
</ul>
</li>
</ul>
</li>
<li><p>直接替换（el，template，propData）</p>
</li>
</ul>
<h1 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;插入slot中:&#123;&#123;name&#125;&#125;&lt;<span class="regexp">/test&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">data()&#123;<span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">"matt"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test 组件</span></span><br><span class="line">&lt;main&gt;</span><br><span class="line">  我在子组件里</span><br><span class="line">  &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/m</span>ain&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，把 插槽当做 test 的子元素处理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span>,        </span><br><span class="line">        children: [<span class="string">'插入slot 中'</span>] <span class="comment">//插槽节点</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [<span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>)]<span class="comment">// slot 第一步解析得到的插槽节点拿到，然后返回</span></span><br><span class="line">    <span class="comment">// children: ['我在子组件里面','插入slot 中']</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、插槽内容怎么解析?插槽如何插子页面?</p>
<ul>
<li>父组件解析<ul>
<li>子组件的插槽解析成<strong>最终节点</strong></li>
<li>保存在子组件占位符节点children中</li>
</ul>
</li>
<li>子组件占位符节点的children转移给子组件选项_renderChildren上</li>
<li>子组件选项 _renderChildren转移给子组件实例$ slot上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件$slot上获取对应的插槽节点并返回，替换占位符   </li>
</ul>
</li>
</ul>
<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><ul>
<li>父组件解析<ul>
<li>子组件的插槽，包装成<strong>函数</strong></li>
<li>保存在子组件占位符节点scopedSlots中</li>
</ul>
</li>
<li>子组件占位符节点的scopedSlots转移给子组件实例上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件scopedSlots上获取对应的插槽函数并执行返回节点，替换占位符   </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;</span><br><span class="line">    &lt;template slot-scope=<span class="string">"slotProps"</span>&gt;插入插槽中&#123;&#123;slotProps&#125;&#125;&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>test&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件test 组件</span></span><br><span class="line"><span class="regexp">&lt;main&gt;</span></span><br><span class="line"><span class="regexp">  我在子组件里</span></span><br><span class="line"><span class="regexp">  &lt;slot :child="child"&gt;&lt;/</span>slot&gt;</span><br><span class="line">&lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件data</span></span><br><span class="line"><span class="regexp">data()&#123;</span></span><br><span class="line"><span class="regexp">  return &#123;child:11&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，<strong>把 插槽包装成一个函数，保存给节点</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span></span><br><span class="line">        scopeSlots:&#123;            </span><br><span class="line">            <span class="keyword">default</span>：<span class="function"><span class="keyword">function</span>(<span class="params">slotProps</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'插入slot 中'</span> + slotProps]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>,&#123;<span class="attr">child</span>:<span class="number">11</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>_t 内部执行:1. 传入的名字（’default’），拿到第一步解析插槽得到的函数 2.执行函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>, <span class="string">'插入slot 中 &#123;child:11&#125;'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="生命周期函数-钩子函数"><a href="#生命周期函数-钩子函数" class="headerlink" title="生命周期函数 钩子函数"></a>生命周期函数 钩子函数</h1><ul>
<li>把所有同类钩子先合并成数组，然后存放在 vm.$options<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$options=&#123;</span><br><span class="line">    created:[fn,fn,fn...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化设置一些标志位，表明是否已经完成某种钩子</li>
<li>callHoock <code>vm.$options[&quot;created&quot;][i].call(vm)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">opt</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>._init(opt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype._init(opt)&#123;</span><br><span class="line">    ... 合并选项</span><br><span class="line">    ... 设置初始值 ，事件 等数据</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>);</span><br><span class="line">    ... 初始化选项等数据</span><br><span class="line">    callHook(vm, <span class="string">'created'</span>);</span><br><span class="line">    ...获取挂载的DOM 父节点</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">    ...解析模板成渲染函数，并执行渲染函数，生成DOM插入页面</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件更新时会调用这个函数</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode, hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...重新调用渲染函数，对比旧节点和新节点，得到最小差异，然后只更新这部分页面</span><br><span class="line">    callHook(vm, <span class="string">'updated'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点被移除时会调用这个函数</span></span><br><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>);</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...实例被消除，移除所有 watcher</span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...DOM被移除</span><br><span class="line">    callHook(vm, <span class="string">'destroyed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>1、vnode 是什么及其作用?</p>
<ul>
<li><p>是什么？<strong>JavaScript 对象</strong></p>
</li>
<li><p>什么用？</p>
<ul>
<li>1、兼容node/浏览器。</li>
<li>2、减少操作 DOM。只需要在最后一步挂载更新DOM<br>2、vnode 什么时候生成? vm._render<br>3、vnode 怎么生成?<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"href"</span>:<span class="string">"xxxx"</span>&#125;&#125;,[<span class="string">"1111"</span>]).</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
vm._c = function(a, b, c, d) {    return createElement(vm, a, b, c, d, false);};</li>
</ul>
</li>
<li><p>如果(tag是正常html标签)<br>new VNode(tag, data, children, undefined:text, undefined:elm, context);</p>
</li>
<li><p>否则（tag是组件）<br>createComponent(Ctor, data, context, children, tag);}</p>
</li>
</ul>
<p>4、vnode 存放什么信息?</p>
<ul>
<li>data(1.节点属性，class，style等 2. 绑定事件 )</li>
<li>elm(真实dom节点)<ul>
<li>elm 会在需要创建DOM 时完成赋值，具体函数在 createElm 中</li>
<li>vnode.elm = document.createElement(tag)</li>
</ul>
</li>
<li>context 如果是页面就是页面实例，如果是组件就是组件实例</li>
<li>isStatic 静态节点 不需要对比和更新</li>
<li>组件相关属性<ul>
<li>parent 组件的占位符节点</li>
<li>componentInstance 组件生成的VueComponent实例</li>
<li>componentOptions 父子组件交流的证据（props 事件 slot）</li>
</ul>
</li>
</ul>
<p>5、vnode 存放在哪里?</p>
<ul>
<li>parent：组件的父节点中的占位符节点</li>
<li>$vnode：_vnode的parent</li>
<li>_vnode:当前节点的vnode，直接映射成当前真实DOM <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...初始化组件选项等</span><br><span class="line">    mountComponent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ....解析模板，生成渲染函数</span><br><span class="line">    <span class="comment">// 用于生成VNode，生成DOM，挂载DOM</span></span><br><span class="line">    updateComponent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render());</span><br><span class="line">    &#125;;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建 watcher，保存updateComponent为更新函数，新建的时候会立即执行一遍</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, expOrFn</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn ;    </span><br><span class="line">    <span class="keyword">this</span>.getter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前面解析得到的渲染函数，返回生成的 VNode</span></span><br><span class="line">Vue.prototype._render = () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据vnode，生成DOM 挂载</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;    </span><br><span class="line">    <span class="keyword">if</span> (不存在旧节点） &#123; ...使用vnode创建DOM并直接挂载 &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123; ...存在旧节点，开始比对旧节点和新节点，然后创建DOM并挂载 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="从模板到DOM的过程"><a href="#从模板到DOM的过程" class="headerlink" title="从模板到DOM的过程"></a>从模板到DOM的过程</h1><ul>
<li>init<ol>
<li>初始化选项</li>
<li>初始化实例</li>
</ol>
</li>
<li>mount<ol>
<li>解析模板，生成并保存渲染函数</li>
<li>新建watcher并立即执行更新函数vm._update(vm._render)</li>
<li>vm._render调用渲染函数生成Vnode，传给vm._update</li>
<li>vm.<em>update调用vm.<em>_patch</em></em>,根据vnode生成DOM并挂载</li>
</ol>
</li>
</ul>
<h1 id="component创建"><a href="#component创建" class="headerlink" title="component创建"></a>component创建</h1><p>1、页面解析模板得到 VNode 时：创建组件构造函数 + 生成外壳节点保存 父子关联的数据    </p>
<ul>
<li>创建外壳节点的流程：<ol>
<li>页面渲染函数执行   </li>
<li>_c(‘test’) 执行    </li>
<li>createElement 碰到 tag 是一个组件    </li>
<li>从父组件中，拿到 test 组件的options，传入createComponent （作用是创建构造函数和 VNode）    </li>
<li>createComponent 调用 Vue.extend 创建组件构造函数   </li>
<li>新建 VNode，并把构造函数和父组件给子组件的数据保存进去     </li>
<li>返回 VNode</li>
</ol>
</li>
</ul>
<p>2、页面开始挂载 DOM 时：新建建组件实例，解析组件内部模板，生成DOM挂载到父页面</p>
<ul>
<li>挂载DOM的过程<ol>
<li>父页面已经拿到了 VNode，其中会调用 createElm 根据 VNode 生成DOM，进行挂载</li>
<li>不断的递归遍历子节点，使用 createComponent 判断标签是否是组件</li>
<li>遇到组件，拿到组件外壳VNode 的data（data 保存有父组件给子组件的，事件，props，构造函数，钩子）</li>
<li>从 data 中拿到 hook，hook 中拿到 init 钩子，并执行 init 钩子</li>
<li>init 钩子中，调用 createComponentInstanceForVnode 调用组件构造函数，并返回组件</li>
<li>init 钩子中，使用上一步返回的实例，手动调用 vm.$mount 进行组件内部模板解析渲染，并挂载</li>
</ol>
</li>
</ul>
<h1 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h1><ul>
<li><p>自定义事件</p>
<ul>
<li>vm._events存放自定义事件</li>
<li>个人调用：vm.$on就是注册事件，vm.$emit 是 触发事件，vm.$off 就是 解绑事件</li>
<li>组件绑定： <code>&lt;test @test=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code></li>
</ul>
</li>
<li><p>DOM 事件</p>
<ul>
<li>addEventListeners 绑定事件</li>
<li>标签绑定：<code>&lt;div @click=&quot;this.alert(1)&quot;&gt;&lt;/div&gt;</code><ul>
<li>vm._vnode.data.on中存放DOM事件</li>
</ul>
</li>
<li>组件绑定：<code>&lt;test @click.native=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code><ul>
<li>vm._vnode.data.nativeOn中存放DOM事件</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么子组件触发事件之后，调用父组件的方法，而父组件的方法上下文对象还是父组件?<br>因为 methods 方法已经使用 bind 绑定啦，上下文对象固定了为父组件实例的</p>
</li>
</ul>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>nextTick就是设置一个回调，用于异步执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.list =[xx,xx,xx]</span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.isLoading=<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>异步执行，比如，就是把你设置的回调放在 setTimeout 中执行，这样就算异步了，等待当时同步代码执行完毕再执行。多个异步回调没有必要使用多个setTimeout。</p>
<p>nextTick：  </p>
<ol>
<li>存在 回调数组 里。每次调用 nextTick，便往数组里面 push 设置的回调</li>
<li>只注册一个 setTimeout，时间为0，用于遍历 回调数组，然后逐个执行子项</li>
<li>同步代码执行完毕，setTimeout 自然会执行</li>
</ol>
<p>Vue 2.5.3～2.6使用宏任务+微任务<br>Vue &lt;2.4和&gt;2.6 只使用微任务 Promise 没有的话兼容到setTimeout</p>
<ul>
<li><strong>nextTick 回调 + 过滤 watcher</strong> 使得Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次<br>多次修改同一个数据的时候，会准备 push进 回调数组 多个 watcher.update，但是只有第一次是push 成功的，其他的会被过滤掉（watcher.id相同），nextTick 的回调数组中只存在唯一一个 watcher.update</li>
</ul>
<h1 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h1><ul>
<li>parse: 接收 template 原始模板，按照模板的节点 和数据 生成对应的 ast</li>
<li>optimize:遍历递归每一个ast节点，标记静态的节点（没有绑定任何动态数据），这样就知道那部分不会变化，于是在页面需要更新时，减少去比对这部分DOM从而性能优化。</li>
<li>generate：<ul>
<li>把前两步生成完善的 ast 组装成 render 字符串</li>
<li>render = new Function(render字符串)</li>
</ul>
</li>
</ul>
<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><ul>
<li>Diff 的作用?<ul>
<li>减少更新量，找到最小差异部分DOM，只更新差异部分DOM</li>
</ul>
</li>
<li>Diff 的做法？<ul>
<li>同层级比较（只有两个新旧节点是相同Vnode节点的时候，才会去比较他们各自的子节点）</li>
<li>避免过渡优化 O(n<sup>3</sup>) -&gt; O(n)</li>
</ul>
</li>
</ul>
<h1 id="Diff-流程"><a href="#Diff-流程" class="headerlink" title="Diff 流程"></a>Diff 流程</h1><p>  在同层新旧Vnode节点中</p>
<p>1、先找到 不需要移动的相同节点，消耗最小</p>
<ul>
<li>两头 新旧的头指针 后移 一位</li>
<li>两尾 新旧的尾指针 前移 一位</li>
</ul>
<p>2、再找相同但是需要移动的节点，消耗第二小</p>
<ul>
<li>老头新尾 <strong>将old start 移动到old end的后面</strong>，old start +1 ，new end -1</li>
<li>老尾新头 <strong>将old end 移动到old start的前面</strong>，old end -1 ， new start +1  </li>
<li>都不匹配 在旧的vnode数组中查找 newStartVnode 的下标，没有key的话要比较tag<ul>
<li>相同则 patchVnode并移动到oldStart前</li>
<li>不相同 新建DOM节点oldStart前   </li>
</ul>
</li>
</ul>
<p>3、最后找不到，才会去新建删除节点，保底处理  </p>
<ul>
<li>旧Vnode 树 和 新Vnode树 进行比较的过程中<br>,不会对这两棵Vode树进行修改，而是以比较的结果直接对 真实DOM 进行修改</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>interview/js加载图片</title>
    <url>/2020/02/19/interview/js%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

<body>
  <div id="mypic" style="background-color: yellow;">
    <div id="middle" style="background-color: red; width: 50%;">
      <a href="#" id="inner" style="background-color: green;">里面的东西</a>
    </div>
  </div>
</body>
<script>
  var obj = new Image();
  obj.src = "https://dss0.bdstatic.com/6Ox1bjeh1BF3odCf/it/u=3533778697,2586993014&fm=74&app=80&f=PNG&size=f121,121?sec=1880279984&t=1dbed90be2871a78074bf731b6872ed0";
  obj.onload = function() {
    console.log('图片的宽度为：' + obj.width + '；图片的高度为：' + obj.height);
    console.log("<img src='" + this.src + "' />")
    document.getElementById("mypic").innerHTML = "<img src='" + this.src + "' />";
    // document.getElementById("mypic").innnerHTML = "<img src='" + this.src + "' />";
    console.log(document.getElementById("mypic").innerHTML)
  }
</script>

</html>
]]></content>
  </entry>
  <entry>
    <title>javascript知识点</title>
    <url>/2020/02/17/interview/javascript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h1><h2 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h2><ul>
<li>直接调用，立即执行 -&gt; window|gloable</li>
<li>obj.foo() -&gt; obj</li>
<li>new Foo() -&gt; foo</li>
<li>箭头函数 -&gt; 没有this、arguments、prototype</li>
<li>bind({a:100}) -&gt; {a:100} 第一个bind </li>
<li>bind() -&gt; window|gloable</li>
<li>new &gt; bind &gt; 对象调用 &gt; 直接调用<a id="more"></a>

</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>原始类型不包含 Object 和 Function</li>
<li>新增Symbol和BigInt</li>
<li>typeof null和typeof [1, 2, 3]均返回”object”</li>
<li>instanceof 用于实例和构造函数对应</li>
<li>判断是否是数组：[1, 2, 3] instanceof Array</li>
<li>Array.isArray({})返回false</li>
</ul>
<h2 id="数据类型转换-“-”"><a href="#数据类型转换-“-”" class="headerlink" title="数据类型转换 “+”"></a>数据类型转换 “+”</h2><ul>
<li>调用实例方法优先级：[Symbol.toPrimitive] &gt; valueOf &gt; toString</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul>
<li>地址引用的函数和对象都是浅拷贝</li>
<li>Object.assign()和 …</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>JSON.parse(JSON.stringify(src))：属性值是function/undefined/Circle嵌套 或者一个类的实例foo的时候，无法正确拷贝</li>
</ul>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><ul>
<li><p>事件捕获 -&gt; 事件冒泡</p>
</li>
<li><p>捕获：从根节点开始执行，一直向子节点传递，直到目标节点。</p>
</li>
<li><p>冒泡：可以通过stopPropagation方法终止冒泡。</p>
</li>
<li><p>DOM2：element.addEventListener(event, function, useCapture)  默认false冒泡</p>
</li>
<li><p>DOM0：html/js绑定on不推荐</p>
</li>
</ul>
<h2 id="ES5继承"><a href="#ES5继承" class="headerlink" title="ES5继承"></a>ES5继承</h2><ul>
<li>绑定构造函数 -&gt; 不能继承父类原型方法/属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 执行父类的构造方法, 上下文为实例对象</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>原型链继承 -&gt; 父构造函数传参<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></li>
<li>组合继承 -&gt;绑定+原型 调用了2次父类的构造函数</li>
<li>寄生组合继承 -&gt; 最理想<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2></li>
<li>所有的引用类型（数组、对象、函数），<strong>proto</strong>属性值指向它的构造函数的 prototype 属性值</li>
<li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<strong>proto</strong>（即它的构造函数的prototype）中寻找</li>
<li>Foo.prototype.<strong>proto</strong> = Object.prototype</li>
<li>Object.prototype.<strong>proto</strong> = null</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>作用域：变量在<strong>声明</strong>它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</li>
<li>作用域链:当前作用域没有找到定义，继续向父级作用域寻找，直至全局作用域。</li>
<li>ES5 有”全局作用域“和”函数作用域“。<ul>
<li>IIFE 块级闭包：var a =(function b(){})()<ul>
<li>函数名b为 <strong>只读</strong> 状态，无法修改,</li>
<li>变量名a在函数内部无法访问（块作用域）</li>
</ul>
</li>
</ul>
</li>
<li>ES6 的let和const 有”块级作用域“。<ul>
<li>变量生命周期：<ul>
<li><strong>声明</strong>（作用域注册一个变量）</li>
<li><strong>初始化</strong>（分配栈内存，初始化为undefined）</li>
<li><strong>赋值</strong></li>
</ul>
</li>
<li>let/const 声明提升 -&gt; 暂时性死区、var 初始化提升、function赋值提升 <ul>
<li>函数声明 &gt; 函数表达式 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li><p>JS 是单线程的，先跑<strong>执行栈里</strong>的<strong>同步任务</strong>，然后再跑<strong>任务队列</strong>的<strong>异步任务</strong>。</p>
</li>
<li><p>当执行栈的栈空，js会读取任务队列，</p>
<ul>
<li>执行一个宏任务(先执行同步代码)–&gt;执行所有微任务–&gt;UI render</li>
<li>宏任务：主代码块 &gt; setTimeout / setInterval &gt; IO回调 &gt; requestAnimationFrame &gt; UIrender(重绘)</li>
<li>微任务：Promise回调</li>
</ul>
</li>
<li><p>循环进行，所以称作Loop</p>
</li>
</ul>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li>全局执行上下文:解析JS时创建。<ul>
<li>this（全局对象window）</li>
<li>变量对象（全局变量）</li>
<li>作用域链。</li>
</ul>
</li>
<li>函数执行上下文：调用函数时创建<ul>
<li>this,</li>
<li>变量对象（局部变量、<strong>多了arguments和参数</strong>),</li>
<li>作用域链（AO+父作用域[词法环境下]）</li>
</ul>
</li>
<li>词法环境：Js 中的函数运行在它们被<strong>定义</strong>的作用域，而不是它们被执行的作用域</li>
<li>this:<strong>执行</strong>的时候确定</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>闭包是函数和声明该函数的词法环境的组合</li>
<li>保证变量不被GC回收</li>
<li>优：避免全局污染</li>
<li>缺：内存泄漏（浏览器强制刷新、node显示null清理）</li>
</ul>
<h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><ul>
<li>(es6)import属于 <strong>异步</strong> 导入<ul>
<li>(node commonjs)require是 <strong>同步</strong> 导入</li>
</ul>
</li>
<li>(es6)import指向 <strong>内存地址</strong>，导入值会随导出值而变化<ul>
<li>(node commonjs)require是 <strong>值拷贝</strong>，导出值变化不会影响导入值；</li>
</ul>
</li>
<li>import()函数 与require支持动态加载</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>源码模拟</title>
    <url>/2020/02/17/interview/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul>
<li>思想: fn.call(obj,…args)转换成obj.fn(…args)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  </span><br><span class="line">  obj = obj || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 保存obj中原有的fn</span></span><br><span class="line">  <span class="keyword">const</span> &#123;fn&#125; = obj</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将函数本身作为对象obj的属性调用，自动绑定this</span></span><br><span class="line">  obj.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result =obj.fn(...args)</span><br><span class="line"></span><br><span class="line">  obj.fn = fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul>
<li>思想：fn.call(obj,args) 转换成obj.fn(args)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  </span><br><span class="line">  obj = obj || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 保存obj中原有的fn</span></span><br><span class="line">  <span class="keyword">const</span> &#123;fn&#125; = obj</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将函数本身作为对象obj的属性调用，自动绑定this</span></span><br><span class="line">  obj.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(args)) &#123;</span><br><span class="line">    result =obj.fn(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = obj.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  obj.fn = fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ul>
<li>思想 return function F(){ return new fn() 或者return fn.apply(…)}<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> fn(...args,...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj,args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="string">'cat'</span>) = &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj,<span class="string">"cat"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span>? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>思路：1. 数组拷贝（递归）2.对象拷贝（递归） 3.基本类型 </li>
<li>Object.keys()返回属性key，但仅包括可枚举的属性</li>
<li>Reflect.ownKeys()返回所有属性key<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src &amp;&amp; <span class="keyword">typeof</span> src == <span class="string">'object'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">src,hash=new WeakMap(</span>))</span>&#123;    <span class="comment">// 添加hash解决嵌套引用</span></span><br><span class="line">  <span class="keyword">if</span>(!isObject(src))&#123; <span class="keyword">return</span> src&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hash.has(src)) <span class="keyword">return</span> hash.get(src);  <span class="comment">// 添加hash解决嵌套引用</span></span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(src)</span><br><span class="line">  <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(src)?[]:&#123;&#125;</span><br><span class="line">  hash.set(src, target);  <span class="comment">//// 添加hash解决嵌套引用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys)&#123;</span><br><span class="line">    <span class="keyword">let</span> value = src[key]</span><br><span class="line">    <span class="keyword">if</span>(isObject(value))&#123;  <span class="comment">//object和array</span></span><br><span class="line">      target[key] = cloneObject(value,hash)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul>
<li>es5 Object.defineProperty(obj,”value”,{})<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line"><span class="actionscript">        value: <span class="string">""</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">onKeyUp</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line">        obj.value = event.target.value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 对 obj.value 进行拦截</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"value"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> value;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>&#123;</span></span><br><span class="line">          value = newValue;</span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">"#value"</span>).innerHTML = newValue; <span class="comment">// 更新视图层</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">"input"</span>).value = newValue; <span class="comment">// 数据模型改变</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>值是：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onkeyup</span>=<span class="string">"onKeyUp(event)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
es6 vue3.0放弃IE，使用Proxy来实现双向数据绑定<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> obj = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, key, receiver)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, key, value, receiver)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(key === <span class="string">'value'</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">'#value'</span>).innerHTML = value</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>).value = value</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">onKeyUp</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line">      newObj.value = event.target.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    值是：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onkeyup</span>=<span class="string">"onKeyUp(event)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>通过原型链来进行判断的，所以只要不断地通过访问<strong>proto</strong>，就可以拿到构造函数的原型prototype。直到null停止。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iof</span>(<span class="params">obj,cons</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = cons.prototype</span><br><span class="line">  <span class="keyword">let</span> _proto = obj.__proto__</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_proto)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_proto == prototype)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    _proto = _proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间绑定-解绑-触发"><a href="#时间绑定-解绑-触发" class="headerlink" title="时间绑定/解绑/触发"></a>时间绑定/解绑/触发</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组置空：</span></span><br><span class="line"><span class="comment">// arr = []; arr.length = 0; arr.splice(0, arr.length)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._cache = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册事件：如果不存在此种type，创建相关数组</span></span><br><span class="line">  on(type, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>._cache[type] = <span class="keyword">this</span>._cache[type] || [];</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>._cache[type];</span><br><span class="line">    <span class="keyword">if</span> (fns.indexOf(callback) === <span class="number">-1</span>) &#123;</span><br><span class="line">      fns.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件：对于一个type中的所有事件函数，均进行触发</span></span><br><span class="line">  trigger(type, ...data) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>._cache[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(...data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除事件：删除事件类型对应的array</span></span><br><span class="line">  off(type, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>._cache[type];</span><br><span class="line">    <span class="comment">// 检查是否存在type的事件绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        <span class="comment">// 卸载指定的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> index = fns.indexOf(callback);</span><br><span class="line">        <span class="keyword">if</span> (index !== <span class="number">-1</span>) &#123;</span><br><span class="line">          fns.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 全部清空</span></span><br><span class="line">        fns = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是测试函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> Event();</span><br><span class="line">event</span><br><span class="line">  .on(<span class="string">"test"</span>, a =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;)</span><br><span class="line">  .trigger(<span class="string">"test"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Promise-resolve-‘foo’"><a href="#Promise-resolve-‘foo’" class="headerlink" title="Promise.resolve(‘foo’)"></a>Promise.resolve(‘foo’)</h1><p>// 等价于<br>new Promise(resolve =&gt; resolve(‘foo’))</p>
<h1 id="Promise-reject-‘foo’"><a href="#Promise-reject-‘foo’" class="headerlink" title="Promise.reject(‘foo’)"></a>Promise.reject(‘foo’)</h1><p>// 等价于<br>new Promise(null,reject =&gt; reject(‘foo’))</p>
<h1 id="Promise-prototype-catch方法"><a href="#Promise-prototype-catch方法" class="headerlink" title="Promise.prototype.catch方法"></a>Promise.prototype.catch方法</h1><p>等价于.then(null, rejection)</p>
<h1 id="Promise-prototype-done"><a href="#Promise-prototype-done" class="headerlink" title="Promise.prototype.done"></a>Promise.prototype.done</h1><p>确保最后一个方法可以抛出错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve,reject).catch(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;,<span class="number">0</span>)  <span class="comment">//抛出全局错误</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>window.Promise &amp;&amp; !(‘finally’ in Promise) &amp;&amp; !function() {<br>  Promise.prototype.finally = function(cb) {<br>    cb = typeof cb === ‘function’ ? cb : function() {};</p>
<pre><code>var Fn = this.constructor;  // 获取当前实例构造函数的引用

// 接受状态：返回数据
var onFulfilled = function(data) {
  return Fn.resolve(cb()).then(function() {
    return data
  })
};

// 拒绝状态：抛出错误
var onRejected = function(err) {
  return Fn.resolve(cb()).then(function() {
    throw err
  })
};

return this.then(onFulfilled, onRejected);</code></pre><p>  }<br>}();</p>
<p>/<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong> 测试 <strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong>/<br>const p = new Promise((resolve, reject) =&gt; {<br>  console.info(‘starting…’);</p>
<p>  setTimeout(() =&gt; {<br>    Math.random() &gt; 0.5 ? resolve(‘success’) : reject(‘fail’);<br>  }, 1000);<br>});</p>
<p>// 正常顺序测试<br>p.then((data) =&gt; {<br>    console.log(<code>%c resolve: ${data}</code>, ‘color: green’)<br>  })<br>  .catch((err) =&gt; {<br>    console.log(<code>%c catch: ${err}</code>, ‘color: red’)<br>  })<br>  .finally(() =&gt; {<br>    console.info(‘finally: completed’)<br>  });</p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"argument must be anarray"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> countNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> promiseNum = promises.length;</span><br><span class="line">    <span class="keyword">var</span> resolvedvalue = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        countNum++;</span><br><span class="line">        resolvedvalue[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (countNum === promiseNum) &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(resolvedvalue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">  p2 = <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">  p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">promiseAll([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;, (reason) =&gt; &#123; <span class="built_in">console</span>.log(reason) &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve,reject)&#123;</span><br><span class="line">    promises.forEach(</span><br><span class="line">      prom =&gt; <span class="built_in">Promise</span>.resolve(prom).then(resolve, reject)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="literal">null</span>, succallbacks = [], failcallbacks = [];</span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">fulfilled, rejected</span>) </span>&#123;</span><br><span class="line">        succallbacks.push(fulfilled);</span><br><span class="line">        failcallbacks.push(rejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">         succallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">             callback(value);</span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        failcallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(num); <span class="comment">//1   去掉time 则不会执行</span></span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>阮一峰的网络日志</title>
    <url>/2020/02/17/%E9%98%AE%E4%B8%80%E5%B3%B0/1/</url>
    <content><![CDATA[<h2 id="Javascript获取页面元素的位置"><a href="#Javascript获取页面元素的位置" class="headerlink" title="Javascript获取页面元素的位置"></a>Javascript获取页面元素的位置</h2><ul>
<li>document.body<ul>
<li>页面大小：clientWidth</li>
<li>滚动页面大小：scrollWidth</li>
<li>滚动左侧：scrollLeft</li>
</ul>
</li>
<li>HTMLElement<ul>
<li>偏移距离：offsetTop</li>
</ul>
</li>
<li>相对浏览器窗口（viewport）左上角距离：getBoundingClientRect()<ul>
<li>相对位置：var X= this.getBoundingClientRect().left;</li>
<li>绝对位置：var X= this.getBoundingClientRect().left+document.body.scrollLeft;</li>
</ul>
</li>
</ul>
<h2 id="面向对象-封装"><a href="#面向对象-封装" class="headerlink" title="面向对象-封装"></a>面向对象-封装</h2><ul>
<li>构造函数：this绑定本地属性和方法</li>
<li>原型：共享的属性和方法</li>
<li>Cat.prototype.<strong>isPrototypeOf</strong>(cat1):判断原型对象与实例关系</li>
<li>cat1.<strong>hasOwnProperty</strong>(“name”)：判断某一个属性到底是本地属性，还是继承自prototype对象的属性</li>
<li>“type” <strong>in</strong> cat1:某个实例是否含有某个(实例或原型)属性</li>
</ul>
<h2 id="面向对象-构造函数的继承"><a href="#面向对象-构造函数的继承" class="headerlink" title="面向对象-构造函数的继承"></a>面向对象-构造函数的继承</h2><p>参考[javascript知识点]</p>
<h2 id="面向对象-非构造函数的继承"><a href="#面向对象-非构造函数的继承" class="headerlink" title="面向对象-非构造函数的继承"></a>面向对象-非构造函数的继承</h2><ul>
<li>把子对象的prototype属性，指向父对象</li>
<li>深拷贝父对象</li>
</ul>
<h2 id="防止iframe嵌入"><a href="#防止iframe嵌入" class="headerlink" title="防止iframe嵌入"></a>防止iframe嵌入</h2><ul>
<li>响应头设置<code>x-frame-options</code></li>
<li>top重定向<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location.hostname != <span class="built_in">window</span>.location.hostname) &#123;</span><br><span class="line">　　top.location.href = <span class="built_in">window</span>.location.href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>console.profile() console.profileEnd();</li>
</ul>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul>
<li>表单元素file<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"upload-form"</span> <span class="attr">action</span>=<span class="string">"upload.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">name</span>=<span class="string">"upload"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2></li>
<li>回调函数 同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="js实现拖拽"><a href="#js实现拖拽" class="headerlink" title="js实现拖拽"></a>js实现拖拽</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dragObj = <span class="built_in">document</span>.getElementById(<span class="string">"out"</span>);</span><br><span class="line">        dragObj.style.left = <span class="string">"0px"</span>;</span><br><span class="line">        dragObj.style.top = <span class="string">"0px"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mouseX, mouseY, objX, objY;</span><br><span class="line">        <span class="keyword">var</span> dragging = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        dragObj.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">            dragging = <span class="literal">true</span>;</span><br><span class="line">            dragObj.style.position = <span class="string">"relative"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            mouseX = event.clientX;</span><br><span class="line">            mouseY = event.clientY;</span><br><span class="line">          <span class="built_in">console</span>.log(mouseX+<span class="string">","</span>+mouseY);</span><br><span class="line">            objX = <span class="built_in">parseInt</span>(dragObj.style.left);</span><br><span class="line">            objY = <span class="built_in">parseInt</span>(dragObj.style.top);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            event = event || <span class="built_in">window</span>.event;</span><br><span class="line">            <span class="keyword">if</span> (dragging) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(event.clientX+<span class="string">","</span>+event.clientY)</span><br><span class="line">                dragObj.style.left = <span class="built_in">parseInt</span>(event.clientX - mouseX + objX) + <span class="string">"px"</span>;</span><br><span class="line">                dragObj.style.top = <span class="built_in">parseInt</span>(event.clientY - mouseY + objY) + <span class="string">"px"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dragging = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>阮一峰</category>
      </categories>
      <tags>
        <tag>阮一峰</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/02/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>参考 <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度</th>
<th>稳定</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
</tr>
<tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定 最坏O(n<sup>2</sup>)</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><table>
<thead>
<tr>
<th>插入</th>
<th>O(n<sup>2</sup>)</th>
<th>稳定</th>
</tr>
</thead>
</table>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="插入排序"></p>
<ul>
<li>将第一位当作新数组，不断地往里面插入新数字 <ul>
<li>i++  </li>
<li>j–  </li>
<li>j交换j-1<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">        [arr[j],arr[j<span class="number">-1</span>]]=[arr[j<span class="number">-1</span>],arr[j]]</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><table>
<thead>
<tr>
<th>冒泡</th>
<th>O(n<sup>2</sup>)</th>
<th>稳定</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="冒泡排序"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>相邻元素比较，从左往右，最大的到末尾<ul>
<li>i–</li>
<li>j++</li>
<li>j交换j-1<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">        [arr[j],arr[j<span class="number">-1</span>]]=[arr[j<span class="number">-1</span>],arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><table>
<thead>
<tr>
<th>选择</th>
<th>O(n<sup>2</sup>)</th>
<th>不稳定</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="选择排序"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 每次循环都找出最小的到前端</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* i++</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* j++</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* j交换i</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;=arr.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">        [arr[j],arr[i]]=[arr[i],arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><table>
<thead>
<tr>
<th>快速</th>
<th>O(nlog<sub>2</sub>n)</th>
<th>不稳定 最坏O(n<sup>2</sup>)</th>
</tr>
</thead>
<tbody><tr>
<td>* 大的放右边，小的放左边</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变异写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length &lt;=<span class="number">1</span>?arr:</span><br><span class="line">    quickSort(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item&lt;arr[<span class="number">0</span>]))</span><br><span class="line">    .concat(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item==arr[<span class="number">0</span>]))</span><br><span class="line">    .concat(quickSort(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;arr[<span class="number">0</span>])))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="快速排序"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非变异写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,            <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><table>
<thead>
<tr>
<th>归并</th>
<th>O(nlog<sub>2</sub>n)</th>
<th>稳定</th>
</tr>
</thead>
<tbody><tr>
<td>* 分为左右两个数组，递归排序，合并</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变异方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>,middle);</span><br><span class="line">    <span class="keyword">let</span> right = arr.slice(middle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = merge(mergeSort(left),mergeSort(right));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>])&#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left.length)&#123;</span><br><span class="line">        result = result.concat(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right.length)&#123;</span><br><span class="line">        result = result.concat(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2020/02/16/es6%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="let-和const"><a href="#let-和const" class="headerlink" title="let 和const"></a>let 和const</h2><ul>
<li>不允许重复声明</li>
<li>不存在变量提升 (var-&gt;undefined foo-&gt;ReferenceError)</li>
<li>暂时性死区 （变量就已经存在了，但是不可获取，只有声明变量，才可获取和使用该变量）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp =<span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>let命令、const命令、class命令声明的全局变量，不属于顶层对象(window,globle)的属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2></li>
<li>交换变量[x, y] = [y, x];</li>
<li>从函数返回多个值</li>
<li>提取json数据</li>
<li>函数参数默认值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li>
<li>函数参数的定义<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>遍历map<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>import {a,b} from ‘…’</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>Number.isFinite(), Number.isNaN()</li>
<li>Number.parseInt(), Number.parseFloat()</li>
<li>Number.isInteger(25) // true</li>
<li>Number.isInteger(25.0) // true</li>
<li>Number.EPSILON // 2.220446049250313e-16</li>
<li>(0.1 + 0.2 - 0.3)&lt;Number.EPSILON</li>
<li>Number.isSafeInteger() -2^53到2^53之间（不含两个端点）</li>
<li>99 ** 99 == Math.pow(99, 99)</li>
</ul>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul>
<li>Array.from(target[,map回调函数])转换成数组<ul>
<li>类数组对象 <ul>
<li>document.querySelectorAll(‘p’)</li>
<li>arguments</li>
<li>“hello”</li>
<li>任何带length属性的对象<ul>
<li>Array.from({ length: 3}) ==&gt; [undefined,undefined,undefined]</li>
</ul>
</li>
</ul>
</li>
<li>可遍历（iterable）的对象<ul>
<li>set </li>
<li>map</li>
</ul>
</li>
</ul>
</li>
<li>Array.of() 参数转数组</li>
<li>find(callback)/findIndex(callback) 根据回调找第一个元素/下标</li>
<li>keys()、values()、entries()</li>
<li>includes()</li>
</ul>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><ul>
<li>默认参数 <ul>
<li>默认 function log(x, y = ‘World’) {}</li>
<li>解构函数默认 function log({x=’hello’, y = ‘World’}={}){}</li>
</ul>
</li>
<li>func.length // func没有指定默认值且不是rest的参数</li>
<li>function(…rest){}<ul>
<li>[…value] = [1,2,3] value ===&gt; [1,2,3]</li>
<li>[a,…value]=[1,2,3] value ===&gt; [2,3]</li>
<li>[a,…value,c]报错</li>
</ul>
</li>
<li>扩展运算符…<ul>
<li>合并数组 […arr1, …arr2, …arr3]</li>
<li>解构赋值 [a, …rest] = list</li>
<li>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</li>
</ul>
</li>
</ul>
<h2 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set / WeakSet"></a>Set / WeakSet</h2><ul>
<li>WeakSet的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用 =&gt; 不可遍历的。</li>
</ul>
<h2 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a>Map/WeakMap</h2><ul>
<li>object 的key只能是字符串，Map的key可以是对象</li>
<li>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外）</li>
<li>WeakMap应用的典型场合就是DOM节点作为键名。</li>
</ul>
<h2 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h2><ul>
<li>某些方法同时在Object和Reflect对象上部署</li>
<li>Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误</li>
<li>Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>name in obj =&gt; Reflect.has(obj, name)</li>
<li>delete obj[name] =&gt; Reflect.deleteProperty(obj, name)</li>
<li>不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>：function (target, key, value, receiver) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">        queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>缺点：</p>
<ul>
<li>立即执行函数，无法取消</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
</ul>
<h3 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>promise实现ajax操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.erro</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>作用：</p>
<ul>
<li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>二是使得数据结构的成员能够按某种次序排列；</li>
<li>三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象,可以被for of循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>es5：</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象 解决回调地狱</li>
</ul>
<p>es6</p>
<ul>
<li>generator函数</li>
<li>async await （generator和field的语法糖）</li>
</ul>
<p>函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖</title>
    <url>/2020/02/10/%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>Page Title</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <script src='main.js'></script>
<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

<body>
  <h2>防抖demo</h2>
  <p>打开控制台观看效果</p>
  <input id="inp"></input>
</body>
<script>
  function debounce(func, wait, immediate) {

    var timeout;

    return function() {
      var context = this;
      var args = arguments;

      if (timeout) clearTimeout(timeout);
      // 立即执行的情况
      if (immediate) {
        // 如果已经执行过，不再执行
        var callNow = !timeout;
        console.log('callNow:', callNow)
        console.log('timeout:', timeout)
        timeout = setTimeout(function() {
          timeout = null;
        }, wait)
        if (callNow) func.apply(context, args)
      } else {
        timeout = setTimeout(function() {
          func.apply(context, args)
        }, wait);
      }
    }
  }

  function sayHi(a) {
    console.log('防抖成功');
    console.log(a);
  }

  var inp = document.getElementById('inp');
  inp.addEventListener('input', debounce(sayHi, 5000, true).bind(this, 'a')); // 防抖
</script>

</html>]]></content>
  </entry>
  <entry>
    <title>vue整理</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/vue/</url>
    <content><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p><a href="https://zhuanlan.zhihu.com/p/23921964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23921964</a></p>
<h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p><img src="http://103.14.34.148:9000/imgs/blog/img/reactive.png" alt="reactive"></p>
<ol>
<li>Vue的初始化阶段，对vue的属性进行处理对于data和props,Vue会通过ovserve/defineReactive等系列操作，把整个data和props定义的对象每一个属性编成响应式的，同时内部持有一个dep的实例。</li>
<li>当我们访问到响应式数据的时候，就会触发数据内部dep的depend方法来收集依赖</li>
<li>收集依赖收集的是当前正在计算的watcher，也就是说当前的Dep.target就会作为订阅者来订阅这些数据的变化<a id="more"></a></li>
<li>当我们修改响应式数据的时候，setter方法通知调用dep.notify方法来通知订阅者</li>
<li>订阅者来执行update的逻辑</li>
<li>对于computed的属性而言，内部会创建computed watcher，每一个computed watcher，每一个watcher会持有一个Dep的实例，</li>
<li>当我们去访问computed的属性的时候，会调用computed watcher的evaluate的计算方法，会触发内部持有的dep去depend去收集依赖，和数据一样，他也会收集到我们当前正在计算的watcehr，将这些watcher做为当前这个dep的subscribes订阅者收集起来</li>
<li>当我们计算属性的依赖值发生变化时，会触发computed watcher重新计算，当计算结果发生变化时，才会通知订阅这个computed变化的这些订阅者，触发他们的更新</li>
<li>对于watch而言，实际上会创建一个user watcher，去观测data、computed等属性的变化，当这些属性发生变化时，会通知dep去遍历所有的user watcher 调用他们的update方法，执行run方法去调用用户定义的回调函数</li>
<li>数据的渲染和重新渲染则是基于响应式系统，在Vue的创建过程中，他会执行每一个组件的mount方法，在mount过程中内部会会创建唯一的render watcher，当组件在执行render过程，也就是渲染成vnode的过程中，会访问到响应式数据，也就是render watcher作为订阅者，去订阅响应式数据，数据的变化会触发render watcher的run方法，在run方法中会执行updateComponent方法去执行重新渲染的过程。</li>
</ol>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h3><ul>
<li>在实例化过程中为每个data属性创建dep对象，并为每个属性定义get()和set()方法。</li>
<li>为每一个data属性创建watcher对象，首先将Dep.target设置为watcher（Dep为类），再调用其getter()方法，触发了get()方法里的dep.depend()，将watcher添加到dep对象的subs，（储存所有该data属性的watcher），再通过Dep.target，将当前dep添加到watcher中的deps（储存所有该data属性的dep）。总而言之就是建立了data，dep，watcher之间的依赖关系。</li>
<li>在数据发生变化时，会调用数据的set()方法，会触发notify()方法，将消息通知该data的dep对象，在dep对象中遍历所有的与dep绑定的watcher，触发他们的update()方法，来更新dom。<h3 id="virtual-dom-虚拟节点树"><a href="#virtual-dom-虚拟节点树" class="headerlink" title="virtual-dom 虚拟节点树"></a>virtual-dom 虚拟节点树</h3>用js实现一个节点树，在发生改变的时候，通过比较新的树和旧的树的变化，就可以记录下变化，然后应用到真实的dom树上，这样就不用重新渲染整个dom树了。<h4 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h4>用js对象来表示dom节点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个Element对象</span><br><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">    this.tagName &#x3D; tagName</span><br><span class="line">    this.props &#x3D; props</span><br><span class="line">    this.children &#x3D; children</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建一个ul实例</span><br><span class="line">var ul &#x3D; new Element(&#39;ul&#39;, &#123;id: &#39;list&#39;&#125;, [</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 1&quot;]&#125;,</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 2&quot;]&#125;,</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 3&quot;]&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
将JavaScript构建的DOM树渲染到真实的DOM树上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在Element中写上通用的方法</span><br><span class="line">Element.prototype.render &#x3D; function() &#123;</span><br><span class="line">    let el &#x3D; document.createElement(this.tagName), &#x2F;&#x2F; 节点名称</span><br><span class="line">        props &#x3D; this.props &#x2F;&#x2F; 节点属性</span><br><span class="line">    for (var propName in props) &#123;</span><br><span class="line">        propValue &#x3D; props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line">    this.children.forEach((child) &#x3D;&gt; &#123;</span><br><span class="line">        var childEl &#x3D; (child instanceof Element)</span><br><span class="line">            ? child.render()</span><br><span class="line">            : document.createTextNode(child)</span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
每一个vnode都映射到一个真实的dom节点上。其中几个比较重要的属性:</li>
<li>tag 属性即这个vnode的标签属性</li>
<li>data 属性包含了最后渲染成真实dom节点后，节点上的class,attribute,style以及绑定的事件</li>
<li>children 属性是vnode的子节点</li>
<li>text 属性是文本属性</li>
<li>elm 属性为这个vnode对应的真实dom节点</li>
<li>key 属性是vnode的标记，在diff过程中可以提高diff的效率，后文有讲解</li>
</ul>
<h4 id="比较虚拟DOM树的差异-diff算法"><a href="#比较虚拟DOM树的差异-diff算法" class="headerlink" title="比较虚拟DOM树的差异 diff算法"></a>比较虚拟DOM树的差异 diff算法</h4><h4 id="将差异应用到都dom树"><a href="#将差异应用到都dom树" class="headerlink" title="将差异应用到都dom树"></a>将差异应用到都dom树</h4>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/vue-router/</url>
    <content><![CDATA[<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="comment">// 混入 beforeCreate 钩子</span></span><br><span class="line">     Vue.mixin(&#123;</span><br><span class="line">       beforeCreate () &#123;</span><br><span class="line">         <span class="comment">// 在option上面存在router则代表是根组件 </span></span><br><span class="line">         <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</span><br><span class="line">           <span class="keyword">this</span>._routerRoot = <span class="keyword">this</span>  <span class="comment">// 定义router的根vm</span></span><br><span class="line">           <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">           <span class="comment">// 执行_router实例的 init 方法</span></span><br><span class="line">           <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</span><br><span class="line">           <span class="comment">// 为 vue 实例定义数据劫持</span></span><br><span class="line">           Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 非根组件则直接从父组件中获取</span></span><br><span class="line">           <span class="keyword">this</span>._routerRoot = (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._routerRoot) || <span class="keyword">this</span></span><br><span class="line">         &#125;</span><br><span class="line">         registerInstance(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       destroyed () &#123;</span><br><span class="line">         registerInstance(<span class="keyword">this</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router</span></span><br><span class="line">     <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;<span class="comment">//Router</span></span><br><span class="line">       <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="comment">// 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route</span></span><br><span class="line">     <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">       <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 注册 router-view 和 router-link 组件</span></span><br><span class="line">     Vue.component(<span class="string">'RouterView'</span>, View)</span><br><span class="line">     Vue.component(<span class="string">'RouterLink'</span>, Link)</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Vue钩子合并策略</span></span><br><span class="line">     <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">     <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">     strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>Vue.use(Router)</code> 调用 vue-router 的 install 方法</p>
<ul>
<li>在 beforeCreate 钩子函数中加入，将 router实例挂载到 vm 实例的 _router 上，并为每一个组件实例挂载 _routerRoot 属性，并渲染 router-view</li>
<li>对 _route 对象 做响应式处理</li>
<li>注册全局组件 router-view router-link,以及全属性 $router $route<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 执行 vm.$options._parentVnode.data.registerRouteInstance 渲染 router-view 组件</span></span><br><span class="line"> <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="keyword">if</span> (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>路由初始化是在组件的初始化阶段执行的，<br>this._routerRoot = 定义router的根vm（每一个组件都挂载）<br>this._router = 定义时new 出的router实例 （根vm才挂载）<br>执行混入的beforeCreate构造的时候，<br>会执行vm._router(根router实例).init(vm)，<br>然后根据history的模式执行history.transitionTo方法进行路由过渡</li>
</ul>
<h2 id="new-一个VueRouter实例"><a href="#new-一个VueRouter实例" class="headerlink" title="new 一个VueRouter实例"></a>new 一个VueRouter实例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">name</span>: <span class="string">'home'</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/bar/:id'</span>, <span class="attr">name</span>: <span class="string">'bar'</span>, <span class="attr">component</span>: Bar,</span><br><span class="line">      children:[</span><br><span class="line">        &#123;</span><br><span class="line">          path:<span class="string">':id'</span>,</span><br><span class="line">          name:<span class="string">'singerDetial'</span>,</span><br><span class="line">          component:singerDetial,</span><br><span class="line">        &#125;, &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="createMatcher"><a href="#createMatcher" class="headerlink" title="createMatcher"></a>createMatcher</h3><p>createMatcher 根据传入的 routes 属性 返回 match 和 addRoutes 方法</p>
<p><code>pathList, pathMap, nameMap</code> 就是 路径/name 和 RouteRecord 的对应关系，pathList 存储所有的 path</p>
<p>addRoutes：动态添加路由映射<br>match：ui匹配到路径，路径映射到路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> record: RouteRecord = &#123;</span><br><span class="line">  path: normalizedPath,</span><br><span class="line">  regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><br><span class="line">  components: route.components || &#123; <span class="attr">default</span>: route.component &#125;,</span><br><span class="line">  instances: &#123;&#125;,</span><br><span class="line">  name,</span><br><span class="line">  parent,</span><br><span class="line">  matchAs,</span><br><span class="line">  redirect: route.redirect,</span><br><span class="line">  beforeEnter: route.beforeEnter,</span><br><span class="line">  meta: route.meta || &#123;&#125;,</span><br><span class="line">  props:</span><br><span class="line">    route.props == <span class="literal">null</span></span><br><span class="line">      ? &#123;&#125;</span><br><span class="line">      : route.components</span><br><span class="line">        ? route.props</span><br><span class="line">        : &#123; <span class="attr">default</span>: route.props &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>路由始终会维护当前的线路，路由切换的时候会将当前线路切换到目标线路，切换过程中会：<br>执行一系列的导航钩子函数<br>更改URL<br>渲染对应的组件<br>切换完毕后会把目标线路更新替换成当前线路，这样就会作为下一次的线路切换的依据</p>
<h3 id="生成-history对象"><a href="#生成-history对象" class="headerlink" title="生成 history对象"></a>生成 history对象</h3><p>确定 mode，默认为 hashHistory，生成 history实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (router: Router, base: ?string) &#123;</span><br><span class="line">  <span class="keyword">this</span>.router = router</span><br><span class="line">  <span class="keyword">this</span>.base = normalizeBase(base)</span><br><span class="line">  <span class="comment">// start with a route object that stands for "nowhere"</span></span><br><span class="line">  <span class="keyword">this</span>.current = START</span><br><span class="line">  <span class="keyword">this</span>.pending = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.ready = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.readyCbs = []</span><br><span class="line">  <span class="keyword">this</span>.readyErrorCbs = []</span><br><span class="line">  <span class="keyword">this</span>.errorCbs = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="VueRouter-init-方法"><a href="#VueRouter-init-方法" class="headerlink" title="VueRouter init 方法"></a>VueRouter init 方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.apps.push(app)</span><br><span class="line">    <span class="keyword">this</span>.app = app</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> history = <span class="keyword">this</span>.history</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History) &#123;</span><br><span class="line">      history.transitionTo(history.getCurrentLocation())</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">      <span class="keyword">const</span> setupHashListener = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">      &#125;</span><br><span class="line">      history.transitionTo(</span><br><span class="line">        history.getCurrentLocation(),</span><br><span class="line">        setupHashListener,</span><br><span class="line">        setupHashListener</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回了当前路径</span></span><br><span class="line">    getCurrentLocation () &#123;</span><br><span class="line">    <span class="keyword">return</span> getHash()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getHash</span> (<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We can't use window.location.hash here because it's not</span></span><br><span class="line">  <span class="comment">// consistent across browsers - Firefox will pre-decode it!</span></span><br><span class="line">  <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> index = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  <span class="comment">// empty path</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  href = href.slice(index + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// decode the hash but not the search or hash</span></span><br><span class="line">  <span class="comment">// as search(query) is already decoded</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/2708</span></span><br><span class="line">  <span class="keyword">const</span> searchIndex = href.indexOf(<span class="string">'?'</span>)</span><br><span class="line">  <span class="keyword">if</span> (searchIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashIndex = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">    <span class="keyword">if</span> (hashIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      href = <span class="built_in">decodeURI</span>(href.slice(<span class="number">0</span>, hashIndex)) + href.slice(hashIndex)</span><br><span class="line">    &#125; <span class="keyword">else</span> href = <span class="built_in">decodeURI</span>(href)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (searchIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      href = <span class="built_in">decodeURI</span>(href.slice(<span class="number">0</span>, searchIndex)) + href.slice(searchIndex)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> href</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。</p>
<p>每一次改变<code>hash(window.location.hash)</code>，都会在浏览器访问历史中增加一个记录。</p>
<h3 id="treansitionTo"><a href="#treansitionTo" class="headerlink" title="treansitionTo"></a>treansitionTo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  transitionTo (</span><br><span class="line">    location: RawLocation,</span><br><span class="line">    onComplete?: <span class="built_in">Function</span>,</span><br><span class="line">    onAbort?: <span class="built_in">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//location 是 当前解析的url this.current</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="keyword">this</span>.router.match(location, <span class="keyword">this</span>.current) <span class="comment">//获得当前路由的 RouteRecord 对象 并通过 _createRoute方法 放回 router对象</span></span><br><span class="line">    <span class="keyword">this</span>.confirmTransition(</span><br><span class="line">      route,</span><br><span class="line">      () =&gt; &#123; <span class="comment">//confirmTransition 执行完毕后的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.updateRoute(route)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        <span class="keyword">this</span>.ensureURL()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fire ready cbs once</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.ready) &#123;</span><br><span class="line">          <span class="keyword">this</span>.ready = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">this</span>.readyCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb(route)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">          onAbort(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err &amp;&amp; !<span class="keyword">this</span>.ready) &#123;</span><br><span class="line">          <span class="keyword">this</span>.ready = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">this</span>.readyErrorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看到，到这里，已经完成了对当前 route 的更新动作。我们之前已经分析了，在 install函数中设置了对route的数据劫持。此时会触发页面的重新渲染过程。</span></span><br><span class="line"><span class="comment">// router-view 就是根据 this.route来渲染组件的</span></span><br><span class="line">  updateRoute (route: Route) &#123;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="keyword">this</span>.current</span><br><span class="line">    <span class="comment">// 当前路由更新</span></span><br><span class="line">    <span class="keyword">this</span>.current = route</span><br><span class="line">    <span class="comment">// cb 执行</span></span><br><span class="line">    <span class="keyword">this</span>.cb &amp;&amp; <span class="keyword">this</span>.cb(route)</span><br><span class="line">    <span class="comment">// 调用 afterEach 钩子</span></span><br><span class="line">    <span class="keyword">this</span>.router.afterHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//this.current的来源</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> START = createRoute(<span class="literal">null</span>, &#123;</span><br><span class="line">  path: <span class="string">'/'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.current = START</span><br><span class="line"></span><br><span class="line"><span class="comment">// _createRoute 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    record: ?RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">    location: Location,</span></span></span><br><span class="line"><span class="function"><span class="params">    redirectedFrom?: Location</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (record &amp;&amp; record.redirect) &#123;</span><br><span class="line">      <span class="keyword">return</span> redirect(record, redirectedFrom || location)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (record &amp;&amp; record.matchAs) &#123;</span><br><span class="line">      <span class="keyword">return</span> alias(record, location, record.matchAs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createRoute(record, location, redirectedFrom, router)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Route 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRoute</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  record: ?RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">  location: Location,</span></span></span><br><span class="line"><span class="function"><span class="params">  redirectedFrom?: ?Location,</span></span></span><br><span class="line"><span class="function"><span class="params">  router?: VueRouter</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stringifyQuery = router &amp;&amp; router.options.stringifyQuery</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> query: any = location.query || &#123;&#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    query = clone(query)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> route: Route = &#123;</span><br><span class="line">    name: location.name || (record &amp;&amp; record.name),</span><br><span class="line">    meta: (record &amp;&amp; record.meta) || &#123;&#125;,</span><br><span class="line">    path: location.path || <span class="string">'/'</span>,</span><br><span class="line">    hash: location.hash || <span class="string">''</span>,</span><br><span class="line">    query,</span><br><span class="line">    params: location.params || &#123;&#125;,</span><br><span class="line">    fullPath: getFullPath(location, stringifyQuery),</span><br><span class="line">    matched: record ? formatMatch(record) : []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (redirectedFrom) &#123;</span><br><span class="line">    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(route)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="confirmTransition"><a href="#confirmTransition" class="headerlink" title="confirmTransition"></a>confirmTransition</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  confirmTransition (route: Route, <span class="attr">onComplete</span>: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="keyword">this</span>.current</span><br><span class="line">    <span class="comment">// 定义中断处理</span></span><br><span class="line">    <span class="keyword">const</span> abort = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      onAbort &amp;&amp; onAbort(err)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 同路由且 matched.length 相同</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isSameRoute(route, current) &amp;&amp;</span><br><span class="line">      <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">      route.matched.length === current.matched.length</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ensureURL()</span><br><span class="line">      <span class="keyword">return</span> abort()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      updated,</span><br><span class="line">      deactivated,</span><br><span class="line">      activated</span><br><span class="line">    &#125; = resolveQueue(<span class="keyword">this</span>.current.matched, route.matched)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 整个切换周期的队列</span></span><br><span class="line">    <span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">      <span class="comment">// 得到即将被销毁组建的 beforeRouteLeave 钩子函数</span></span><br><span class="line">      extractLeaveGuards(deactivated),</span><br><span class="line">      <span class="comment">// 全局 router before hooks</span></span><br><span class="line">      <span class="keyword">this</span>.router.beforeHooks,</span><br><span class="line">      <span class="comment">// 得到组件 updated 钩子</span></span><br><span class="line">      extractUpdateHooks(updated),</span><br><span class="line">      <span class="comment">// 将要更新的路由的 beforeEnter 钩子</span></span><br><span class="line">      activated.map(<span class="function"><span class="params">m</span> =&gt;</span> m.beforeEnter),</span><br><span class="line">      <span class="comment">// 异步组件</span></span><br><span class="line">      resolveAsyncComponents(activated)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.pending = route</span><br><span class="line">    <span class="comment">// 每一个队列执行的 iterator 函数</span></span><br><span class="line">    <span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果当前处理的路由，已经不等于 route 则终止处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// hook 是queue 中的钩子函数，在这里执行</span></span><br><span class="line">    hook(route, current, (to: any) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 钩子函数外部执行的 next 方法</span></span><br><span class="line">      <span class="comment">// next(false): 中断当前的导航。</span></span><br><span class="line">      <span class="comment">// 如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)</span></span><br><span class="line">      <span class="comment">// 那么 URL 地址会重置到 from 路由对应的地址。</span></span><br><span class="line">      <span class="keyword">if</span> (to === <span class="literal">false</span> || isError(to)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(to)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// next('/') 或者 next(&#123; path: '/' &#125;): 跳转到一个不同的地址。</span></span><br><span class="line">        <span class="comment">// 当前的导航被中断，然后进行一个新的导航。</span></span><br><span class="line">        <span class="keyword">typeof</span> to === <span class="string">'string'</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> to === <span class="string">'object'</span> &amp;&amp; (</span><br><span class="line">          <span class="keyword">typeof</span> to.path === <span class="string">'string'</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> to.name === <span class="string">'string'</span></span><br><span class="line">        ))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// next('/') or next(&#123; path: '/' &#125;) -&gt; redirect</span></span><br><span class="line">        abort()</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">'object'</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">          <span class="keyword">this</span>.replace(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.push(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前钩子执行完成，移交给下一个钩子函数</span></span><br><span class="line">        <span class="comment">// 注意这里的 next 指的是 runQueue 中传过的执行队列下一个方法函数: step(index + 1)</span></span><br><span class="line">        next(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    abort(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行队列 leave 和 beforeEnter 相关钩子</span></span><br><span class="line">    runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">  <span class="keyword">const</span> isValid = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.current === route</span><br><span class="line">  <span class="comment">// 获取 beforeRouteEnter 钩子函数</span></span><br><span class="line">  <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">  <span class="comment">// 获取 beforeResolve 钩子函数 并合并生成另一个 queue</span></span><br><span class="line">  <span class="keyword">const</span> queue = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">  runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理完，就不需要再次执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="keyword">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 调用 onComplete 函数</span></span><br><span class="line">    onComplete(route)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">      <span class="comment">// nextTick 执行 postEnterCbs 所有回调</span></span><br><span class="line">      <span class="keyword">this</span>.router.app.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        postEnterCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123; cb() &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出 resolveQueue 就是交叉比对当前路由的路由记录和现在的这个路由的路由记录来确定出哪些组件需要更新，哪些需要激活，哪些组件被卸载。再执行其中的对应钩子函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolveQueue</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Array&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  next: Array&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  updated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  activated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="comment">// 取得最大深度</span></span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(current.length, next.length)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果记录不一样则停止</span></span><br><span class="line">    <span class="keyword">if</span> (current[i] !== next[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别返回哪些需要更新，哪些需要激活，哪些需要卸载</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    updated: next.slice(<span class="number">0</span>, i),</span><br><span class="line">    activated: next.slice(i),</span><br><span class="line">    deactivated: current.slice(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>监听事件 popState hashChange，该方法设置监听了浏览器事件hashchange,调用的函数为replaceHash,即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法。</p>
<p>在init时，先构建history.transtitionTo方法，再添加 监听事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(supportsPushState ? <span class="string">'popstate'</span> : <span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> current = <span class="keyword">this</span>.current</span><br><span class="line">  <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.transitionTo(getHash(), route =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">      handleScroll(<span class="keyword">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">      replaceHash(route.fullPath)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每当 window.location.hash 改变时就会触发 transitionTo方法</p>
<h3 id="push-replace-方法"><a href="#push-replace-方法" class="headerlink" title="push  replace 方法"></a>push  replace 方法</h3><p>transitionTo()方法是用来处理路由变化中的基础逻辑的，</p>
<p>push()方法最主要的是对window的hash进行了直接赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      route =&gt; &#123;</span><br><span class="line">        pushHash(route.fullPath)</span><br><span class="line">        handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHash</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    pushState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path  <span class="comment">//直接改变 hash</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      route =&gt; &#123;</span><br><span class="line">        replaceHash(route.fullPath)</span><br><span class="line">        handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Location.replace()方法以给定的URL来替换当前的资源。 与assign() 方法 不同的是调用replace()方法后，当前页面不会保存到会话历史中（session History），这样用户点击回退按钮将不会再跳转到该页面。</span></span><br><span class="line"></span><br><span class="line">  go (n: number) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="html5-history"><a href="#html5-history" class="headerlink" title="html5 history"></a>html5 history</h2><p>HTML5引入了history.pushState()和history.replaceState()方法，他们分别可以添加和修改历史记录条目。这些方法通常与 window.<strong>onpopstate</strong> 配合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(stateObject,title,url)</span><br><span class="line"><span class="built_in">window</span>.history,replaceState(stateObject,title,url)</span><br></pre></td></tr></table></figure>
<p>pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</p>
<p>比较</p>
<ul>
<li>pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url</li>
<li>pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>
<li>pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串</li>
<li>pushState可额外设置title属性供后续使用</li>
</ul>
<h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>主要用于生成一个dom，默认为 a 标签，通过 click 事件触发， to 表示要跳转的路由<br>跳转的处理交给 history 对象</p>
<p>触发的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.replace) &#123; <span class="comment">//会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</span></span><br><span class="line">      router.replace(location)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h2><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>beforeEach<br>beforeResolve<br>afterEach</p>
<h3 id="路由独享"><a href="#路由独享" class="headerlink" title="路由独享"></a>路由独享</h3><p>beforeEnter</p>
<h3 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">   <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">   <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line"> &#125;,</span><br><span class="line"> beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">   <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">   <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">   <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line"> &#125;,</span><br><span class="line"> beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">   <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 <strong>next</strong> 的回调函数。</li>
</ol>
<h2 id="触发路由"><a href="#触发路由" class="headerlink" title="触发路由"></a>触发路由</h2><ol>
<li>router-link 触发回调函数，拿到to的值，执行vue-router 的 push方法</li>
<li>执行 transitionTo 方法, 修改路由路径， vm._route </li>
<li>触发 _route 的数据响应，使 router-view 重新渲染</li>
<li>router-view 从 vm.$route.matched 表示路由路径上的全部 RouteRecord</li>
<li>根据组件的深度(是否有父 router-view)，获取当前 view-router 需要渲染的 组件，生成vnode并返回</li>
</ol>
<h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>window.location.hash</p>
<ol>
<li>点击事件改变当前url</li>
<li>通过hashChange事件来监听url的变化来更新组件</li>
</ol>
<h3 id="html5-history-1"><a href="#html5-history-1" class="headerlink" title="html5 history"></a>html5 history</h3><p>window.history</p>
<ol>
<li>点击事件触发回调，通过 pushState,replaceState 来改变url，并调用相应的更新</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>12.transition</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/12.transition/</url>
    <content><![CDATA[<h2 id="render函数-vnode"><a href="#render函数-vnode" class="headerlink" title="render函数 vnode"></a>render函数 vnode</h2><ol>
<li>transition组件使用同插槽一样，调用 transition 组件的render方法，通过 <code>this.$slots.default</code> 取得内部的vnode</li>
<li>在 vnode的data上 生成 transition对象，保存transition标签上的 props （例如 name），listeners等属性 <code>vnode.data.transition</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data: <span class="built_in">Object</span> = (child.data || (child.data = &#123;&#125;)).transition = extractTransitionData(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 transition组件 过渡动画所需的属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>   (<span class="params">comp: Component</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> options: ComponentOptions = comp.$options</span><br><span class="line">  <span class="comment">// props</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options.propsData) &#123;</span><br><span class="line">    data[key] = comp[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// events.</span></span><br><span class="line">  <span class="comment">// extract listeners and pass them directly to the transition methods</span></span><br><span class="line">  <span class="keyword">const</span> listeners: ?<span class="built_in">Object</span> = options._parentListeners</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> listeners) &#123;</span><br><span class="line">    data[camelize(key)] = listeners[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该方法在子组件上添加动画css名，这样 child.data.transition 中就包含了过渡所需的一些数据</p>
<blockquote>
<p>如果组件里面写了html语言（不是正常插槽的写法），那么会作为 _c的 children vnode 传入，最终vnode保存在 componentOptions.children，在 _init过程中 </p>
</blockquote>
<ul>
<li>合并component配置的过程中，<code>opts._renderChildren = vnodeComponentOptions.children;</code>，</li>
<li>initRender 将 opts._renderChildren 挂载到 vm.$slots.default 上<a id="more"></a>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2></li>
</ul>
<p>patch 过程中 执行 invokeCreateHooks ，来调用 vnode的 <strong>create</strong> 钩子函数 里的 _enter，所以会执行enter方法，来进行 进入动画的处理 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_enter</span> (<span class="params">_: any, vnode: VNodeWithData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode.data.show !== <span class="literal">true</span>) &#123;</span><br><span class="line">    enter(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> inBrowser ? &#123;</span><br><span class="line">  create: _enter,</span><br><span class="line">  activate: _enter,</span><br><span class="line">  remove (vnode: VNode, <span class="attr">rm</span>: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (vnode.data.show !== <span class="literal">true</span>) &#123;</span><br><span class="line">      leave(vnode, rm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rm()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; : &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>提供了3个钩子函数</p>
<h2 id="enter方法"><a href="#enter方法" class="headerlink" title="enter方法"></a>enter方法</h2><ol>
<li>从 vnode.data.transition 获取 name ，并生成css名</li>
<li>获取 css ,如果 已经显示的定义了这些属性就会覆盖默认的 class 名</li>
</ol>
<p>默认类名， 为 transition name + 后缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    enterClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-enter`</span>,</span><br><span class="line">    enterToClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-enter-to`</span>,</span><br><span class="line">    enterActiveClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-enter-active`</span>,</span><br><span class="line">    leaveClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-leave`</span>,</span><br><span class="line">    leaveToClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-leave-to`</span>,</span><br><span class="line">    leaveActiveClass: <span class="string">`<span class="subst">$&#123;name&#125;</span>-leave-active`</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>自定义类名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">    name=<span class="string">"custom-classes-transition"</span></span><br><span class="line">    enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"animated tada"</span></span><br><span class="line">    leave-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"animated bounceOutRight"</span></span><br><span class="line">  &gt;</span><br></pre></td></tr></table></figure>


<p>执行顺序</p>
<ol>
<li><p>执行 beforeEnterHook 钩子函数</p>
<ul>
<li>addClass (startClass,activeClass)</li>
<li>nextFrame <ul>
<li>removeClass(startCLass)</li>
<li>addClass (toClass)</li>
<li>如果 设置了 duration ，<code>setTimeout(cb, explicitEnterDuration)</code></li>
<li>否则 等待动画（transitionEndEvent 或 animationEndEvent）结束 <code>whenTransitionEnds(el, type, cb)</code>,执行回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>nextFrame调用回调函数 定义了 动画结束的回调函数 cb ,执行 afterEnterHook 钩子函数，并置 el._enterCb = null</p>
<ul>
<li>removeClass(activeClass,toClass)</li>
<li>afterEnterHook 钩子函数</li>
<li>el._enterCb = null</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> startClass = isAppear &amp;&amp; appearClass</span><br><span class="line">    ? appearClass</span><br><span class="line">    : enterClass</span><br><span class="line"><span class="keyword">const</span> activeClass = isAppear &amp;&amp; appearActiveClass</span><br><span class="line">  ? appearActiveClass</span><br><span class="line">  : enterActiveClass</span><br><span class="line"><span class="keyword">const</span> toClass = isAppear &amp;&amp; appearToClass</span><br><span class="line">  ? appearToClass</span><br><span class="line">  : enterToClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beforeEnterHook = isAppear</span><br><span class="line">  ? (beforeAppear || beforeEnter)</span><br><span class="line">  : beforeEnter</span><br><span class="line"><span class="keyword">const</span> enterHook = isAppear</span><br><span class="line">  ? (<span class="keyword">typeof</span> appear === <span class="string">'function'</span> ? appear : enter)</span><br><span class="line">  : enter</span><br><span class="line"><span class="keyword">const</span> afterEnterHook = isAppear</span><br><span class="line">  ? (afterAppear || afterEnter)</span><br><span class="line">  : afterEnter</span><br><span class="line"><span class="keyword">const</span> enterCancelledHook = isAppear</span><br><span class="line">  ? (appearCancelled || enterCancelled)</span><br><span class="line">  : enterCancelled</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> explicitEnterDuration: any = toNumber(</span><br><span class="line">  isObject(duration)</span><br><span class="line">    ? duration.enter</span><br><span class="line">    : duration</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; explicitEnterDuration != <span class="literal">null</span>) &#123;</span><br><span class="line">  checkDuration(explicitEnterDuration, <span class="string">'enter'</span>, vnode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expectsCSS = css !== <span class="literal">false</span> &amp;&amp; !isIE9</span><br><span class="line"><span class="keyword">const</span> userWantsControl = getHookArgumentsLength(enterHook)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  el = vnode.elm</span><br><span class="line">  <span class="keyword">const</span> cb = el._enterCb = once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">      removeTransitionClass(el, toClass)</span><br><span class="line">      removeTransitionClass(el, activeClass)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb.cancelled) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">        removeTransitionClass(el, startClass)</span><br><span class="line">      &#125;</span><br><span class="line">      enterCancelledHook &amp;&amp; enterCancelledHook(el)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      afterEnterHook &amp;&amp; afterEnterHook(el)</span><br><span class="line">    &#125;</span><br><span class="line">    el._enterCb = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beforeEnterHook &amp;&amp; beforeEnterHook(el)</span><br><span class="line">  <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">    addTransitionClass(el, startClass)</span><br><span class="line">    addTransitionClass(el, activeClass)</span><br><span class="line">    nextFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      removeTransitionClass(el, startClass)</span><br><span class="line">      <span class="keyword">if</span> (!cb.cancelled) &#123;</span><br><span class="line">        addTransitionClass(el, toClass)</span><br><span class="line">        <span class="keyword">if</span> (!userWantsControl) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isValidDuration(explicitEnterDuration)) &#123;</span><br><span class="line">            setTimeout(cb, explicitEnterDuration)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            whenTransitionEnds(el, type, cb) <span class="comment">//添加 事件 transitionEndEvent 或 animationEndEvent</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> raf = inBrowser</span><br><span class="line">  ? <span class="built_in">window</span>.requestAnimationFrame</span><br><span class="line">    ? <span class="built_in">window</span>.requestAnimationFrame.bind(<span class="built_in">window</span>)</span><br><span class="line">    : setTimeout</span><br><span class="line">  : <span class="function"><span class="params">fn</span> =&gt;</span> fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextFrame</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">  raf(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    raf(fn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//whenTransitionEnds</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenTransitionEnds</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  expectedType: ?string,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, timeout, propCount &#125; = getTransitionInfo(el, expectedType)</span><br><span class="line">  <span class="keyword">if</span> (!type) <span class="keyword">return</span> cb()</span><br><span class="line">  <span class="keyword">const</span> event: string = type === TRANSITION ? transitionEndEvent : animationEndEvent</span><br><span class="line">  <span class="keyword">let</span> ended = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> end = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    el.removeEventListener(event, onEnd)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> onEnd = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.target === el) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++ended &gt;= propCount) &#123;</span><br><span class="line">        end()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ended &lt; propCount) &#123;</span><br><span class="line">      end()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, timeout + <span class="number">1</span>)</span><br><span class="line">  el.addEventListener(event, onEnd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于过渡类名方面，startClass 定义进入过渡的开始状态，在元素被插入时生效，在下一个帧移除；activeClass 定义过渡的状态，在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除；toClass 定义进入过渡的结束状态，在元素被插入一帧后生效 (与此同时 startClass 被删除)，在 <code>&lt;transition&gt;/animation</code> 完成之后移除。</p>
<p>对于过渡钩子函数方面，beforeEnterHook 是过渡开始前执行的钩子函数，enterHook 是在元素插入后或者是 v-show 显示切换后执行的钩子函数。afterEnterHook 是在过渡动画执行完后的钩子函数。</p>
<p>explicitEnterDuration 表示 enter 动画执行的时间。</p>
<p>expectsCSS 表示过渡动画是受 CSS 的影响。</p>
<p>cb 定义的是过渡完成执行的回调函数。</p>
<ol start="3">
<li>vnode添加 insert =&gt; enterHook钩子函数，在patch过程中 invokeInsertHook时，来执行 enter 钩子函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enterHook = isAppear</span><br><span class="line">    ? (<span class="keyword">typeof</span> appear === <span class="string">'function'</span> ? appear : enter)</span><br><span class="line">    : enter</span><br><span class="line">    </span><br><span class="line">mergeVNodeHook(vnode, <span class="string">'insert'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = el.parentNode</span><br><span class="line">      <span class="keyword">const</span> pendingNode = parent &amp;&amp; parent._pending &amp;&amp; parent._pending[vnode.key]</span><br><span class="line">      <span class="keyword">if</span> (pendingNode &amp;&amp;</span><br><span class="line">        pendingNode.tag === vnode.tag &amp;&amp;</span><br><span class="line">        pendingNode.elm._leaveCb</span><br><span class="line">      ) &#123;</span><br><span class="line">        pendingNode.elm._leaveCb()</span><br><span class="line">      &#125;</span><br><span class="line">      enterHook &amp;&amp; enterHook(el, cb)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
enterHook 就是用户自定义的钩子函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   done()</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
第二个参数 done 就是 动画执行结束的回调函数 cb</li>
</ol>
<blockquote>
<p>vue 管理动画类名，而不是直接产生动哈</p>
</blockquote>
<h2 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h2><p>在删除节点时，调用 removeAndInvokeRemoveHook <strong>remove</strong> 钩子，就会执行 transition组件的leave(vnode, rm) 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  css,</span><br><span class="line">  type,</span><br><span class="line">  leaveClass,</span><br><span class="line">  leaveToClass,</span><br><span class="line">  leaveActiveClass,</span><br><span class="line">  beforeLeave,</span><br><span class="line">  leave,</span><br><span class="line">  afterLeave,</span><br><span class="line">  leaveCancelled,</span><br><span class="line">  delayLeave,</span><br><span class="line">  duration</span><br><span class="line">&#125; = data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cb = el._leaveCb = once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (el.parentNode &amp;&amp; el.parentNode._pending) &#123;</span><br><span class="line">    el.parentNode._pending[vnode.key] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">    removeTransitionClass(el, leaveToClass)</span><br><span class="line">    removeTransitionClass(el, leaveActiveClass)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cb.cancelled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">      removeTransitionClass(el, leaveClass)</span><br><span class="line">    &#125;</span><br><span class="line">    leaveCancelled &amp;&amp; leaveCancelled(el)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rm()</span><br><span class="line">    afterLeave &amp;&amp; afterLeave(el)</span><br><span class="line">  &#125;</span><br><span class="line">  el._leaveCb = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果进入动画还没结束，则调用  <code>el._enterCb.cancelled = true el._enterCb()</code>来取消动画</p>
<ol>
<li><p>执行 performLeave方法，</p>
<ul>
<li>beforeLeave 钩子函数</li>
<li>添加class addClass(leaveClass,leaveActiveClass)</li>
<li>nextFrame<ul>
<li>移除 leaveClass</li>
<li>addClass(leaveToClass);</li>
<li>等待动画执行结束 ，执行 结束回调函数</li>
</ul>
</li>
<li>执行 leave 钩子<ul>
<li>removeClass(leaveToClass,leaveActiveClass)</li>
<li>afterLeave 钩子函数</li>
<li>el._leaveCb = null<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performLeave</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// the delayed leave may have already been cancelled</span></span><br><span class="line">      <span class="keyword">if</span> (cb.cancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// record leaving element</span></span><br><span class="line">      <span class="keyword">if</span> (!vnode.data.show &amp;&amp; el.parentNode) &#123;</span><br><span class="line">        (el.parentNode._pending || (el.parentNode._pending = &#123;&#125;))[(vnode.key)] = vnode;</span><br><span class="line">      &#125;</span><br><span class="line">      beforeLeave &amp;&amp; beforeLeave(el);</span><br><span class="line">      <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">        addTransitionClass(el, leaveClass);</span><br><span class="line">        addTransitionClass(el, leaveActiveClass);</span><br><span class="line">        nextFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          removeTransitionClass(el, leaveClass);</span><br><span class="line">          <span class="keyword">if</span> (!cb.cancelled) &#123;</span><br><span class="line">            addTransitionClass(el, leaveToClass);</span><br><span class="line">            <span class="keyword">if</span> (!userWantsControl) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isValidDuration(explicitLeaveDuration)) &#123;</span><br><span class="line">                setTimeout(cb, explicitLeaveDuration);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                whenTransitionEnds(el, type, cb);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      leave &amp;&amp; leave(el, cb); <span class="comment">// 自定义 leave方法</span></span><br><span class="line">      <span class="keyword">if</span> (!expectsCSS &amp;&amp; !userWantsControl) &#123;</span><br><span class="line">        cb();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>回调函数定义</p>
<ul>
<li><p>移除class (leaveToClass,leaveActiveClass)</p>
</li>
<li><p>afterLeave 钩子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cb = el._leaveCb = once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (el.parentNode &amp;&amp; el.parentNode._pending) &#123;</span><br><span class="line">        el.parentNode._pending[vnode.key] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">        removeTransitionClass(el, leaveToClass);</span><br><span class="line">        removeTransitionClass(el, leaveActiveClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cb.cancelled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectsCSS) &#123;</span><br><span class="line">          removeTransitionClass(el, leaveClass);</span><br><span class="line">        &#125;</span><br><span class="line">        leaveCancelled &amp;&amp; leaveCancelled(el);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rm();</span><br><span class="line">        afterLeave &amp;&amp; afterLeave(el);</span><br><span class="line">      &#125;</span><br><span class="line">      el._leaveCb = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="nextFrame"><a href="#nextFrame" class="headerlink" title="nextFrame"></a>nextFrame</h2><p>是 requestAnimationFrame 的简单实现</p>
<p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，通过这个api,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。</p>
<p>vue使用 nextFrame 是为了让 dom先添加上 enter-active class ，再添加 enter-to class,避免动画直接到末尾</p>
<h2 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h2><p>transition-group 组件 在调用beforeMount钩子函数时，修改 _update 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeMount () &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">const</span> update = <span class="keyword">this</span>._update</span><br><span class="line">    <span class="keyword">this</span>._update = <span class="function">(<span class="params">vnode, hydrating</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// force removing pass</span></span><br><span class="line">      <span class="keyword">this</span>.__patch__(</span><br><span class="line">        <span class="keyword">this</span>._vnode,</span><br><span class="line">        <span class="keyword">this</span>.kept, <span class="comment">//新旧都存在的vnode</span></span><br><span class="line">        <span class="literal">false</span>, <span class="comment">// hydrating</span></span><br><span class="line">        <span class="literal">true</span> <span class="comment">// removeOnly (!important, avoids unnecessary moves)</span></span><br><span class="line">      )<span class="comment">//将两次都存在的列表项进行patch，先删除需要删除的节点</span></span><br><span class="line">      <span class="keyword">this</span>._vnode = <span class="keyword">this</span>.kept</span><br><span class="line">      restoreActiveInstance()</span><br><span class="line">      update.call(<span class="keyword">this</span>, vnode, hydrating) <span class="comment">// 插入的节点 各个表项移动到 最终的位置，保证被移动的节点依旧在原来相对的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>transition-group作为一个组件 patch过程中 调用 createComponent方法生成vue实例，再调用mount方法生产vnode，其中调用了其render方法</p>
<ul>
<li>获取 tag 类型   this.$vnode.data.tag</li>
<li>map对象保存当前表项 {key:vnode}</li>
<li>prevChildren 上一次表项</li>
<li>children 本次表项 <code>[vnode]</code></li>
<li>rawChildren 插槽的子vnode数组 this.$slots.default</li>
<li>c.data.transitionData 类名 = extractTransitionData(this)</li>
</ul>
<p><code>(c.data || (c.data = {})).transition = transitionData</code><br>为每个子节点添加 transition属性，为了能在 enter 方法中识别到该vnode要进行动画渲染</p>
<ul>
<li>比较新旧 vnode 列表<ul>
<li>相同的 加入到 kept数组</li>
<li>不同的，需要从旧列表中移除的 加入到 remove数组</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.kept = h(tag, <span class="literal">null</span>, kept)</span><br><span class="line"><span class="keyword">this</span>.removed = removec</span><br></pre></td></tr></table></figure>

<ul>
<li>return 生成 vnode  <code>h(tag, null, children)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">render (h: <span class="built_in">Function</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> tag: string = <span class="keyword">this</span>.tag || <span class="keyword">this</span>.$vnode.data.tag || <span class="string">'span'</span></span><br><span class="line">    <span class="keyword">const</span> map: <span class="built_in">Object</span> = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> prevChildren: <span class="built_in">Array</span>&lt;VNode&gt; = <span class="keyword">this</span>.prevChildren = <span class="keyword">this</span>.children</span><br><span class="line">    <span class="keyword">const</span> rawChildren: <span class="built_in">Array</span>&lt;VNode&gt; = <span class="keyword">this</span>.$slots.default || []</span><br><span class="line">    <span class="keyword">const</span> children: <span class="built_in">Array</span>&lt;VNode&gt; = <span class="keyword">this</span>.children = []</span><br><span class="line">    <span class="keyword">const</span> transitionData: <span class="built_in">Object</span> = extractTransitionData(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rawChildren.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> c: VNode = rawChildren[i]</span><br><span class="line">      <span class="keyword">if</span> (c.tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.key != <span class="literal">null</span> &amp;&amp; <span class="built_in">String</span>(c.key).indexOf(<span class="string">'__vlist'</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">          children.push(c)</span><br><span class="line">          map[c.key] = c</span><br><span class="line">          ;(c.data || (c.data = &#123;&#125;)).transition = transitionData</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> opts: ?VNodeComponentOptions = c.componentOptions</span><br><span class="line">          <span class="keyword">const</span> name: string = opts ? (opts.Ctor.options.name || opts.tag || <span class="string">''</span>) : c.tag</span><br><span class="line">          warn(<span class="string">`&lt;transition-group&gt; children must be keyed: &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevChildren) &#123;</span><br><span class="line">      <span class="keyword">const</span> kept: <span class="built_in">Array</span>&lt;VNode&gt; = []</span><br><span class="line">      <span class="keyword">const</span> removed: <span class="built_in">Array</span>&lt;VNode&gt; = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevChildren.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c: VNode = prevChildren[i]</span><br><span class="line">        c.data.transition = transitionData</span><br><span class="line">        c.data.pos = c.elm.getBoundingClientRect() <span class="comment">// 位置坐标</span></span><br><span class="line">        <span class="keyword">if</span> (map[c.key]) &#123;</span><br><span class="line">          kept.push(c)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          removed.push(c)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.kept = h(tag, <span class="literal">null</span>, kept)</span><br><span class="line">      <span class="keyword">this</span>.removed = removed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h(tag, <span class="literal">null</span>, children)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = <span class="keyword">this</span>._update</span><br><span class="line"><span class="keyword">this</span>._update = <span class="function">(<span class="params">vnode, hydrating</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// force removing pass</span></span><br><span class="line">      <span class="keyword">this</span>.__patch__(</span><br><span class="line">        <span class="keyword">this</span>._vnode,</span><br><span class="line">        <span class="keyword">this</span>.kept,</span><br><span class="line">        <span class="literal">false</span>, <span class="comment">// hydrating</span></span><br><span class="line">        <span class="literal">true</span> <span class="comment">// removeOnly (!important, avoids unnecessary moves)</span></span><br><span class="line">      )<span class="comment">//将两次都存在的列表项进行patch，先删除需要删除的节点</span></span><br><span class="line">      <span class="keyword">this</span>._vnode = <span class="keyword">this</span>.kept</span><br><span class="line">      restoreActiveInstance()</span><br><span class="line">      update.call(<span class="keyword">this</span>, vnode, hydrating) <span class="comment">// 插入的节点 各个表项移动到 最终的位置，保证被移动的节点依旧在原来相对的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行destory 钩子函数，也就是执行了 transition的 leave方法，为每一个子节点添加动画css，这一部分和 transition相同</p>
<p>执行 create 钩子函数，也就是执行了 transiotion 的 enter方法，为每一个子节点添加动画css，这一部分和 transition相同</p>
<blockquote>
<p>与 transition 不同的是 transition-group会生成一个dom节点，包裹住内部的列表，而transition是一个虚结点。</p>
</blockquote>
<h3 id="添加表项"><a href="#添加表项" class="headerlink" title="添加表项"></a>添加表项</h3><ul>
<li>生成新的vnode，进行patch，在比较新旧节点的过程中，调用了 prePatch ，再调用 updateChildComponent,其中比较重要的步骤 （和keep-alive相同）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$options._renderChildren = renderChildren;  <span class="comment">//替换成新的 插槽内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsForceUpdate) &#123;</span><br><span class="line">      vm.$slots = resolveSlots(renderChildren, parentVnode.context); <span class="comment">//更新 vm.$slots </span></span><br><span class="line">      vm.$forceUpdate(); <span class="comment">//重新渲染 &lt;transition-group&gt;实例</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用 transition-group 的 render函数，通过this.$slots.default拿到新的插槽内容，更新 c，kept，remove</p>
</li>
<li><p>执行 transiton-group 实例的 _update</p>
<ul>
<li>kept 和 旧节点 个数相同， 执行patch无变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>._update = <span class="function">(<span class="params">vnode, hydrating</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// force removing pass</span></span><br><span class="line">      <span class="keyword">this</span>.__patch__(</span><br><span class="line">        <span class="keyword">this</span>._vnode,</span><br><span class="line">        <span class="keyword">this</span>.kept,</span><br><span class="line">        <span class="literal">false</span>, <span class="comment">// hydrating</span></span><br><span class="line">        <span class="literal">true</span> <span class="comment">// removeOnly (!important, avoids unnecessary moves)</span></span><br><span class="line">      )<span class="comment">//将两次都存在的列表项进行patch，先删除需要删除的节点</span></span><br><span class="line">      <span class="keyword">this</span>._vnode = <span class="keyword">this</span>.kept <span class="comment">// 修改 transition-group 实例的 渲染vnode</span></span><br><span class="line">      restoreActiveInstance()</span><br><span class="line">      update.call(<span class="keyword">this</span>, vnode, hydrating) <span class="comment">// 插入的节点 各个表项移动到 最终的位置，保证被移动的节点依旧在原来相对的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>其中比较重要的： <code>this._vnode = this.kept</code></p>
<ul>
<li>再次调用 <strong>原生 _update</strong>,渲染新的 dom，以及他们的动画 (按 transition 处理)</li>
</ul>
<ul>
<li>在 更新watcher队列 执行完后会调用 <strong>transition-group 的 updated 钩子 函数</strong>，主要实现了 其他表项的移动动画<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = queue.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> watcher = queue[i];</span><br><span class="line">      <span class="keyword">var</span> vm = watcher.vm;</span><br><span class="line">      <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'updated'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm, hook</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">    pushTarget();</span><br><span class="line">    <span class="keyword">var</span> handlers = vm.$options[hook];</span><br><span class="line">    <span class="keyword">var</span> info = hook + <span class="string">" hook"</span>;</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">        invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">      vm.$emit(<span class="string">'hook:'</span> + hook);</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transition-group update</span></span><br><span class="line">    updated () &#123;  <span class="comment">//其他列表项的缓动动画 </span></span><br><span class="line">     <span class="keyword">const</span> children: <span class="built_in">Array</span>&lt;VNode&gt; = <span class="keyword">this</span>.prevChildren</span><br><span class="line">    <span class="keyword">const</span> moveClass: string = <span class="keyword">this</span>.moveClass || ((<span class="keyword">this</span>.name || <span class="string">'v'</span>) + <span class="string">'-move'</span>)</span><br><span class="line">    <span class="keyword">if</span> (!children.length || !<span class="keyword">this</span>.hasMove(children[<span class="number">0</span>].elm, moveClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we divide the work into three loops to avoid mixing DOM reads and writes</span></span><br><span class="line">    <span class="comment">// in each iteration - which helps prevent layout thrashing.</span></span><br><span class="line">    children.forEach(callPendingCbs)</span><br><span class="line">    children.forEach(recordPosition)</span><br><span class="line">    children.forEach(applyTranslation)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// force reflow to put everything in position</span></span><br><span class="line">    <span class="comment">// assign to this to avoid being removed in tree-shaking</span></span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="keyword">this</span>._reflow = <span class="built_in">document</span>.body.offsetHeight <span class="comment">// ！！触发浏览器重绘</span></span><br><span class="line"></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">c: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.data.moved) &#123;</span><br><span class="line">        <span class="keyword">const</span> el: any = c.elm</span><br><span class="line">        <span class="keyword">const</span> s: any = el.style</span><br><span class="line">        addTransitionClass(el, moveClass)</span><br><span class="line">        s.transform = s.WebkitTransform = s.transitionDuration = <span class="string">''</span> <span class="comment">// 移掉 transform</span></span><br><span class="line">        el.addEventListener(transitionEndEvent, el._moveCb = <span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (e &amp;&amp; e.target !== el) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!e || <span class="regexp">/transform$/</span>.test(e.propertyName)) &#123;</span><br><span class="line">            el.removeEventListener(transitionEndEvent, cb)</span><br><span class="line">            el._moveCb = <span class="literal">null</span></span><br><span class="line">            removeTransitionClass(el, moveClass)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="v-move"><a href="#v-move" class="headerlink" title="v-move"></a>v-move</h3><p>主要是为了 生成其他表项的移动动画，</p>
<p>####hasMove<br>hasMove 的判断，首先克隆一个 DOM 节点，然后为了避免影响，移除它的所有其他的过渡 Class；接着添加了 moveClass 样式，设置 display 为 none，添加到组件根节点上；</p>
<p>首先会判断是否设置了 move相关属性，再判断move相关属性的css是否涉及到了 动画的css属性</p>
<p>为每一个子节点,防止连续多次点击，让前一个动画 结束</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callPendingCbs</span> (<span class="params">c: VNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (c.elm._moveCb) &#123;</span><br><span class="line">    c.elm._moveCb()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (c.elm._enterCb) &#123;</span><br><span class="line">    c.elm._enterCb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录新的el 位置坐标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recordPosition</span> (<span class="params">c: VNode</span>) </span>&#123;</span><br><span class="line">  c.data.newPos = c.elm.getBoundingClientRect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据新旧位置的距离，来设置动画，先将每一个表项移动到之前的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyTranslation</span> (<span class="params">c: VNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldPos = c.data.pos</span><br><span class="line">  <span class="keyword">const</span> newPos = c.data.newPos</span><br><span class="line">  <span class="keyword">const</span> dx = oldPos.left - newPos.left</span><br><span class="line">  <span class="keyword">const</span> dy = oldPos.top - newPos.top</span><br><span class="line">  <span class="keyword">if</span> (dx || dy) &#123;</span><br><span class="line">    c.data.moved = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> s = c.elm.style</span><br><span class="line">    s.transform = s.WebkitTransform = <span class="string">`translate(<span class="subst">$&#123;dx&#125;</span>px,<span class="subst">$&#123;dy&#125;</span>px)`</span></span><br><span class="line">    s.transitionDuration = <span class="string">'0s'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>._reflow = <span class="built_in">document</span>.body.offsetHeight; <span class="comment">// 触发浏览器回流重绘 防止 在 tree-shaking的时候被删除</span></span><br><span class="line"></span><br><span class="line">children.forEach(<span class="function">(<span class="params">c: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.data.moved) &#123;</span><br><span class="line">        <span class="keyword">const</span> el: any = c.elm</span><br><span class="line">        <span class="keyword">const</span> s: any = el.style</span><br><span class="line">        addTransitionClass(el, moveClass) <span class="comment">// 设置 move 的 css 动画效果</span></span><br><span class="line">        s.transform = s.WebkitTransform = s.transitionDuration = <span class="string">''</span> <span class="comment">// 移掉 transform</span></span><br><span class="line">        el.addEventListener(transitionEndEvent, el._moveCb = <span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (e &amp;&amp; e.target !== el) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!e || <span class="regexp">/transform$/</span>.test(e.propertyName)) &#123;</span><br><span class="line">            el.removeEventListener(transitionEndEvent, cb)</span><br><span class="line">            el._moveCb = <span class="literal">null</span></span><br><span class="line">            removeTransitionClass(el, moveClass)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="删除表项"><a href="#删除表项" class="headerlink" title="删除表项"></a>删除表项</h2><p>在 update过程中 ， kept和旧的表项不相同，在执行 <code>__patch__</code> 的过程中，先删除要删除的点，再次调用 _update</p>
<h3 id="第一次patch-移除节点-第二次-update-添加和移动节点"><a href="#第一次patch-移除节点-第二次-update-添加和移动节点" class="headerlink" title="第一次patch 移除节点 第二次 _update 添加和移动节点"></a>第一次patch 移除节点 第二次 _update 添加和移动节点</h3><p>这样删除的节点就会在原来的位置开始移除动画，添加的节点也是</p>
<p>如果直接 进行 _update操作，那么在patch的过程中 不能保证表项中每一个的相对位置保存不变</p>
<p>比如 在头部插入一项并且尾部删除一项,最后生产的列表如下，第一个项被移动到了最后一个，在为其添加move动画时，他是相对原来在第一个的位置进行移动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="keyword">this</span>.prevChildren;</span><br><span class="line"></span><br><span class="line">c.data.newPos = c.elm.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldPos = c.data.pos;</span><br><span class="line"><span class="keyword">var</span> newPos = c.data.newPos;  </span><br><span class="line"><span class="keyword">var</span> dx = oldPos.left - newPos.left;</span><br><span class="line"><span class="keyword">var</span> dy = oldPos.top - newPos.top;</span><br></pre></td></tr></table></figure>
<p>如果仅通过一次patch，第一个位置的 1 被移动到了 最后一个，那么在添加move动画时，1是相对与第一个位置进行移动到最后一个位置。  </p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] =&gt; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>] <span class="comment">//在进行到需要删除1时，1在最后一位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分两次patch</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] =&gt; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] =&gt; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>正常情况</p>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/app_nor.gif" alt="正常情况"></p>
<p>不正常情况</p>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/app_un.gif" alt="不正常情况"></p>
<p>调用 remove 钩子函数，和 transition相同</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>transition-group 在渲染时调用 $mount前，会先执行 自定义的beforeUpdate钩子函数，修改了当前实例的 _update 方法，重新render生成vnode再update（先执行自定义的_update方法做第一次patch，再执行原生update 做第二次patch 进行渲染生成移入 移出 动画）。在渲染完毕后，会执行 自定义的 updated 钩子函数，进行其他表项移动动画的生成</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>11.keep-alive</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/11.keep-alive/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>keep-alive组件是一个抽象组件，它的实现通过自定义render函数并且利用了插槽，并且知道了 keep-alive 缓存 vnode，了解组件包裹的子元素——也就是插槽是如何做更新的。且在 patch 过程中对于已缓存的组件不会执行 mounted，所以不会有一般的组件的生命周期函数但是又提供了activated 和 deactivated 钩子函数。另外我们还知道了keep-alive的 props 除了 include 和 exclude 还有文档中没有提到的 max，它能控制我们缓存的个数。</p>
<a id="more"></a>
<h2 id="keep-alive-组件"><a href="#keep-alive-组件" class="headerlink" title="keep-alive 组件"></a>keep-alive 组件</h2><p>它的 props 定义了 include，exclude，它们可以字符串或者表达式，include 表示只有匹配的组件会被缓存，而 exclude 表示任何匹配的组件都不会被缓存，props 还定义了 max，它表示缓存的大小，</p>
<p>它有一个属性 abstract 为 true，是一个抽象组件，实际上它在组件实例建立父子关系的时候会被忽略</p>
<h2 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h2><h3 id="render-生成-vnode-时"><a href="#render-生成-vnode-时" class="headerlink" title="render 生成 vnode 时"></a>render 生成 vnode 时</h3><p>由于keep-alive是一个组件，所以会在Vue上查找全局组件的 构造函数。（一个已经写好的keep-alive组件 ）</p>
<blockquote>
<p>keep-alive 组件 在初始化Vue的时候就会挂载到Vue的原型上</p>
</blockquote>
<p>接着生成 keep-alive vnode</p>
<p>keep-alive 的使用 用到了插槽，其中的组件 在编译过程中 不会作为插槽来处理，而是直接调用 createElement方法传入组件名 来生成vnode，作为 <code>&lt;keep-alive&gt;</code> 的子节点vnode来使用。</p>
<p>而一般的插槽其中 定义的 <code>&lt;template&gt;</code> 会生成对应的 render函数，保存在 父节点的 sloScopes字段上，在子节点渲染的过程中，通过调用相应的render函数来生成vnode</p>
<p>在生产vnode的过程中，keep-alive 插槽内容 的节点保存在 <code>vnode.componentOptions.children</code></p>
<p><code>vm.$options._renderChildren = vnodeComponentOptions.children</code></p>
<p><code>&lt;component :is=&quot;tab[right_tab]&quot;&gt;&lt;/component&gt;</code> 其中需要用到的组件信息都保存在 vm.$options.components 中</p>
<h3 id="patch-渲染出真实dom-default插槽的渲染过程"><a href="#patch-渲染出真实dom-default插槽的渲染过程" class="headerlink" title="patch 渲染出真实dom (default插槽的渲染过程)"></a>patch 渲染出真实dom (default插槽的渲染过程)</h3><p>在调用子组件的 Vue构造函数时，initRender会将 keep-alive 的子vnode（_renderChildren）挂载到 $slots上<br>vm.$slots = resolveSlots(options._renderChildren, renderContext);</p>
<p>$mount -&gt; new Watcher -&gt; watcher.get() -&gt; _update(_render()) -&gt; vm.$options.render()  (keep-alive 自定义的render函数，所以不需要编译出render函数)</p>
<p>vm.$options.render 是合并了 vm 构造函数上的 keeep-alive options</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  render: <span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slot = <span class="keyword">this</span>.$slots.default;</span><br><span class="line">    <span class="keyword">var</span> vnode = getFirstComponentChild(slot);</span><br><span class="line">    <span class="keyword">var</span> componentOptions = vnode &amp;&amp; vnode.componentOptions;</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">var</span> name = getComponentName(componentOptions);</span><br><span class="line">      <span class="keyword">var</span> ref = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> include = ref.include;</span><br><span class="line">      <span class="keyword">var</span> exclude = ref.exclude;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ref$<span class="number">1</span> = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> cache = ref$<span class="number">1.</span>cache;</span><br><span class="line">      <span class="keyword">var</span> keys = ref$<span class="number">1.</span>keys;</span><br><span class="line">      <span class="keyword">var</span> key = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? (<span class="string">"::"</span> + (componentOptions.tag)) : <span class="string">''</span>)</span><br><span class="line">        : vnode.key;</span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key);</span><br><span class="line">        keys.push(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode;</span><br><span class="line">        keys.push(key);</span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用 keep-alive 的 render函数</p>
<ol>
<li>首先从 vm.$slots 中拿到 default 默认插槽的vnode</li>
<li>判断是否缓存</li>
</ol>
<p>keep-alive vm实例 有两个属性用于缓存</p>
<ul>
<li>catch {} 保存 对应的vnode</li>
<li>keys [] ,保存对应的 vnode的key，用于判断 最后使用节点</li>
</ul>
<p>如果 该vnode未被缓存，缓存该vnode，返回vnode<br>如果 已经缓存，则 将 vnode.componentInstance 改为 已缓存vnode的componentInstance，并返回 新的 vnode</p>
<ol start="3">
<li>接着 插槽内容进行渲染，由于已经存在vnode.componentsInstace ,所以不需要再生成一个新的 vm 实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cache[key] = vnode;</span><br><span class="line">keys.push(key);</span><br><span class="line"></span><br><span class="line">vnode.data.keepAlive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="切换组件"><a href="#切换组件" class="headerlink" title="切换组件"></a>切换组件</h2><ol>
<li>触发 kepp-alive 的 watcher，执行patch方法，会执行 <strong>prepatch</strong> 方法,修改 keep-alive中插槽的值</li>
</ol>
<blockquote>
<p>因为更新后的 keep-alive vnode是相同的，不会触发 createElement重新渲染keep-alive，而 vm.$slots 是在生成vm实例时得到的，所以需要调用 prepatch。并且修改了 <strong>vm.$slots</strong> 需要重新触发 keep-alive 的 render 方法，返回新的vnode进行渲染</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prepatch: <span class="function"><span class="keyword">function</span> <span class="title">prepatch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = vnode.componentOptions;</span><br><span class="line">    <span class="keyword">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">    updateChildComponent(</span><br><span class="line">      child,</span><br><span class="line">      options.propsData, <span class="comment">// updated props</span></span><br><span class="line">      options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">      vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">      options.children <span class="comment">// new children</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//updateChildComponent</span></span><br><span class="line"><span class="keyword">var</span> needsForceUpdate = !!(</span><br><span class="line">      renderChildren ||               <span class="comment">// has new static slots</span></span><br><span class="line">      vm.$options._renderChildren ||  <span class="comment">// has old static slots</span></span><br><span class="line">      hasDynamicScopedSlot</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needsForceUpdate) &#123;</span><br><span class="line">      vm.$slots = resolveSlots(renderChildren, parentVnode.context); <span class="comment">//修改 vm.$slots</span></span><br><span class="line">      vm.$forceUpdate(); <span class="comment">//触发 keep-alive的forceUpdate，重新执行 &lt;keep-alive&gt; 的 render </span></span><br><span class="line">  &#125; <span class="comment">//重新触发 keep-alive的渲染</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>keep-alive 组件的实例化其中执行 render函数，会返回新的插槽组件vnode</p>
<ul>
<li>如果keep-alive中缓存了该vnode，那么 vnode.componentInstance = 缓存的componentInstance</li>
</ul>
</li>
<li><p>对插槽组件vnode进行渲染,在生成vnode的vm实例时，会对 componentInstance 进行判断</p>
<ul>
<li>如果存在 componentInstance 就不会重新生成vm实例，而是 触发 vnode.prepatch</li>
<li>不存在，则创建vm实例</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init (vnode: VNodeWithData, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.componentInstance &amp;&amp;</span><br><span class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">      vnode.data.keepAlive</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//vm实例</span></span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="更换内容-可以忽略"><a href="#更换内容-可以忽略" class="headerlink" title="更换内容  // 可以忽略"></a>更换内容  // 可以忽略</h2><p>vm._render() 重新生成vnode</p>
<p>vm._update -&gt; vm.patch 比较新旧vnode</p>
<p>patchVnode 调用 组件的 prePatch钩子函数 -&gt; updateChildComponent</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> needsForceUpdate = !!(</span><br><span class="line">      renderChildren ||               <span class="comment">// has new static slots</span></span><br><span class="line">      vm.$options._renderChildren ||  <span class="comment">// has old static slots</span></span><br><span class="line">      hasDynamicScopedSlot</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"> vm.$options._renderChildren = renderChildren;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (needsForceUpdate) &#123;</span><br><span class="line">      vm.$slots = resolveSlots(renderChildren, parentVnode.context);</span><br><span class="line">      vm.$forceUpdate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果是一个插槽，修改 keep-alive vm实例的 vm.$options._renderChildren 为新的内容（initRender时会挂载到 $slots $slotScopes）</p>
</li>
<li><p>进行强制更新，触发 keep-alive vm实例的watcher更新 在下一次nextTick进行更新</p>
</li>
<li><p>再次调用 keep-alive组件的 render方法，如果缓存中没有该vnode则进行缓存</p>
</li>
<li><p>在patch完成后，执行invokeInsertHook，如果是首次缓存，则调用 mounted activated钩子函数，</p>
</li>
<li><p>如果 内容已经在缓存内，那么在 调用render函数时，会直接将 vm实例 挂载到 vnode.componentInstance上，（<code>vnode = this.$slots.default[0]</code>）</p>
</li>
<li><p>调用 kepp-alive 的 init方法，由于此时已经存在 vnode.componentInstance,会调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mountedNode = vnode;</span><br><span class="line">componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><br></pre></td></tr></table></figure></li>
<li><p>此时 needsForceUpdate = false ，不会触发强制更新</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>10.插槽</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/10.%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="./demo/slot.html">demo</a></p>
<a id="more"></a>
<h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p>parseEndTag -&gt; end -&gt; closeElement -&gt; processElement -&gt; processSlotContent</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:main</span>=<span class="string">'data'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;data.people.name&#125;&#125; + &#123;&#123;data.text&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;desc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析 template 标签 生成ast树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = getSlotName(slotBinding);</span><br><span class="line"><span class="keyword">var</span> name = ref.name;</span><br><span class="line"><span class="keyword">var</span> dynamic = ref.dynamic;</span><br><span class="line">el.slotTarget = name;</span><br><span class="line">el.slotTargetDynamic = dynamic;</span><br><span class="line">el.slotScope = slotBinding.value || emptySlotScopeToken;</span><br></pre></td></tr></table></figure>

<p>在ast (<code>template</code>)节点添加如下属性 </p>
<ul>
<li>slotTarget：name    <code>header</code> //插槽的名字</li>
<li>slotTargetDynamic </li>
<li>slotScope：value || <code>_empty_</code>     //传入插槽内部的值</li>
</ul>
<p>slotTargetDynamic 与 needsForceUpdate 有关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> needsForceUpdate = el.for || <span class="built_in">Object</span>.keys(slots).some(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> slot = slots[key];</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        slot.slotTargetDynamic ||</span><br><span class="line">        slot.if ||</span><br><span class="line">        slot.for ||</span><br><span class="line">        containsSlotChild(slot) <span class="comment">// is passing down slot from parent which may be dynamic</span></span><br><span class="line">      )</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在 closeElement 建立父子关系时，在 父节点ast (<code>&lt;layout&gt;</code>)的 scopedSlots 中添加该 template 的 ast节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.slotScope) &#123;</span><br><span class="line">  <span class="comment">// scoped slot</span></span><br><span class="line">  <span class="comment">// keep it in the children list so that v-else(-if) conditions can</span></span><br><span class="line">  <span class="comment">// find it as the prev node.</span></span><br><span class="line">  <span class="keyword">var</span> name = element.slotTarget || <span class="string">'"default"'</span></span><br><span class="line">  ;(currentParent.scopedSlots || (currentParent.scopedSlots = &#123;&#125;))[name] = element; <span class="comment">//当前ast节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>genElement -&gt; genData 代码生成<br>解析写在组件中的 html标签，也就是 上文中的父节点的 scopedSlots 字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//genData</span></span><br><span class="line">    <span class="comment">// scoped slots</span></span><br><span class="line">    <span class="keyword">if</span> (el.scopedSlots) &#123;</span><br><span class="line">      data += (genScopedSlots(el, el.scopedSlots, state)) + <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//genScopedSlots</span></span><br><span class="line">  <span class="keyword">var</span> generatedSlots = <span class="built_in">Object</span>.keys(slots)</span><br><span class="line">      .map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> genScopedSlot(slots[key], state); &#125;)</span><br><span class="line">      .join(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"scopedSlots:_u(["</span> + generatedSlots + <span class="string">"]"</span> + (needsForceUpdate ? <span class="string">",null,true"</span> : <span class="string">""</span>) + (!needsForceUpdate &amp;&amp; needsKey ? (<span class="string">",null,false,"</span> + (hash(generatedSlots))) : <span class="string">""</span>) + <span class="string">")"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// genScopedSlot</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">genScopedSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el,</span></span></span><br><span class="line"><span class="function"><span class="params">    state</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isLegacySyntax = el.attrsMap[<span class="string">'slot-scope'</span>];</span><br><span class="line">    <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed &amp;&amp; !isLegacySyntax) &#123;</span><br><span class="line">      <span class="keyword">return</span> genIf(el, state, genScopedSlot, <span class="string">"null"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">      <span class="keyword">return</span> genFor(el, state, genScopedSlot)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> slotScope = el.slotScope === emptySlotScopeToken</span><br><span class="line">      ? <span class="string">""</span></span><br><span class="line">      : <span class="built_in">String</span>(el.slotScope);</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="string">"function("</span> + slotScope + <span class="string">")&#123;"</span> +</span><br><span class="line">      <span class="string">"return "</span> + (el.tag === <span class="string">'template'</span></span><br><span class="line">        ? el.if &amp;&amp; isLegacySyntax</span><br><span class="line">          ? (<span class="string">"("</span> + (el.if) + <span class="string">")?"</span> + (genChildren(el, state) || <span class="string">'undefined'</span>) + <span class="string">":undefined"</span>)</span><br><span class="line">          : genChildren(el, state) || <span class="string">'undefined'</span></span><br><span class="line">        : genElement(el, state)) + <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">// reverse proxy v-slot without scope on this.$slots</span></span><br><span class="line">    <span class="keyword">var</span> reverseProxy = slotScope ? <span class="string">""</span> : <span class="string">",proxy:true"</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"&#123;key:"</span> + (el.slotTarget || <span class="string">"\"default\""</span>) + <span class="string">",fn:"</span> + fn + reverseProxy + <span class="string">"&#125;"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'layout'</span>,&#123;<span class="attr">scopedSlots</span>:_u([&#123;<span class="attr">key</span>:<span class="string">"header"</span>,<span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'h1'</span>,[_v(_s(title))])]&#125;,<span class="attr">proxy</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">key</span>:<span class="string">"main"</span>,<span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'p'</span>,[_v(_s(msg))])]&#125;,<span class="attr">proxy</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">key</span>:<span class="string">"footer"</span>,<span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'p'</span>,[_v(_s(desc))])]&#125;,<span class="attr">proxy</span>:<span class="literal">true</span>&#125;])&#125;)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h4><p>生成ast树</p>
<p>processSlotOutlet ,根据 <code>&lt;slot name=&#39;name&#39;&gt;&lt;/slot&gt;</code>在ast节点上生成 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processSlotOutlet</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">      el.slotName = getBindingAttr(el, <span class="string">'name'</span>);</span><br><span class="line">      <span class="keyword">if</span> (el.key) &#123;</span><br><span class="line">        warn$<span class="number">2</span>(</span><br><span class="line">          <span class="string">"`key` does not work on &lt;slot&gt; because slots are abstract outlets "</span> +</span><br><span class="line">          <span class="string">"and can possibly expand into multiple elements. "</span> +</span><br><span class="line">          <span class="string">"Use the key on a wrapping element instead."</span>,</span><br><span class="line">          getRawBindingAttr(el, <span class="string">'key'</span>)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>slotName = ‘name’</li>
</ul>
<p>代码生成 genElement -&gt; genSlot</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>genSlot方法 解析 slot标签,生成:<code>_t(&quot;header&quot;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[_c(<span class="string">'header'</span>,[_t(<span class="string">"header"</span>)],<span class="number">2</span>),_v(<span class="string">" "</span>),</span><br><span class="line">_c(<span class="string">'main'</span>,[_t(<span class="string">"main"</span>)],<span class="number">2</span>),_v(<span class="string">" "</span>)</span><br><span class="line">,_c(<span class="string">'footer'</span>,[_t(<span class="string">"footer"</span>)],<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>4</p>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target._o = markOnce</span><br><span class="line">target._n = toNumber</span><br><span class="line">target._s = toString</span><br><span class="line">target._l = renderList</span><br><span class="line">target._t = renderSlot</span><br><span class="line">target._q = looseEqual</span><br><span class="line">target._i = looseIndexOf</span><br><span class="line">target._m = renderStatic</span><br><span class="line">target._f = resolveFilter</span><br><span class="line">target._k = checkKeyCodes</span><br><span class="line">target._b = bindObjectProps</span><br><span class="line">target._v = createTextVNode</span><br><span class="line">target._e = createEmptyVNode</span><br><span class="line">target._u = resolveScopedSlots</span><br><span class="line">target._g = bindObjectListeners</span><br><span class="line">target._d = bindDynamicKeys</span><br><span class="line">target._p = prependModifier</span><br></pre></td></tr></table></figure>

<p>target._t = renderSlot</p>
<h4 id="生成占位符vnode"><a href="#生成占位符vnode" class="headerlink" title="生成占位符vnode"></a>生成占位符vnode</h4><p>组件占位符节点在render的过程中，执行 <strong>_u</strong> ，也就是 <strong>resolveScopedSlots</strong> 方法，该方法会将 slotScopes中的数组展开成一个对象,作为 createElement 的 data.scopedSlots 参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scopedSlots:&#123;</span><br><span class="line">  footer:fn(), </span><br><span class="line">  header:fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'h1'</span>,[_v(_s(title))])]&#125;,</span><br><span class="line">  main:fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p>在 生成组件实例 vm.$options._renderChildren 时，会进行配置的合并，其中就包括 占位符vnode.vnodeComponentOptions.children </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initInternalComponent  vm.$options</span></span><br><span class="line">opts._renderChildren = vnodeComponentOptions.children</span><br></pre></td></tr></table></figure>

<p>在 组件vue _init -&gt; initRender </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$slots = resolveSlots(options._renderChildren, renderContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resolveSlots</span></span><br><span class="line">slots = vm.$slots</span><br><span class="line">(slots.default || (slots.default = [])).push(child);</span><br></pre></td></tr></table></figure>

<h4 id="生成-组件vm实例"><a href="#生成-组件vm实例" class="headerlink" title="生成 组件vm实例"></a>生成 组件vm实例</h4><p>组件生成的 vm 实例  _init-&gt;_render 会执行 Vue._render()，在生成渲染vnode前，将占位符vnode的 slotScopes 以及 slots 添加到当前 组件的 vueComponent实例中</p>
<ul>
<li>将 _parentVnode.data.scopedSlots 上的render方法 挂载到 vm.$slots,如果可以使用代理 就 defineProperty，否则直接添加方法，这样可以直接在取值时获得</li>
<li>将 vm.$slots 上的 vnode ，通过<code>function () { return vm.$slots[key]; }</code>封装挂载到 vm.$scopedSlots</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">        vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">          _parentVnode.data.scopedSlots, <span class="comment">//占位符vnode</span></span><br><span class="line">          vm.$slots,</span><br><span class="line">          vm.$scopedSlots</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$slotScopes =</span><br><span class="line">&#123;</span><br><span class="line">  footer:fn(), </span><br><span class="line">  header:fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'h1'</span>,[_v(_s(title))])]&#125;,</span><br><span class="line">  main:fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm.$slots = &#123;</span><br><span class="line">  footer:[vnode],</span><br><span class="line">  header:[vnode],</span><br><span class="line">  main:[vnode],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fn函数就是在编译父节点过程中生成的</p>
<p>接着调用 子组件的 render函数 生成 vnode，在此过程中会调用 <code>_t(&quot;header&quot;)</code>,也就是 renderSlot方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scopedSlotFn = <span class="keyword">this</span>.$scopedSlots[name];</span><br><span class="line"><span class="keyword">if</span>(scopedSlotFn)&#123;</span><br><span class="line">  nodes = scopedSlotFn(props) || fallback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  nodes = <span class="keyword">this</span>.$slots[name] || fallback; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用父节点的 fn函数 来生成 vnode节点，作为子组件 调用createElement()的子节点，其中 fallback 为默认操作</p>
<p>其中 fn 被封装为 normalizer方法 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> normalized = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> res = <span class="built_in">arguments</span>.length ? fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>) : fn(&#123;&#125;);</span><br><span class="line">      res = res &amp;&amp; <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(res)</span><br><span class="line">        ? [res] <span class="comment">// single vnode</span></span><br><span class="line">        : normalizeChildren(res);</span><br><span class="line">      <span class="keyword">return</span> res &amp;&amp; (</span><br><span class="line">        res.length === <span class="number">0</span> ||</span><br><span class="line">        (res.length === <span class="number">1</span> &amp;&amp; res[<span class="number">0</span>].isComment) <span class="comment">// #9658</span></span><br><span class="line">      ) ? <span class="literal">undefined</span></span><br><span class="line">        : res</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>这样就实现了 父节点定义的slot 在组件中作为vnode被渲染出来</p>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>对于父节点，作用域插槽 <code>v-slot：main=&#39;data&#39;</code> 有了 value值，所以slotScope不再为空值 empty，而是 value</p>
<ul>
<li>slotTarget：name  //main</li>
<li>slotTargetDynamic</li>
<li>slotScope：value  //data</li>
</ul>
<p>生成的代码会有所不同，main的fn函数 带了 data 属性，<strong>没有proxy属性</strong></p>
<blockquote>
<p>是否有proxy,依据 template生成的ast节点的 slotScope属性是否为 <code>_empty_</code>，如果是的话，proxy为true，否则为false</p>
</blockquote>
<p>proxy 为false 时， vm.$slots 里不会添加该slot，是为了什么？<br>因为 调用该方法需要传入 一个参数，通过get方法来执行fn时 无法传入参数,所以不会挂载到 vm.$slots上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> normalized = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> res = <span class="built_in">arguments</span>.length ? fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>) : fn(&#123;&#125;);</span><br><span class="line">      res = res &amp;&amp; <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(res)</span><br><span class="line">        ? [res] <span class="comment">// single vnode</span></span><br><span class="line">        : normalizeChildren(res);</span><br><span class="line">      <span class="keyword">return</span> res &amp;&amp; (</span><br><span class="line">        res.length === <span class="number">0</span> ||</span><br><span class="line">        (res.length === <span class="number">1</span> &amp;&amp; res[<span class="number">0</span>].isComment) <span class="comment">// #9658</span></span><br><span class="line">      ) ? <span class="literal">undefined</span></span><br><span class="line">        : res</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fn.proxy) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(normalSlots, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>: normalized,</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return normalized</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 占位符vnode this执行的是父vm实例</span></span><br><span class="line">&#123;<span class="attr">key</span>:<span class="string">"main"</span>,<span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="keyword">return</span> [_c(<span class="string">'p'</span>,[_v(_s(data.people.name)+<span class="string">" + "</span>+_s(data.text))])]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对于子组件生成ast树和代码生成都和之前差不多，就是多了一下属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_c(<span class="string">'main'</span>,[_t(<span class="string">"main"</span>,[_c(<span class="string">'p'</span>,[_v(_s(people.age))])],&#123;<span class="string">"people"</span>:people,<span class="string">"text"</span>:<span class="string">"hello"</span>&#125;)],<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>运行时，子组件的 </p>
<p>在将父节点的 slotScopes 整合到 vm上时，proxy为false的 fn不会被添加到 vm.$slots上，其他字段还是相同。</p>
<p><code>_t(&quot;main&quot;,[_c(&#39;p&#39;,[_v(_s(people.age))])],{&quot;people&quot;:people,&quot;text&quot;:&quot;hello&quot;}</code>,的第三个参数，把子组件的数据作为参数传给了 父节点</p>
<p>子组件 slot上定义的数据作为一个对象传给了 父节点的 fn函数，所以父节点可以得到子组件的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name,</span></span></span><br><span class="line"><span class="function"><span class="params">  fallback, <span class="regexp">//</span>插槽默认渲染的dom</span></span></span><br><span class="line"><span class="function"><span class="params">  props,</span></span></span><br><span class="line"><span class="function"><span class="params">  bindObject</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scopedSlotFn = <span class="keyword">this</span>.$scopedSlots[name];</span><br><span class="line">  nodes = scopedSlotFn(props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>‘with’语句将某个对象添加到作用域链的顶部，如果在 with中的语句 中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。</p>
<p>尽量还是使用 闭包 来将需要保存的对象用一个临时变量来保存指针</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>prepatch 修改</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>插槽 的 vnode生成是在 子组件渲染的时候，而不是父节点，但是子组件调用 fn方法 render函数来生成vnode 的作用域是父节点<br>作用域插槽的vnode的data中保留scopedSlots对象，fn方法 render函数传入scopedSlot</p>
<blockquote>
<p>对于插槽内容是组件的情况，不会生成render函数，而是直接使用组件名来调用 createElement方法来生产 vnode，_c(tab[right_tab],{tag:”component”})</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>9.双向绑定</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/9.%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Av-model/</url>
    <content><![CDATA[<h2 id="补充表单知识点"><a href="#补充表单知识点" class="headerlink" title="补充表单知识点"></a>补充表单知识点</h2><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>input</p>
<ul>
<li>text 单行文本<ul>
<li>placeholder 默认文本</li>
</ul>
</li>
<li>radio 单选框<ul>
<li>value</li>
<li>name  单选框组名字相同</li>
</ul>
</li>
<li>checkbox 复选框<ul>
<li>value 提交的值 </li>
</ul>
</li>
</ul>
<p>textarea 多行文本</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>select 选择框<ul>
<li>option 选项<ul>
<li>value 没有的话 默认为其中文本值</li>
<li>disabled 不可选</li>
</ul>
</li>
<li>multiple 多选</li>
</ul>
</li>
</ul>
<h4 id="v-model修饰符"><a href="#v-model修饰符" class="headerlink" title="v-model修饰符"></a>v-model修饰符</h4><ul>
<li>.lazy v-model 在每次 input 事件触发后将输入框的值与数据进行同步,你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步<blockquote>
<p>input事件是在输入文本的时候触发，change事件是在input表单失去焦点时触发</p>
</blockquote>
</li>
<li>.number</li>
<li>.trim</li>
</ul>
<h4 id="composition-事件"><a href="#composition-事件" class="headerlink" title="composition 事件"></a>composition 事件</h4><p>compositionstart 事件在用户开始进行非直接输入的时候触发，而在非直接输入结束，也即用户点选候选词或者点击「选定」按钮之后，会触发 compositionen 事件。</p>
<p>当输入一个中文时，触发顺序：</p>
<ul>
<li>composition start</li>
<li>input</li>
<li>input</li>
<li>input</li>
<li>composition end</li>
</ul>
<p>compositionStart事件之后依旧要执行 input事件，如果要阻止 input事件的触发，可以使用一个boolean变量来控制。参考vue v-model 对 input标签的处理</p>
<p>在输入中文时，compositionend 事件在 input 事件之后触发，所以在 compositionend事件触发时，也要手动调用 input 事件处理逻辑。</p>
<h4 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>) <span class="comment">//MouseEvents UIEvents</span></span><br><span class="line">e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>) <span class="comment">//决定是否事件是否应该向上冒泡</span></span><br><span class="line">el.dispatchEvent(e)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>initEvent(type,bubbles,cancelable)</p>
<ul>
<li>事件类型</li>
<li>决定是否事件是否应该向上冒泡</li>
<li>决定该事件的默认动作是否可以被取消</li>
</ul>
</li>
<li><p>el.dispatchEvent 向一个指定的事件目标el派发一个事件</p>
</li>
</ul>
<p>现在被  event = new Event(typeArg, eventInit); 替代<br>是 EventInit 类型的字典，接受以下字段: 对象</p>
<ul>
<li>“bubbles”，可选，Boolean类型，默认值为 false，表示该事件是否冒泡。</li>
<li>“cancelable”，可选，Boolean类型，默认值为 false， 表示该事件能否被取消。</li>
<li>“composed”，可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。</li>
</ul>
<h2 id="编译-parse"><a href="#编译-parse" class="headerlink" title="编译 parse"></a>编译 parse</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">'e=&gt;this.message=e.target.value&#125;'</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-model等相关信息都保存在 AST树节点的 attrsList 数组中。比如：<code>name: &quot;v-model&quot;, value: &quot;message&quot;</code></p>
<p>执行 addDirective,把 name,rawname,value包装成对象 添加到 ast节点的 <strong>directives</strong>属性上</p>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>genData中 genDirectives -&gt; model -&gt; genDefaultModel</p>
<p>实现了对 ast节点中directives属性的代码生成</p>
<p>生成回调函数 <code>if($event.target.composing)return;message=$event.target.value</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addProp(el, <span class="string">'value'</span>, <span class="string">`(<span class="subst">$&#123;value&#125;</span>)`</span>)</span><br><span class="line">addHandler(el, event, code, <span class="literal">null</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>addProps 将 message 作为prop传给 value  : <code>el.props.push({name:&quot;value&quot;,value:&quot;(message)&quot;})</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: <span class="built_in">Array</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="number">0</span>:</span><br><span class="line">        dynamic: <span class="literal">undefined</span></span><br><span class="line">        name: <span class="string">"value"</span></span><br><span class="line">        value: <span class="string">"(message)"</span></span><br></pre></td></tr></table></figure>
<p>addHandler 将回调事件添加到ats节点的 events:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.events[input] = &#123;<span class="attr">dynamic</span>: <span class="literal">undefined</span>,</span><br><span class="line">        value: <span class="string">"if($event.target.composing)return;message=$event.target.value"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>vnode的data上保存了 编译过程中产生的属性，最终生成 data对象，成为createElement的第二个参数传入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[_c(<span class="string">'input'</span>,&#123;<span class="attr">directives</span>:[&#123;<span class="attr">name</span>:<span class="string">"model"</span>,<span class="attr">rawName</span>:<span class="string">"v-model"</span>,<span class="attr">value</span>:(message),<span class="attr">expression</span>:<span class="string">"message"</span>&#125;],<span class="attr">attrs</span>:&#123;<span class="string">"placeholder"</span>:<span class="string">"edit me"</span>&#125;,<span class="attr">domProps</span>:&#123;<span class="string">"value"</span>:(message)&#125;,<span class="attr">on</span>:&#123;<span class="string">"input"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;<span class="keyword">if</span>($event.target.composing)<span class="keyword">return</span>;message=$event.target.value&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>domProps:{&quot;value&quot;:(message)</code>  v-bind 是形成的参数</p>
<p><code>on:{&quot;input&quot;:function($event){if($event.target.composing)return;message=$event.target.value}}</code></p>
<p>都是生成的</p>
<h2 id="v-model-运行时"><a href="#v-model-运行时" class="headerlink" title="v-model 运行时"></a>v-model 运行时</h2><h4 id="vue-input-对于-中文输入的处理"><a href="#vue-input-对于-中文输入的处理" class="headerlink" title="vue input 对于 中文输入的处理"></a>vue input 对于 中文输入的处理</h4><p>patch -&gt; createElm -&gt; invokeCreateHooks -&gt; <strong>updateDirectives</strong>，对data中的directives对象进行处理</p>
<p>insertedVnodeQueue 里添加 insert事件，触发 inserted 事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.addEventListener(<span class="string">'compositionstart'</span>, onCompositionStart)</span><br><span class="line">el.addEventListener(<span class="string">'compositionend'</span>, onCompositionEnd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompositionStart</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.target.composing = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompositionEnd</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// prevent triggering an input event for no reason</span></span><br><span class="line">  <span class="keyword">if</span> (!e.target.composing) <span class="keyword">return</span></span><br><span class="line">  e.target.composing = <span class="literal">false</span></span><br><span class="line">  trigger(e.target, <span class="string">'input'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span> (<span class="params">el, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>)</span><br><span class="line">  e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">  el.dispatchEvent(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在生产的代码中 对 input事件的回调函数是这样写的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (needCompositionGuard) &#123;</span><br><span class="line">    code = <span class="string">`if($event.target.composing)return;<span class="subst">$&#123;code&#125;</span>`</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中就通过<code>$event.target.composing</code>这个值来控制input事件回调函数的触发</p>
<h2 id="components-上的-v-model"><a href="#components-上的-v-model" class="headerlink" title="components 上的 v-model"></a>components 上的 v-model</h2><p>在编译的过程中会在ast节点上的data中生成 model 对象,这个data会作为 createElement的第二个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.model) &#123;</span><br><span class="line">  data += <span class="string">`model:&#123;value:<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    el.model.value</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>,callback:<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    el.model.callback</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>,expression:<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    el.model.expression</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>&#125;,`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model = &#123;</span><br><span class="line">    callback: <span class="string">"function ($$v) &#123;message=$$v&#125;"</span></span><br><span class="line">    expression: <span class="string">"message"</span></span><br><span class="line">    value: <span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>

<p>生成render函数<br><code>_c(&#39;child&#39;,{model:{value:(),callback:function ($$v) {message=$$v},expression:&quot;message&quot;}}</code></p>
<h4 id="生成vnode"><a href="#生成vnode" class="headerlink" title="生成vnode"></a>生成vnode</h4><p>执行上述render函数</p>
<p>createElement -&gt; createComponent，对 data 中的 model对象进行处理,其中data是父组件的data， Ctor.options是子组件的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (isDef(data.model)) &#123;<span class="comment">//组件渲染 vnode</span></span><br><span class="line">    transformModel(Ctor.options, data)  <span class="comment">//Ctor.options 占位符vnode</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transformModel (options, <span class="attr">data</span>: any) &#123;</span><br><span class="line">  <span class="keyword">const</span> prop = (options.model &amp;&amp; options.model.prop) || <span class="string">'value'</span></span><br><span class="line">  <span class="keyword">const</span> event = (options.model &amp;&amp; options.model.event) || <span class="string">'input'</span></span><br><span class="line">  ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value</span><br><span class="line">  <span class="keyword">const</span> on = data.on || (data.on = &#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> existing = on[event]</span><br><span class="line">  <span class="keyword">const</span> callback = data.model.callback</span><br><span class="line">  <span class="keyword">if</span> (isDef(existing)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(existing)</span><br><span class="line">        ? existing.indexOf(callback) === <span class="number">-1</span></span><br><span class="line">        : existing !== callback</span><br><span class="line">    ) &#123;</span><br><span class="line">      on[event] = [callback].concat(existing)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    on[event] = callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transformModel 就是把 props：value 和 input 事件添加到 组件data属性上<br>（data就是createElement的第二个参数）<br><code>data.attrs[prop] = value</code></p>
<p><code>data.on[event] = callback</code></p>
<p>相当于<br><code>&lt;child :value=&#39;message&#39; @input=&#39;function ($$v) {message=$$v}&#39;&gt;&lt;/child&gt;</code></p>
<p><code>&lt;child :msg = &#39;message&#39; @change=&#39;function($$v){message=$$v}&#39;&gt;</code></p>
<p>接着执行 extractPropsFromVNodeData，删除 data.attrs 中组件已有的props属性，转移到 <strong>propsDate</strong>这个属性中，作为占位符vnode的 componentOptions 属性传入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      (<span class="string">"vue-component-"</span> + (Ctor.cid) + (name ? (<span class="string">"-"</span> + name) : <span class="string">''</span>)),</span><br><span class="line">      data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">      &#123; <span class="attr">Ctor</span>: Ctor, <span class="attr">propsData</span>: propsData, <span class="attr">listeners</span>: listeners, <span class="attr">tag</span>: tag, <span class="attr">children</span>: children &#125;,</span><br><span class="line">      asyncFactory</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>data.model中 联合组件的model属性</p>
<ul>
<li>value 属性 会被转化为 生成的 vnode 的 componentOptions.propsData</li>
<li>callback 自定义事件 vnode.componentOptions.listeners</li>
</ul>
<p>在生成子组件构造函数时 ,Ctor.options 的生成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.extend</span></span><br><span class="line"></span><br><span class="line"> Sub.options = mergeOptions(</span><br><span class="line">        Super.options,</span><br><span class="line">        extendOptions  <span class="comment">// 子组件的属性</span></span><br><span class="line">      );</span><br><span class="line"> <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">    initProps(Sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps$1</span> (<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> props = Comp.options.props;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      proxy(Comp.prototype, <span class="string">"_props"</span>, key); <span class="comment">// vm.key =&gt; get return this._props.key</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]   <span class="comment">// this =&gt; Vue实例 ,target =&gt; Vue实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="model对象"><a href="#model对象" class="headerlink" title="model对象"></a>model对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> child = &#123;</span><br><span class="line">  template:<span class="string">`&lt;dic id='child'&gt;</span></span><br><span class="line"><span class="string">      &lt;input :value='msg' @input='updateValue' placeholder='edit me'&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">  props:[<span class="string">'msg'</span>],</span><br><span class="line">  model:&#123;</span><br><span class="line">    prop:<span class="string">'msg'</span>,</span><br><span class="line">    event:<span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateValue(e)&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;child v-model=<span class="string">'message'</span>&gt;&lt;<span class="regexp">/child&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的model对象可以改变传入的prop属性名，和 触发的input事件的名字 (默认是 value 和 input)</p>
<ul>
<li>prop 修改 调用组件时 传入的prop名字 <code>:msg = message</code></li>
<li>event 修改 调用组件时 触发的事件名字 <code>@change=function(){}</code></li>
</ul>
<h4 id="patch-生成dom实例"><a href="#patch-生成dom实例" class="headerlink" title="patch 生成dom实例"></a>patch 生成dom实例</h4><p>调用子组件的 Ctor构造函数，执行_init -&gt; initInternalComponent,将vnode的componentOptions属性 赋值到了 vm.$options 上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">opts._parentListeners = vnodeComponentOptions.listeners</span><br></pre></td></tr></table></figure>
<p>initEvents(vm); 生成事件<br>initState(vm) 生成props</p>
<p>在生成组件vm时，调用 initProps() ，将props这个对象进行响应式处理 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    vm._watchers = [];</span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">    <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;  <span class="comment">// vm.$options.props 是继承了组件属性</span></span><br><span class="line">    <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">      initData(vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">      initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initProps</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm, propsOptions</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125; <span class="comment">//将props 放到 vm._props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  defineReactive(props, key, value)  <span class="comment">// 不给props对象生成observe实例是为了防止响应式的通过 Vue.set Vue.delete 往props 上添加删除属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)  <span class="comment">//挂载到vm实例上</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件v-model-和-表单v-model的区别"><a href="#组件v-model-和-表单v-model的区别" class="headerlink" title="组件v-model 和 表单v-model的区别"></a>组件v-model 和 表单v-model的区别</h2><h4 id="表单v-model"><a href="#表单v-model" class="headerlink" title="表单v-model"></a>表单v-model</h4><p>编译在生成ast节点时，生成directives属性</p>
<p>在生成目标代码时，会先在 ast节点上生成</p>
<ul>
<li>props</li>
<li>events<br>通过判断ast节点是否有这些属性，生成对应的代码</li>
</ul>
<p>在运行阶段，patch过程中，<strong>invokeCreateHooks</strong>，分别为dom对象添加两个事件<br>props，events 分别由对应的 <strong>invokeCreateHooks</strong> </p>
<ul>
<li>updateDOMProps</li>
<li>updateDOMListeners<br>处理生成</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.addEventListener(<span class="string">'compositionstart'</span>, onCompositionStart)</span><br><span class="line">el.addEventListener(<span class="string">'compositionend'</span>, onCompositionEnd)</span><br></pre></td></tr></table></figure>
<h4 id="组件v-model"><a href="#组件v-model" class="headerlink" title="组件v-model"></a>组件v-model</h4><p>在编译阶段 在 ast树中生成 model属性</p>
<p>在生成目标代码的过程中，根据model属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model = &#123;</span><br><span class="line">    callback: <span class="string">"function ($$v) &#123;message=$$v&#125;"</span></span><br><span class="line">    expression: <span class="string">""</span>message<span class="string">""</span></span><br><span class="line">    value: <span class="string">"(message)"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>生成的render函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">'div'</span>,[_c(<span class="string">'child'</span>,&#123;  <span class="comment">//占位符 vnode.data</span></span><br><span class="line">    model:&#123;</span><br><span class="line">      value:(message),</span><br><span class="line">      callback:<span class="function"><span class="keyword">function</span> (<span class="params">$$v</span>) </span>&#123;</span><br><span class="line">        message=$$v</span><br><span class="line">      &#125;,</span><br><span class="line">      expression:<span class="string">"message"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  _c(<span class="string">'p'</span>,[_v(<span class="string">"Message is: "</span>+_s(message))])],<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 占位符vnode.data  依据组件的model对象 添加了 model属性进行处理，如果没有model对象默认 为 value 和 input<br>在 data 中的 (data就是 createElement的第二个属性)</p>
<ul>
<li>attrs属性中生成 <code>value: &quot;&quot;</code></li>
<li>on属性 <code>input: ƒ ($$v)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.attrs.props = &#123;</span><br><span class="line">  value: (message),</span><br><span class="line">&#125;</span><br><span class="line">data.on = &#123;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">$$v</span>) </span>&#123;</span><br><span class="line">    message=$$v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br></pre></td></tr></table></figure>
<p>将 attrs中的属性和 组件的options 中的 props中的属性进行比较，相同就从attrs中删去</p>
<p>最终转变成对 props 和 events 属性的处理</p>
<h2 id="props-原理"><a href="#props-原理" class="headerlink" title="props 原理"></a>props 原理</h2><h3 id="对于组件"><a href="#对于组件" class="headerlink" title="对于组件"></a>对于组件</h3><ol>
<li><p>对于普通的组件 props ，<code>&lt;mycomp :msg = message&gt;&lt;/mycomp&gt;</code> 关于props的属性生成在 data.attrs上 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//data</span></span><br><span class="line">attrs:&#123;<span class="string">"msg"</span>:mess</span><br><span class="line">age&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在生成组件构造函数时，会将 attrs上的属性 转移到 propsData 上，作为组件vnode的 componentOptions.propsData属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生成组件vm时，将vnode.componentOptions 的属性 赋值到 vm.$options 上，调用 initProps() ，将props这个对象进行响应式处理 </p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// props中的每一个key</span></span><br><span class="line">  defineReactive(props, key, value, () =&gt; &#123; <span class="comment">// props 上的 key 变成响应式的</span></span><br><span class="line">  <span class="comment">// 不给props对象生成observe实例是为了防止响应式的通过 Vue.set Vue.delete 往props 上添加删除属性</span></span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;  <span class="comment">//isUpdatingChildComponent 判断是否此key是否处于updatingChildren中被修改，如果不是，说明此修改来自子组件，触发warning提示。</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)  <span class="comment">//挂载到vm实例上</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proxy</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]   <span class="comment">// this =&gt; Vue实例 ,target =&gt; Vue实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>响应式，将新的值作为新的vnode的参数，重新渲染<h3 id="对于普通的html标签"><a href="#对于普通的html标签" class="headerlink" title="对于普通的html标签"></a>对于普通的html标签</h3></li>
<li>props相关信息储存在 domProps上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">domProps:&#123;<span class="string">"value"</span>:message&#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="v-model和-sync修饰符区别"><a href="#v-model和-sync修饰符区别" class="headerlink" title="v-model和.sync修饰符区别"></a>v-model和.sync修饰符区别</h4><p>两者本质都是一样，并没有任何区别： “监听一个触发事件”=”(val) =&gt; value = val”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--v-model写法--&gt;</span><br><span class="line">&lt;my-component type=<span class="string">"text"</span> v-model=<span class="string">"value"</span>&gt;</span><br><span class="line">&lt;!--编译后的写法--&gt;</span><br><span class="line">&lt;my-component type=<span class="string">"text"</span></span><br><span class="line">  :value=<span class="string">"value"</span></span><br><span class="line">  @input=<span class="string">"value = $event.target.value"</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">默认针对原生组件input事件，但是如果子组件定义了针对事件</span><br><span class="line">model: &#123;</span><br><span class="line">        prop: <span class="string">"value"</span>,</span><br><span class="line">        event: <span class="string">"update"</span></span><br><span class="line">&#125;,</span><br><span class="line">则编译为</span><br><span class="line">--&gt;</span><br><span class="line">&lt;my-component type=<span class="string">"text"</span></span><br><span class="line">  :value=<span class="string">"value"</span></span><br><span class="line">  @update=<span class="string">"(val) =&gt; value = val"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--语法糖.sync--&gt;</span><br><span class="line">&lt;my-component :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--编译后的写法--&gt;</span><br><span class="line">&lt;my-component </span><br><span class="line">  :value=<span class="string">"msg"</span> </span><br><span class="line">  @update:value=<span class="string">"(val) =&gt; value = val"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>只不过v-model默认对应的是input或者textarea等组件的input事件，如果在子组件替换这个input事件，其本质和.sync修饰符一模一样。比较单一，不能有多个。</p>
</li>
<li><p>一个组件可以多个属性用.sync修饰符，可以同时”双向绑定多个“prop”，而并不像v-model那样，一个组件只能有一个。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>8.事件绑定</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/8.event/</url>
    <content><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h4 id="生成-ast树"><a href="#生成-ast树" class="headerlink" title="生成 ast树"></a>生成 ast树</h4><p> 根据 assts的属性来提取出其中的 事件属性<br> <a id="more"></a><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> el.events = &#123;</span><br><span class="line">  select: &#123;</span><br><span class="line">    value: <span class="string">'selectHandler'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.nativeEvents = &#123;</span><br><span class="line">  click: &#123;</span><br><span class="line">    value: <span class="string">'clickHandler'</span>,</span><br><span class="line">    modifiers: &#123;</span><br><span class="line">      prevent: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template: <span class="string">'&lt;button @click="clickHandler($event)" @select="selecHandler"&gt;'</span> +</span><br><span class="line"> <span class="string">'click me'</span> +</span><br><span class="line"> <span class="string">'&lt;/button&gt;'</span>,</span><br></pre></td></tr></table></figure>
<p>对于这种 <code>@click=&quot;clickHandler($event)&quot;</code>，即不满足是一个变量表达式，也不是一个函数表达式，在生成render函数时，会对回调函数进行包装， 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">$event</span>)</span>&#123;</span><br><span class="line">    value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;</span><br><span class="line">  clickHandler($event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入的data参数</span></span><br><span class="line">&#123;</span><br><span class="line">  on: &#123;<span class="string">"select"</span>: selectHandler&#125;,</span><br><span class="line">  nativeOn: &#123;<span class="string">"click"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;  <span class="comment">//native 只用在component上</span></span><br><span class="line">      $event.preventDefault();</span><br><span class="line">      <span class="keyword">return</span> clickHandler($event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><p>vue的事件修饰符</p>
<ul>
<li>capture  添加事件侦听器时使用事件捕获模式 , 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 捕获模式下触发事件</li>
<li>prevent 阻止默认事件发生</li>
<li>passive listener 永远不会调用 preventDefault()。</li>
<li>stop 阻止单击事件继续传播</li>
<li>self 只当在 event.target 是当前元素自身时触发处理函数</li>
<li>once </li>
</ul>
<blockquote>
<p>事件捕获和事件冒泡是两个公司提出的为了解决页面中事件流（从页面中接受事件的顺序，事件发生顺序）的问题，<strong>先事件捕获再事件冒泡</strong>，现在默认情况下使用的是<strong>事件冒泡</strong>阶段调用事件处理函数</p>
</blockquote>
<blockquote>
<p>addEventListener 第三个参数默认值为配置对象{capture:false} 以及第四个参数useCapture默认为false，表示在<strong>事件冒泡</strong>阶段调用事件处理函数;如果参数为true，则表示在事件捕获阶段调用处理函数</p>
</blockquote>
<p>target.addEventListener(type, listener, options);<br>target.addEventListener(type, listener, useCapture);</p>
<ul>
<li><p>option:{capture,once,passive} </p>
<ul>
<li>capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li>
<li>once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li>
<li>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。</li>
</ul>
</li>
<li><p>useCapture:同capture</p>
</li>
<li><p>e.targer 事件真正发出的dom </p>
</li>
<li><p>e.currentTarget 在事件冒泡阶段 捕获事件的dom</p>
</li>
</ul>
<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><p>patch 阶段 执行 <strong>invokeCreateHooks</strong> -&gt; updateDOMListeners （先子后父）</p>
<h4 id="初始化事件"><a href="#初始化事件" class="headerlink" title="初始化事件"></a>初始化事件</h4><p>传入的是 vnode.data.on</p>
<ul>
<li>updateListeners(vnode.data.on) 会  先遍历 新的事件，为每一个事件进行包装生成真正的执行函数invoker，事件的回调函数存储在 fns = invoker.fns</li>
<li>调用add方法，用过 target.addEventListene 真正添加监听事件， </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装回调函数 绑定到 invoker.fns 以便后期更换回调函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFnInvoker</span> (<span class="params">fns: Function | Array&lt;Function&gt;, vm: ?Component</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invoker</span> (<span class="params"></span>) </span>&#123; <span class="comment">//事件执行的回调函数</span></span><br><span class="line">    <span class="keyword">const</span> fns = invoker.fns</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      <span class="keyword">const</span> cloned = fns.slice()</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cloned.length; i++) &#123;</span><br><span class="line">        invokeWithErrorHandling(cloned[i], <span class="literal">null</span>, <span class="built_in">arguments</span>, vm, <span class="string">`v-on handler`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// return handler return value for single handlers</span></span><br><span class="line">      <span class="keyword">return</span> invokeWithErrorHandling(fns, <span class="literal">null</span>, <span class="built_in">arguments</span>, vm, <span class="string">`v-on handler`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  invoker.fns = fns</span><br><span class="line">  <span class="keyword">return</span> invoker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="更新事件"><a href="#更新事件" class="headerlink" title="更新事件"></a>更新事件</h4><ul>
<li>遍历新的事件对象，如果旧的有该事件，比较新旧 事件的回调函数是否相同，如果不同，那么执行 <code>old.fns = cur</code>，改变旧的<code>invoker.fns</code> 为新的回调函数，这样就可以直接改变真正执行的函数中的fns，<code>on[name] = old</code>，保存旧的invoker 到 新的 vnode.data.on 事件对象上。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  on: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldOn: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  add: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  remove: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (name <span class="keyword">in</span> on) &#123;</span><br><span class="line">    def = cur = on[name]</span><br><span class="line">    old = oldOn[name]</span><br><span class="line">    event = normalizeEvent(name)</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__ &amp;&amp; isPlainObject(def)) &#123;</span><br><span class="line">      cur = def.handler</span><br><span class="line">      event.params = def.params</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(cur)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Invalid handler for event "<span class="subst">$&#123;event.name&#125;</span>": got `</span> + <span class="built_in">String</span>(cur),</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(old)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(cur.fns)) &#123;</span><br><span class="line">        cur = on[name] = createFnInvoker(cur, vm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isTrue(event.once)) &#123;</span><br><span class="line">        cur = on[name] = createOnceHandler(event.name, cur, event.capture)</span><br><span class="line">      &#125;</span><br><span class="line">      add(event.name, cur, event.capture, event.passive, event.params)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur !== old) &#123;</span><br><span class="line">      old.fns = cur  <span class="comment">//invoker中执行的函数</span></span><br><span class="line">      on[name] = old</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> oldOn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(on[name])) &#123;</span><br><span class="line">      event = normalizeEvent(name)</span><br><span class="line">      remove(event.name, oldOn[name], event.capture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
add(event.name, cur, event.capture, event.passive, event.params) =&gt;<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(name, handler, supportsPassive? &#123; capture, passive &#125;: capture)</span><br></pre></td></tr></table></figure></li>
<li>遍历 旧的事件对象，如果新的事件对象上未定义，那么就删去 监听事件 <code>target.removeEventListener</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listener 必须为先前定义的同一个事件回调函数</span></span><br><span class="line"><span class="built_in">document</span>.removeEventListener(name, handler, capture);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入的data参数</span></span><br><span class="line">&#123;</span><br><span class="line">  on: &#123;<span class="string">"select"</span>: selectHandler&#125;,</span><br><span class="line">  nativeOn: &#123;<span class="string">"click"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;  <span class="comment">//native 只用在component上</span></span><br><span class="line">      $event.preventDefault();</span><br><span class="line">      <span class="keyword">return</span> clickHandler($event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成组件占位vnode时，并传入listeners<br>在vnode中</p>
<ul>
<li>listeners = data.on 保存自定义事件</li>
<li>data.on = data.nativeOn ，来初始化DOM事件 通过 updateDomListener来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateComponent</span></span><br><span class="line"><span class="keyword">var</span> listeners = data.on;</span><br><span class="line">    <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">    <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">    data.on = data.nativeOn;</span><br><span class="line"><span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      (<span class="string">"vue-component-"</span> + (Ctor.cid) + (name ? (<span class="string">"-"</span> + name) : <span class="string">''</span>)),</span><br><span class="line">      data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">      &#123; <span class="attr">Ctor</span>: Ctor, <span class="attr">propsData</span>: propsData, <span class="attr">listeners</span>: listeners, <span class="attr">tag</span>: tag, <span class="attr">children</span>: children &#125;, <span class="comment">//componentOptions</span></span><br><span class="line">      asyncFactory</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>是在 patch的过程中，生成 组件占位符vnode vue实例的过程中，执行了 vue.init</p>
<ul>
<li>首先是合并options，其中 opts 即 vm.$options  <code>vm.$options._parentListeners = vnode.componentOptions.listeners</code></li>
</ul>
<p><code>vnodeComponentOptions = parentVnode.componentOptions</code><br><code>opts._parentListeners = vnodeComponentOptions.listeners</code>就是用户自定义的事件</p>
<ul>
<li><p>initEvents(vm) 就是对自定义事件的实现，同样调用updateComponentListeners(<strong>vm.$options._parentListeners</strong>) <code>target = vm;</code>-&gt; updateListeners但是传入的add和remove方法不同，分别执行 target.$on(event, fn)，target.$off(event, fn)</p>
<ul>
<li><p>target.$on(event, fn) ，存储 event（事件名）事件，fn（回调函数invoker） 到  <strong>vm._events[event]</strong>，通过调用 Vue.prototype.$emit 来遍历执行 <code>vm._events[event]</code>中的回调函数。</p>
</li>
<li><p>target.$emit,根据event名，遍历 <code>vm._events[event]</code>，来执行所对应的所有回调函数</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initEvent() 只处理 组件事件</span></span><br><span class="line"><span class="keyword">var</span> listeners = vm.$options._parentListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">      updateComponentListeners(vm, listeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">    target.$on(event, fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">          vm.$on(event[i], fn);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (vm._events[event] || (vm._events[event] = [])).push(fn);</span><br><span class="line">        <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">        <span class="comment">// instead of a hash lookup</span></span><br><span class="line">        <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">          vm._hasHookEvent = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">    target.$off(event, fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// all</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">        vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> vm</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// array of events</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">1</span> = <span class="number">0</span>, l = event.length; i$<span class="number">1</span> &lt; l; i$<span class="number">1</span>++) &#123;</span><br><span class="line">          vm.$off(event[i$<span class="number">1</span>], fn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vm</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// specific event</span></span><br><span class="line">      <span class="keyword">var</span> cbs = vm._events[event];</span><br><span class="line">      <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">        <span class="keyword">return</span> vm</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">        vm._events[event] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> vm</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// specific handler</span></span><br><span class="line">      <span class="keyword">var</span> cb;</span><br><span class="line">      <span class="keyword">var</span> i = cbs.length;</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        cb = cbs[i];</span><br><span class="line">        <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">          cbs.splice(i, <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//emit</span></span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">const</span> info = <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        invokeWithErrorHandling(cbs[i], vm, args, vm, info)<span class="comment">//执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新方式和dom events 相同，都是比较新旧 listeners对象，只是添加和移除事件的方式不同</p>
<p><strong>对于父子组件通信的理解</strong></p>
<blockquote>
<p> <code>this.$emit</code>是 子组件抛出事件。在实现父子组件的通信时通常都这么写。</p>
</blockquote>
<p><code>&lt;child @select=&quot;selectHandler&quot; @click.native.prevent=&quot;clickHandler&quot;&gt;&lt;/child&gt;</code>。<br> native表示像原生事件一样通过addEventListener实现</p>
<blockquote>
<p>其实是 组件 将事件注册在了占位符组件的 componentOptions.listeners 上，在组件实例化的过程中，占位符vnode 注册的事件通过options，注册到组件的vue实例上<code>vm.$options._parentListeners</code>，然后生成回调函数绑定在 <code>vm._events[event]</code>。在组件执行 this.$emit函数时，其实是执行了 自身 vue实例上的 中的回调函数。但是 回调函数是在父组件定义的，执行的环境还是在 父组件中。在当前例子中，当子组件的 button 被点击了，它通过 this.$emit(‘select’) 派发事件，那么子组件的实例就监听到了这个 select 事件，并执行它的回调函数————定义在父组件中的 selectHandler 方法，这样就相当于完成了一次父子组件的通讯。</p>
</blockquote>
<blockquote>
<p>render 生成的render函数开头是 with(this),用来绑定内部的作用域，所以在任何数据时，都是在当前作用域下取值，在调用 <code>vnode = render.call(vm._renderProxy, vm.$createElement)</code>传入了<code>vm._renderProxy</code>，在生产环境下 <code>vm._renderProxy = vm</code>,所以在子组件触发事件，调用父组件提供的回调函数时，其作用域还是父组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;_c(<span class="string">'child'</span>,&#123;<span class="attr">on</span>:&#123;<span class="string">"myclick"</span>:mycb&#125;)&#125;</span><br><span class="line"><span class="comment">// 取 mycb，其实就是 this.mycb ，也就是在当前 vm 取mycb</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>vue实例下的 methods中的方法都在 initState的过程中被绑定到了vue实例vm上，可以通过vm.methodName 直接访问 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'&lt;button @click="clickHandler($event)"&gt;'</span> +</span><br><span class="line">  <span class="string">'click me'</span> +</span><br><span class="line">  <span class="string">'&lt;/button&gt;'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandler(e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Button clicked!'</span>, e)</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'select'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target.$off(event, fn)</code><br><code>vm._events[event] = null</code>,从vm实例的 <code>_events[event]</code>数组中删去该回调函数</li>
</ul>
<h3 id="dom-事件-和-component-事件-的区别"><a href="#dom-事件-和-component-事件-的区别" class="headerlink" title="dom 事件 和 component 事件 的区别"></a>dom 事件 和 component 事件 的区别</h3><ol>
<li>初始化的时间不同，dom是在patch创建dom时，调用created钩子函数时；component事件是在生成组件实例的初始化过程</li>
<li>实现方式不同，dom是通过原生的addEventListener添加事件；component事件是通过将回调函数挂载在vm实例上，并配合$emit实现</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>7.编译</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/7.%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>参考：<a href="https://segmentfault.com/a/1190000015848917" target="_blank" rel="noopener">Vue源码解读之AST语法树（一）</a></p>
<h2 id="不同平台下的-文件的布局-和-柯里化"><a href="#不同平台下的-文件的布局-和-柯里化" class="headerlink" title="不同平台下的 文件的布局 和 柯里化"></a>不同平台下的 文件的布局 和 柯里化</h2><p>对于 web平台 ，运行的是 web平台下的 <code>entry-runtime-with-compiler</code>，所以该平台下的 编译生成 render 函数 的方法和 weex平台下时不同的，那么如何做到区分，就需要函数柯里化</p>
<a id="more"></a>
<ul>
<li>编译相关的 核心公用代码 放在了 compiler 目录下 ，不同平台下的差异文件放在了 platform 文件夹下 的 web或者weex 文件夹中</li>
<li>不同的平台有不同的 配置信息，通过函数柯里化 将 配置信息 baseOptions 传入到编译 函数中保留 ，避免了还需要执行 判断平台相关的代码，提高了性能</li>
<li>利用函数柯里化技巧把baseCompile函数抽出来，把真正编译的过程和其他逻辑如对编译配置处理、缓存处理等剥离开<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//web</span></span><br><span class="line">compileToFunctions(template,option) </span><br><span class="line"></span><br><span class="line"><span class="comment">//web</span></span><br><span class="line">&#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="comment">//编译核心 </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompilerCreator</span>(<span class="params">baseCompile</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompiler</span>(<span class="params">baseOptions</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> finalOptions = <span class="built_in">Object</span>.create(baseOptions)</span><br><span class="line">            <span class="keyword">const</span> compiled = baseCompile(template.trim(), finalOptions) <span class="comment">// 编译</span></span><br><span class="line">            <span class="keyword">return</span> compiled</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            compile,</span><br><span class="line">            compileToFunctions: createCompileToFunctionFn(compile)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompileToFunctionFn</span> (<span class="params">compile</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span>) </span>&#123;<span class="comment">//入口</span></span><br><span class="line">        <span class="keyword">const</span> compiled = compile(template, options)</span><br><span class="line">        <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>大概就是这么个意思</p>
<ul>
<li>createCompilerCreator 将 编译的核心 baseCompile 与 配置处理部分 分离出来,并返回createCompiler 方法</li>
<li>执行 createCompiler(baseOption) 传入平台相关的配置信息，将这些 baseOption 通过闭包的形式 传递到 compile() 方法，返回 compiler complieToFunctions<ul>
<li>createCompiler 里的 createCompileToFunctionFn(compile),返回 complieToFunctions 这个就是编译的入口，</li>
</ul>
</li>
<li>complieToFunctions(template,options,vm)</li>
</ul>
<blockquote>
<p>complieToFunctions 对传入编译的配置做处理，compiler主要是为了合并baseOptions与传入的 options， baseCompile 才是真正的编译核心</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;  <span class="comment">//编译核心</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)  <span class="comment">// ast 树</span></span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options) <span class="comment">//优化</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)  <span class="comment">//生成代码</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompilerCreator</span>(<span class="params">baseCompiler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompiler</span>(<span class="params">baseOptions</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template,options</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//合并配置 baseOptions 以及 options</span></span><br><span class="line">            baseCompiler(template)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            compile,</span><br><span class="line">            complieToFunctions:createCompileToFunctionFn(compile)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompileToFunctionFn</span>(<span class="params">compile</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">complieToFunctions</span>(<span class="params">template,options,vm</span>)</span>&#123;</span><br><span class="line">        compile(template,options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core</span></span><br><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(baseCompiler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//platform</span></span><br><span class="line">&#123;</span><br><span class="line">    compile,</span><br><span class="line">    complieToFunctions</span><br><span class="line">&#125; = createCompiler(baseOptions)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">complieToFunctions(template,options,vm)</span><br></pre></td></tr></table></figure>

<h2 id="parse-解析-gt-生成抽象语法树-AST"><a href="#parse-解析-gt-生成抽象语法树-AST" class="headerlink" title="parse 解析 =&gt; 生成抽象语法树 AST"></a>parse 解析 =&gt; 生成抽象语法树 AST</h2><h3 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h3><p>维护一个 stack 栈</p>
<h3 id="匹配一个标签起始"><a href="#匹配一个标签起始" class="headerlink" title="匹配一个标签起始"></a>匹配一个标签起始</h3><ul>
<li>parseStartTag  获取节点信息</li>
<li>handleStartTag 处理节点信息<br>advance(commentLength)</li>
</ul>
<h4 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag()"></a>parseStartTag()</h4><p>对于开始标签，除了标签名之外，还有一些标签相关的属性。函数先通过正则表达式 startTagOpen 匹配到开始标签，然后定义了 match 对象，接着循环去匹配开始标签中的属性并添加到 match.attrs 中，直到匹配的开始标签的闭合符结束。如果匹配到闭合符，则获取一元斜线符，前进到闭合符尾，并把当前索引赋值给 match.end。</p>
<h4 id="handleStartTag"><a href="#handleStartTag" class="headerlink" title="handleStartTag()"></a>handleStartTag()</h4><p>handleStartTag 的核心逻辑很简单，先判断开始标签是否是一元标签，类似 <img>、<br/> 这样，接着对 match.attrs 遍历并做了一些处理，最后判断如果非一元标签，则<strong>往 stack 里 push 一个对象</strong>，并且把 tagName 赋值给 lastTag。最后调用 options.start 函数创建 ast节点</p>
<p><code>stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end })</code></p>
<h4 id="start-创建-ast节点"><a href="#start-创建-ast节点" class="headerlink" title="start 创建 ast节点"></a>start 创建 ast节点</h4><ul>
<li>index 当前位置</li>
<li>last 上一次的html文本 </li>
<li>lastTag 上一次的标签</li>
</ul>
<p>创建 AST 元素</p>
<ul>
<li><p>root ast树的根节点</p>
</li>
<li><p>currentOarent = 当前 ast节点</p>
</li>
<li><p>stack</p>
</li>
<li><p>ast  存储一个ast节点的信息</p>
<ul>
<li>type <ul>
<li>1 : 普通元素</li>
<li>2 ：表达式文本</li>
<li>3 ： 纯文本节点</li>
</ul>
</li>
<li>tag</li>
<li>attrsList : [] 属性<ul>
<li>attrs = html.match(attribute)<ul>
<li>name</li>
<li>value</li>
<li>start :index</li>
<li>end</li>
</ul>
</li>
</ul>
</li>
<li>attrsMap : {name : value} </li>
<li>attrs :[{name : attr}]</li>
<li>parent</li>
<li>children</li>
<li>start : index</li>
<li>unarySlash : 一元标签 ‘/‘</li>
<li>end </li>
</ul>
</li>
</ul>
<p>处理 AST 元素</p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul>
<li>if</li>
<li>ifConditions</li>
<li>else</li>
<li>else if<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4></li>
<li>for items  obj<code>(item,index) in items //数组 (value,name,index) in obj //对象</code></li>
<li>alias item value</li>
<li>iterator1 : index name</li>
<li>iterators : index<h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4></li>
<li><strong>events</strong>: {type：value}</li>
</ul>
<p>AST 树管理</p>
<p>更新 currentParent 和 stack ，判断当前如果不是一个一元标签，我们要把它生成的 AST 元素 push 到 stack 中，并且把当前的 AST 元素赋值给 currentParent。</p>
<p>如果是一元标签 执行 closeElement<br>判断如果有 currentParent，会把当前 AST 元素 push 到 currentParent.chilldren 中，同时把 AST 元素的 parent 指向 currentParent。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">currentParent.children.push(element) <span class="comment">//建立树父子关系</span></span><br><span class="line">element.parent = currentParent</span><br></pre></td></tr></table></figure>
<p>如果不是一元标签，维护一个ast stack 栈  不是一元标签 会把 <strong>ast节点</strong> push进去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">currentParent = element <span class="comment">//currentParent闭包保存</span></span><br><span class="line">stack.push(element)</span><br></pre></td></tr></table></figure>

<h3 id="匹配到一个标签闭合"><a href="#匹配到一个标签闭合" class="headerlink" title="匹配到一个标签闭合"></a>匹配到一个标签闭合</h3><p>parseEndTag<br>匹配后把栈到 pos 位置的都弹出，最后调用了 options.end 回调函数，并传入一些参数，并从 stack 尾部拿到 lastTag。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.end(stack[i].tag, start, end)</span><br><span class="line"></span><br><span class="line">lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].tag</span><br></pre></td></tr></table></figure>

<ul>
<li>检查标签是否匹配  出栈</li>
<li>end()  -&gt; closeElement()  建立父子关系 -&gt; end() 出栈 </li>
</ul>
<p>变量 stack， 匹配标签的 开始和结尾</p>
<h4 id="执行-end-方法"><a href="#执行-end-方法" class="headerlink" title="执行 end 方法"></a>执行 end 方法</h4><p>把 stack 最后一个元素赋值给 currentParent，这样就保证了当遇到闭合标签的时候，可以正确地更新 stack 的长度以及 currentParent 的值，这样就维护了整个 AST 树</p>
<ul>
<li>更新 end的位置</li>
<li>ast stack 出栈</li>
<li>closeElement <ul>
<li>processElement<ul>
<li>processAttrs 事件的处理</li>
</ul>
</li>
<li>currentParent.children.push(element); 父亲建立与 儿子的联系</li>
<li>element.parent = currentParent; 儿子建立与 父亲的联系</li>
</ul>
</li>
<li>stack 出栈</li>
<li>更新 lastTag </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = stack[stack.length - <span class="number">1</span>]</span><br><span class="line">      <span class="comment">// pop stack</span></span><br><span class="line">      stack.length -= <span class="number">1</span></span><br><span class="line">      currentParent = stack[stack.length - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="匹配文本"><a href="#匹配文本" class="headerlink" title="匹配文本"></a>匹配文本</h3><p>接下来判断 textEnd 是否大于等于 0 的，满足则说明到从当前位置到 textEnd 位置都是文本，并且如果 &lt; 是纯文本中的字符，就继续找到真正的文本结束的位置，然后前进到结束的位置。</p>
<p>再继续判断 textEnd 小于 0 的情况，则说明整个 template 解析完毕了，把剩余的 html 都赋值给了 text。</p>
<p>最后调用了 options.chars 回调函数 创建ast节点，并传 text 参数</p>
<ul>
<li><p>处理空字符串 直接跳过</p>
</li>
<li><p>parseText : 把 <code> :</code> 类似于这样的文本 解析为 render函数中的 语句  <code>_s(item.val)+&quot; :&quot;+_s(item.id)</code></p>
</li>
<li><p>生成 AST 节点</p>
<ul>
<li>type: 2,  //表达式 <code>&lt;p&gt;&lt;/p&gt;</code></li>
<li>expression: res.expression, // <code>_s(item.val)+&quot; :&quot;+_s(item.id)</code></li>
<li>tokens: res.tokens, [_s(item.val),’”:”‘,_s(item.id)]</li>
<li>text: text </li>
<li>start</li>
<li>end</li>
</ul>
</li>
<li><p>纯文本 AST 节点 </p>
<ul>
<li>type: 3, //纯文本节点 <code>&lt;p&gt;123&lt;/p&gt;</code> 中的 123 </li>
<li>text: text</li>
</ul>
</li>
<li><p>AST 节点 push 到 currentParent.children </p>
</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>phasingTag  能放在p标签里面的 元素</p>
<p>如果 p 标签中放了 notphasingTag，那么在编译的过程中，会把标签拿出来</p>
<p><code>&lt;p&gt;&lt;div&gt;123&lt;/div&gt;&lt;/p&gt;</code> =&gt; <code>&lt;p&gt;&lt;/p&gt; &lt;div&gt;123&lt;/div&gt; &lt;p&gt;&lt;/p&gt;</code></p>
<p><code>&lt;/br&gt;</code> =&gt; <code>&lt;br&gt;</code></p>
<p><code>&lt;p&gt;123&lt;p&gt;321&lt;/p&gt;&lt;/p&gt;</code> =&gt; <code>&lt;p&gt;123&lt;/p&gt; &lt;p&gt;321&lt;/p&gt; &lt;p&gt;&lt;/p&gt;</code></p>
<p><code>&lt;p&gt;&lt;p&gt;321&lt;/p&gt;123&lt;/p&gt;</code> =&gt; <code>&lt;p&gt;&lt;/p&gt;&lt;p&gt;321&lt;/p&gt;&quot;123&quot;&lt;p&gt;&lt;/p&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleStartTag &lt;p&gt;&lt;div&gt;</span></span><br><span class="line"><span class="keyword">if</span> (expectHTML) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastTag === <span class="string">'p'</span> &amp;&amp; isNonPhrasingTag(tagName)) &#123;</span><br><span class="line">        parseEndTag(lastTag)  <span class="comment">//把 p 出栈</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (canBeLeftOpenTag(tagName) &amp;&amp; lastTag === tagName) &#123;</span><br><span class="line">        parseEndTag(tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//parseEndTag &lt;/p&gt;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (lowerCasedTagName === <span class="string">'br'</span>) &#123;  <span class="comment">// &lt;/br&gt; =&gt; &lt;br&gt;</span></span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], <span class="literal">true</span>, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCasedTagName === <span class="string">'p'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], <span class="literal">false</span>, start, end) <span class="comment">//currentParent 添加新 children AST节点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (options.end) &#123;</span><br><span class="line">        options.end(tagName, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="报错情况"><a href="#报错情况" class="headerlink" title="报错情况"></a>报错情况</h3><ul>
<li>一个 template 不止一个根节点</li>
<li>一个 template 没有 根节点</li>
<li>文本在根节点外面</li>
<li>包含 <code>&lt;script&gt;</code> 标签</li>
</ul>
<h2 id="optimize-优化"><a href="#optimize-优化" class="headerlink" title="optimize 优化"></a>optimize 优化</h2><p>为静态节点打上标记 使 patch 跳过 对 非响应式数据的比对</p>
<p>为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。</p>
<h3 id="markStatic"><a href="#markStatic" class="headerlink" title="markStatic"></a>markStatic</h3><p>AST元素节点是否静态 isStatic</p>
<ul>
<li>false <ul>
<li>node.type === 2 表达式</li>
</ul>
</li>
<li>true<ul>
<li>node.type === 3 纯文本</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span> (<span class="params">node: ASTNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123; <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123; <span class="comment">// text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !!(node.pre || (</span><br><span class="line">    !node.hasBindings &amp;&amp; <span class="comment">// no dynamic bindings</span></span><br><span class="line">    !node.if &amp;&amp; !node.for &amp;&amp; <span class="comment">// not v-if or v-for or v-else</span></span><br><span class="line">    !isBuiltInTag(node.tag) &amp;&amp; <span class="comment">// not a built-in</span></span><br><span class="line">    isPlatformReservedTag(node.tag) &amp;&amp; <span class="comment">// not a component</span></span><br><span class="line">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.keys(node).every(isStaticKey)</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归 node.children 和 v-if-else条件 进行 static 判断，一旦子节点有不是 static 的情况，则它的父节点的 static 均变成 false</p>
<h3 id="markStaticRoots"><a href="#markStaticRoots" class="headerlink" title="markStaticRoots"></a>markStaticRoots</h3><p>node.type === 1 才有 staticRoot属性</p>
<ul>
<li>true<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">  node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">  node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>false 上面情况的 else</li>
</ul>
<p>递归遍历 node.children 和 v-if-else条件 进行 staticRoot 判断</p>
<p><strong>如果 children 的 staticRoot 为 false，那么父亲也需要设置为 false</strong></p>
<h2 id="genCode"><a href="#genCode" class="headerlink" title="genCode"></a>genCode</h2><p>把优化后的 AST 树转换成可执行的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ast: ASTElement | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CodegenResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? genElement(ast, state) : <span class="string">'_c("div")'</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,  <span class="comment">//with(this) 保证this执行当前渲染watcher的vm实例</span></span><br><span class="line">    staticRenderFns: state.staticRenderFns <span class="comment">// staticRoot</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将生成的 字符串转化为函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span> (<span class="params">code, errors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errors.push(&#123; err, code &#125;)</span><br><span class="line">    <span class="keyword">return</span> noop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="genElement"><a href="#genElement" class="headerlink" title="genElement"></a>genElement</h4><ul>
<li>genStatic </li>
<li>genOnce</li>
<li>genFor -&gt; <strong>forProcessed=true</strong> genElement -&gt;</li>
<li>genIf …</li>
<li>genChildren</li>
<li>genSlot</li>
<li>genComponent</li>
<li>genData</li>
</ul>
<p>-&gt; data -&gt; genChildren -&gt; genNode -&gt; </p>
<ul>
<li>node.type<ul>
<li>genElement</li>
<li>genComment</li>
<li>genText</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target._o = markOnce</span><br><span class="line"> target._n = toNumber</span><br><span class="line"> target._s = toString</span><br><span class="line"> target._l = renderList</span><br><span class="line"> target._t = renderSlot</span><br><span class="line"> target._q = looseEqual</span><br><span class="line"> target._i = looseIndexOf</span><br><span class="line"> target._m = renderStatic</span><br><span class="line"> target._f = resolveFilter</span><br><span class="line"> target._k = checkKeyCodes</span><br><span class="line"> target._b = bindObjectProps</span><br><span class="line"> target._v = createTextVNode</span><br><span class="line"> target._e = createEmptyVNode</span><br><span class="line"> target._u = resolveScopedSlots</span><br><span class="line"> target._g = bindObjectListeners</span><br><span class="line"> target._d = bindDynamicKeys</span><br><span class="line"> target._p = prependModifiers</span><br><span class="line"></span><br><span class="line"> _c = createElement</span><br></pre></td></tr></table></figure>

<h4 id="genIf"><a href="#genIf" class="headerlink" title="genIf"></a>genIf</h4><h4 id="genFor"><a href="#genFor" class="headerlink" title="genFor"></a>genFor</h4><h4 id="genData"><a href="#genData" class="headerlink" title="genData"></a>genData</h4><p>根据 AST 元素节点的属性构造出一个 data 对象字符串，这个在后面创建 VNode 的时候的时候会作为参数传入。</p>
<h4 id="genChildren"><a href="#genChildren" class="headerlink" title="genChildren"></a>genChildren</h4><ul>
<li>genElement</li>
<li>genText</li>
<li>genComment</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>4.数据响应</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/4.%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<p>Vue源码中实现依赖收集，实现了三个类：<br><img src="http://103.14.34.148:9000/imgs/blog/img/a.png" alt=""></p>
<ul>
<li>Dep：扮演观察目标的角色，每一个数据都会有Dep类实例，它内部有个subs队列，subs就是subscribers的意思，保存着依赖本数据的观察者，当本数据变更时，调用dep.notify()通知观察者</li>
<li>Watcher：扮演观察者的角色，进行观察者函数的包装处理。如render()函数，会被进行包装成一个Watcher实例</li>
<li>Observer：辅助的可观测类，数组/对象通过它的转化，可成为可观测数据<br>参考：<a href="https://ruphi.cn/archives/336/" target="_blank" rel="noopener">Vue依赖收集原理</a>  </li>
</ul>
<a id="more"></a>



<h2 id="创建响应式对象"><a href="#创建响应式对象" class="headerlink" title="创建响应式对象"></a>创建响应式对象</h2><p>init =&gt; initState =&gt; initData =&gt; observe =&gt; new Observer()</p>
<blockquote>
<p>initState 包含了对 data props methods computed watch</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        msg:<span class="string">''</span>,</span><br><span class="line">        show:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 value 为 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    msg:<span class="string">''</span>,</span><br><span class="line">    show:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 value 对象 上定义 <code>__ob__</code> 属性，来保存当前数据的 Observer实例<ul>
<li>创建 Dep 对象，其中 subs 数组 来保存该数据的所有watcher</li>
</ul>
</li>
<li>walk 遍历 value<ul>
<li>value 中的每一个属性，都执行 defineReactive =&gt; oberve() 重复上述步骤，直到value不再是一个对象或Vnode</li>
<li>为每一个属性 defineProperty() 定义 setter getter方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>用户自定义watcher在init阶段就生成了，而渲染watcher是在 mount过程中生成，所以用户自定义的 watcher id 小于 渲染 watcher<br><img src="http://103.14.34.148:9000/imgs/blog/img/%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E8%A7%82%E6%B5%8B.png" alt="配置依赖观测"></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 不是对象 或 是 vnode*/</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Observe(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">// Observe.dep</span></span><br><span class="line">    value.__ob__ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*数组*/</span>)&#123;</span><br><span class="line">        <span class="comment">//处理数组</span></span><br><span class="line">        <span class="comment">//数组添加增强后的 会改变原数组的操作（pop，push，shift，unshift，reverse，sort，splice）</span></span><br><span class="line">        <span class="keyword">this</span>.observeArray(value);<span class="comment">//数组没有defineReactive的操作 </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observe.prototype.walk = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 value 的每一个属性</span></span><br><span class="line">    defineReactive(value,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep() <span class="comment">//闭包dep</span></span><br><span class="line">    childob = observe(obj[key]);</span><br><span class="line">    <span class="comment">//定义 getter settter</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;  <span class="comment">//判断是否在渲染阶段</span></span><br><span class="line">        dep.depend() <span class="comment">// 对象内容（数据）闭包dep 的依赖收集</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()  <span class="comment">//  如果属性的值是个对象就要对其 对象 __ob__.dep 进行依赖收集 针对 数组和对象增加 删除属性</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal) <span class="comment">// 如果是对象，则响应式</span></span><br><span class="line">      dep.notify() <span class="comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p><img src="http://103.14.34.148:9000/imgs/blog/img/%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96.png" alt="收集依赖"></p>
<ul>
<li>在创建响应式对象Observer实例，其中创建的Dep对象用来保存 data 和 watcher 之间的依赖关系</li>
<li>在渲染的过程中，实例化watcher对象的构造函数中会执行 <code>watcher.get()</code>，生成的渲染watcher对象会在 将全局遍历Dep.targer设为自身，（在targetStack栈中保存递归调用生成的watcher），接着执行 <code>watcher.getter</code>,也就是（<code>vm._update(vm._render())</code>）,</li>
<li>render的过程 中触发数据 data 的 getter方法，（也就是在initData中通过 defineProperty 绑定的get方法）,执行 <code>dep.depend()</code> 会将当前数据的 Dep 实例中的 subs 数组中添加 watcher （订阅者）。watcher实例中 deps数组会添加 dep 对象（用于比较 新旧 dep）<ul>
<li>cleanupDeps，根据 watcher 中保存的 新旧 deps，如果新添加的dep在旧deps中不存在，就要删除 当前旧dep.subs 中的 当前watcher，这样就不会触发不必要的更新</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dep 对象</span></span><br><span class="line">depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher 对象</span></span><br><span class="line">  <span class="keyword">get</span> () &#123; <span class="comment">//依赖收集</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)  <span class="comment">//修改 Dep.Target</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)  <span class="comment">//渲染dom   watcher key值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;  <span class="comment">// 深度遍历对象</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">cleanupDeps () &#123;  <span class="comment">// 删除新页面中不会再用到的 watcher</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __ob__, <span class="comment">// Observer类的实例，里面保存着Dep实例__ob__.dep =&gt; dep(uid:0)</span></span><br><span class="line">    a: <span class="number">1</span>,   <span class="comment">// 在闭包里存在dep(uid:1)</span></span><br><span class="line">    b: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="comment">// 在闭包里存在着dep(uid:2)，还有b.__ob__.dep =&gt; dep(uid:4)</span></span><br><span class="line">    c: &#123;</span><br><span class="line">        __ob__, <span class="comment">// Observer类的实例，里面保存着Dep实例__ob__.dep =&gt; dep(uid:5)</span></span><br><span class="line">        d: <span class="number">5</span> <span class="comment">// 在闭包里存在着dep(uid:6)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在对 c 执行 defineReactive时，会生成一个 c 的 闭包dep</li>
<li>然后对其值 <code>{d:5}</code>执行observe方法，生成一个Observe实例挂载在 <code>c.__ob__</code></li>
<li>在进行依赖收集，执行 c 的get方法时，不仅为闭包dep进行依赖收集，也为c的observe实例的dep进行依赖收集</li>
<li>闭包dep，在c的值发生改变时触发set方法时，会执行 闭包dep的notify</li>
<li>如果通过 Vue.set 为c的值这个对象添加一个属性，不会触发c的set方法，但是会通过 <code>c.__ob__.dep</code> 来触发notify。如果在c进行依赖收集时，没有为<code>c.__ob__</code>进行依赖收集，那么就不会触发相关watcher的更新</li>
</ol>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/%E6%95%B0%E6%8D%AE%E5%80%BC%E5%8F%98%E6%9B%B4.png" alt="数据值变更"></p>
<blockquote>
<p>为什么对于对象，配置依赖观测后，会实例化两个Dep类实例呢？<br>这是因为：对象，都是引用类型数据，对于引用类型数据，存在两种操作：改变引用和改变内容.</p>
</blockquote>
<blockquote>
<p>对象，改变引用 修改某一个属性，通过 闭包dep 来派发更新 ;对其增加 删除某一属性,通过 <code>__ob__</code> 来派发更新</p>
</blockquote>
<blockquote>
<p>数组，都需要通过 <code>__ob__</code> 来检测，在对数组进行响应式处理时，会修改数组原型上会改变数组自身的操作，（push，pop，splice），它们会获取到插入的值，然后把新添加的值变成一个响应式对象，在执行原先操作之后，手段派发notify通知。</p>
</blockquote>
<p>一共有四个地方调用了dep.notify。</p>
<p>其中三个地方是调用了ob.dep.notify()。<br>分别是：</p>
<ol>
<li>对数组push等七个方法重写的函数中</li>
<li>set方法，为一个对象添加一个属性</li>
<li>del方法，为对象删除一个属性</li>
</ol>
<p>而闭包中的dep.notify()只是在Object.defineProperty的set方法中触发。</p>
<p>那么很清楚了，#1是闭包中的Dep，用于由对象本身修改而触发setter函数导致闭包中的Dep通知所有的Watcher对象。#2则是在对象本身增删属性或者数组变化的时候被触发的Dep。</p>
<h2 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h2><ul>
<li>当对数据进行更改时，会触发 setter方法，setter方法 会比较新旧值是否相同，不同则触发 dep.notify()。 （其中 watcher 也是按照从小到大排序）</li>
<li>dep中的 subs数组保存着与该数据相关联的 渲染 watcher，调用watcher的update方法</li>
<li>执行 queueWatcher，将需要更新的渲染watcher保存到任务队列中（防止watcher的重复渲染），等待 nextTick时统一进行更新 flushSchedulerQueue<ul>
<li>在更新的过程中会对 watcher 的 id 从小到大排序，<ol>
<li>因为组件是从父到子生成的</li>
<li>用户 watcher 总是 在 渲染 watcher 之前渲染</li>
<li>如果 父组件销毁，那么就不需要重新渲染子组件</li>
</ol>
</li>
<li>执行 watcher.run()</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watcher</span></span><br><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;   <span class="comment">//同步</span></span><br><span class="line">      <span class="keyword">this</span>.run() </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//schedule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>  <span class="comment">//防止 watcher 的多次调用</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;  </span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//正在执行中</span></span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// ** if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="comment">//由于watcher.run 运行的过程中，用户定义的回调函数出发了新的watcher</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)  <span class="comment">//异步</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//watcher</span></span><br><span class="line">run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()  <span class="comment">//得到值 触发 _update(_render())</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123; <span class="comment">// watch</span></span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue) <span class="comment">//watch update</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick()"></a>nextTick()</h2><h3 id="Vue-2-6"><a href="#Vue-2-6" class="headerlink" title="Vue 2.6"></a>Vue 2.6</h3><p>推荐使用微任务（Promise MutationObserver ）来执行 回调函数，如果浏览器不支持，最终会使用 (setImmediate setTimeout)的形式</p>
<ol>
<li>每次调用 nextTick 都会判断当前是否有 tick 在执行，当 tick 真正执行的时候会置 pending为 false，此时调用 nextTick 可以开启下一个异步任务到浏览器的任务队列。</li>
<li>如果 pending  为 false， 就只能往 callbacks 里添加回调函数</li>
<li>当 下一个 tick 开始执行时，会将 callbacks 拷贝一份执行里面的回调函数 并清空，又会将 pending 置为 false</li>
</ol>
<ul>
<li>每次调用 nextTick ， 回调函数都会被存储在 callbacks数组中，只有当上一个callbacks数组执行的异步任务在事件循环中被执行（也就是执行flushCallbacks函数，将pending = false），才能执行新的callbacks数组，将异步任务添加到事件循环中的任务队列中。在此之前所有的 回调函数都会被添加到上一个callbacks数组，等待本次 tick 执行。</li>
</ul>
<blockquote>
<p>$nextTick 回调函数在下一个事件循环中执行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>  <span class="comment">// </span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vue-2-5"><a href="#Vue-2-5" class="headerlink" title="Vue 2.5"></a>Vue 2.5</h3><p>默认使用 微任务形式，如果浏览器不支持吗，那么使用 宏任务形式<br>也会对外提供  withMacroTask ，来使用宏任务形式（用于处理一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task）</p>
<p>当某个操作触发了 nextTick 时，如果此时上一个Tick已经在执行，或者已经执行完毕，那么就可以开启本次异步Tick。在本次异步tick还没有执行前，同步操作触发的 nextTick 方法都会保存到同一个 callbacks 中，等待本次异步tick执行。</p>
<h2 id="监听对象和数组变化的特殊情况"><a href="#监听对象和数组变化的特殊情况" class="headerlink" title="监听对象和数组变化的特殊情况"></a>监听对象和数组变化的特殊情况</h2><h3 id="添加-删除-对象属性"><a href="#添加-删除-对象属性" class="headerlink" title="添加 删除 对象属性"></a>添加 删除 对象属性</h3><p>Vue.set </p>
<ul>
<li>数组 -&gt; splice -&gt; 触发修改后的数组原生方法 -&gt; notify</li>
<li>对象<ul>
<li>有该键值 直接修改</li>
<li>没有 添加该属性<ul>
<li>获取该对象的 observer 对象<ul>
<li>不是响应式对象 直接返回</li>
</ul>
</li>
<li>将该属性变为响应式数据 defineReactive(ob.value, key, val) ,（在使用的时候会调用 getter 来进行赋值）</li>
<li>ob.dep.notify 手动触发更新<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key);</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ob = (target).__ob__;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val);</span><br><span class="line">  ob.dep.notify();</span><br></pre></td></tr></table></figure>
Vue.delete</li>
</ul>
</li>
</ul>
</li>
<li>数组 -&gt; splice -&gt; 触发修改后的数组原生方法 -&gt; notify</li>
<li>对象<ul>
<li>没有该键值 直接返回</li>
<li>有 删除该属性<ul>
<li>获取该对象的 observer 对象<ul>
<li>不是响应式对象 直接返回</li>
</ul>
</li>
<li><code>delete target[key]</code></li>
<li>ob.dep.notify 手动触发更新<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.splice(key, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ob = (target).__ob__;</span><br><span class="line"><span class="keyword">if</span> (!hasOwn(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> target[key];</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="修改数组内的-数据"><a href="#修改数组内的-数据" class="headerlink" title="修改数组内的 数据"></a>修改数组内的 数据</h3><p>数组是不能直接通过赋值来修改数组内的数据，因为 他没有为每一个值执行 defineReactive 设置 getter setter 方法</p>
<ul>
<li>Vue.set  当你利用索引直接设置一个项时Vue.set(arr,index,value) 或 splice(start,1,value)</li>
<li>数组原生方法<br>数组，都需要通过 <code>__ob__</code> 来检测，在对数组进行响应式处理时，会修改数组原型上会改变数组自身的操作，（push，pop，splice…），它们会获取到插入的值，然后把新添加的值变成一个响应式对象，在执行原先操作之后，手段派发notify通知。</li>
</ul>
<p>在为数组生成 Observe对象实例 时，会将 arrayMethods 作为数组的原型添加上去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted) <span class="comment">//对于插入操作 push unshift splice,对插入的数据进行响应式处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="proxy-代理-与-defineProperty"><a href="#proxy-代理-与-defineProperty" class="headerlink" title="proxy 代理 与 defineProperty"></a>proxy 代理 与 defineProperty</h3><ol>
<li>proxy是直接代理一个对象，defineProperty需要为对象的每一个属性设置get、set方法</li>
<li>proxy 可以直接 <code>target[key]</code> 返回原对象的值，而 defineProperty 需要从其他保存值的地方取值</li>
<li>proxy 可以直接识别 为一个对象添加属性的操作 ，而 defineProperty 需要通过 Vue.set方法添加响应式属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">      <span class="comment">// 如果receiver === target，表明proxy处于被赋值对象的原型链上</span></span><br><span class="line">      <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set</span></span><br><span class="line">      <span class="comment">// 仅仅拦截直接对proxy的赋值操作（reactiveProxy.newProperty=newValue）</span></span><br><span class="line">      <span class="keyword">if</span> (!target.hasOwnProperty(property) &amp;&amp; receiver === proxy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">"object"</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果要赋的值也是对象，则也要拦截这个对象的赋值操作</span></span><br><span class="line">          value = createReactiveProxy(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// console.log("Vue.set ", target, property);</span></span><br><span class="line">        Vue.set(target, property, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log("Reflect.set ", target, property);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="为什么组件的data一定要是函数返回对象的形式"><a href="#为什么组件的data一定要是函数返回对象的形式" class="headerlink" title="为什么组件的data一定要是函数返回对象的形式"></a>为什么组件的data一定要是函数返回对象的形式</h3><p>因为组件是可以复用的，其中的data就是用户在定义组件时生成的data对象，如果传入的是一个对象，那么每一个组件实例都公用同一个data对象，因为是引用。</p>
<p>而如果使用函数的形式，在每生成一个组件实例时，都调用一次data方法，返回一个新的data对象，这个data是每个组件实例独享的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.data = (<span class="keyword">typeof</span> data === <span class="string">'function'</span>?data():data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> component(data)</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> component(data)</span><br><span class="line"></span><br><span class="line">c1.data === c2.data <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>5.computed和watch</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/5.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&amp;%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initState 的 过程中也会 对 computed属性进行初始化（initComputed）</p>
<ul>
<li><p>会为每一个computed里的数据生成一个 watcher实例，（其中getter属性为computed中的数据由用户定义的函数或对象的get方法）与数据响应的watcher区别在与设置了lazy属性为true，这个属性主要的作用就是在数据发生改变时不会触发notify</p>
</li>
<li><p>将 computed中的属性 部署到 vm上，可以直接通过vm来获取，并设置其getter方法，</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatch</span><br><span class="line">  ers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,  <span class="comment">//this.getter</span></span><br><span class="line">        noop,  <span class="comment">//回调 this.cb</span></span><br><span class="line">        computedWatcherOptions  </span><br><span class="line">        <span class="comment">/*包括</span></span><br><span class="line"><span class="comment">        this.deep = !!options.deep //watch</span></span><br><span class="line"><span class="comment">        this.user = !!options.user // watch computed</span></span><br><span class="line"><span class="comment">        this.lazy = !!options.lazy // computed</span></span><br><span class="line"><span class="comment">        this.sync = !!options.sync //watch</span></span><br><span class="line"><span class="comment">        this.before = options.before //watch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">//在计算watcher 中不会 执行 this.get</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      this.value = this.lazy</span></span><br><span class="line"><span class="comment">      ? undefined</span></span><br><span class="line"><span class="comment">      : this.get()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params">vm,key,userDef</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(vm,key,createComputedGetter(key)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置在 vm 上计算属性的 get 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="keyword">debugger</span>;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evaluate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() </span><br><span class="line">    <span class="comment">// watcher.get 触发 用户自定义的计算方法 其中会用到一些响应式数据，触发他们的依赖收集</span></span><br><span class="line">    <span class="comment">// 此时的 Dep.target 是计算 watcher， 响应式数据的dep.subs 中就会添加上 Dep.target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性是没有进行响应式处理的，所以没有自己的observer对象以及dep对象</span></span><br><span class="line">    <span class="comment">// 当 使用 计算属性时，会触发 计算属性的get函数（computedGetter）</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span> <span class="comment">// 表示可以使用缓存</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> () &#123; <span class="comment">//依赖收集</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)  <span class="comment">//修改 Dep.Target</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)  <span class="comment">//渲染dom   watcher key值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;  <span class="comment">// 深度遍历对象</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span> <span class="comment">//computed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;   <span class="comment">// watcher 同步</span></span><br><span class="line">      <span class="keyword">this</span>.run() </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>在调用计算属性时进行依赖收集</p>
</li>
<li><p>在进行页面的渲染时 调用 render函数，会触发 计算属性的 getter方法。主要包括</p>
<ul>
<li>计算结果，其他如果包含其他响应式数据，那么会触发他们的getter方法，将计算属性的watcher添加到他们的 subs中， 计算属性的watcher的deps中也会 添加 他们的dep。</li>
<li>建立 计算属性中所用到的 响应式数据 与 当前vm 渲染watcher的依赖关系。如果计算属性中用到其他的响应式数据，因为计算属性的没有自己的 dep对象，不能触发页面的刷新，只能通过其中响应式数据，绑定到当前的渲染watcher来进行更新。</li>
</ul>
</li>
<li><p>如果计算属性中用到其他的响应式数据，当他们发生改变时，会通知对应的watcher更新渲染，但是如果是计算属性的watcher，因为他的lazy值是true，所以不会直接像响应式数据那样 触发 notify，而是 在其他数据触发页面重新渲染的render的时候，计算出新的值。</p>
</li>
<li><p>也叫做 计算属性的缓存——lazy Watcher，</p>
<ul>
<li>因为 lazy 表示一种固定描述，不可改变，表示这个 watcher 需要缓存</li>
<li>dirty 表示缓存是否可用，如果为 true，表示缓存脏了，需要重新计算，否则不用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span>  <span class="comment">// 不会直接进行更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;   <span class="comment">//同步</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  evaluate()&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3></li>
</ul>
</li>
</ul>
<ol>
<li>相关响应式数发生变化，触发了 计算watcher的update</li>
<li>watcher.dirty = true</li>
<li>在渲染watcher需要使用该计算属性时，触发计算属性的get，因为dirty为true，所以重新计算计算属性的值，保存在watcher.value，触发了watcher.get</li>
<li>执行 用户自定义的计算方法 并更新依赖</li>
</ol>
<h3 id="2-5-版本"><a href="#2-5-版本" class="headerlink" title="2.5 版本"></a>2.5 版本</h3><ul>
<li>在2.5版本中，计算watcher中是有 Dep对象的，在依赖收集时，是将 渲染watcher 保存在自己的 watcehs.dep.subs中，所以在数据更新时，计算属性会对最后的计算结果与旧值进行比较，如果相同就不会触发页面的重新渲染。如果不同，才会触发计算watcher.dep.subs的重新渲染。虽然是一种优化，但是存在问题<ul>
<li>如果 计算属性为 a+b，如果 a++ b–，会触发两次更新，因为数据的更新是同步的，在a更新时计算 a+b，b的值其实还没有发生改变，所以会触发重新渲染，更新a+b的值；在b更新时，a+b的值又和更新后的a+b的值不同，又会触发渲染。</li>
</ul>
</li>
<li>所以2.5中又去掉了这种优化</li>
</ul>
<h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">  deep:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>initWatcher </p>
<ul>
<li>执行 $watch </li>
<li>创建一个 watcher实例， 传入 key 为 getter，用户自定义函数 为 callback，（传入 deep immediate）(option.user=true)<ul>
<li>在创建的过程中，对 key值进行解析 <ul>
<li>key 为 字符串 ，解析为 取值函数 （也就是 vm.key） （触发数据的getter）</li>
<li>函数 ，直接执行</li>
</ul>
</li>
<li>在取值的过程中，会触发响应式数据的 getter 方法 ，进行依赖收集，他们的subs中添加 当前 用户 watcher</li>
<li>如果此时 deep 为 true, 就会遍历对象或数组中的每一个属性的值，触发他们的getter，将当前 用户watcher 添加到响应式数据的dep.subs 中 </li>
</ul>
</li>
<li>如果 immediate 为 true，那么直接调用 回调函数</li>
<li>返回 取消监听的函数 </li>
</ul>
<blockquote>
<p>(如果是基本类型的数组，不会进行依赖收集，因为没有设置get方法)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,  <span class="regexp">//</span>key</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler] <span class="comment">//cb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function, <span class="regexp">//</span>key</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any, <span class="regexp">//</span>callback</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object </span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.user = <span class="literal">true</span>  <span class="comment">//user watcher</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//watcher constructor</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)  <span class="comment">// 解析</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//watcher.get()中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;  <span class="comment">// 深度遍历对象</span></span><br><span class="line">        traverse(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;     <span class="comment">//通过 取值 来触发 对象里的每一个属性的 getter</span></span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 $watch 会返回取消watcher的函数</li>
</ul>
<ul>
<li>immediate 为 true ，表示立即执行 回调函数</li>
<li>deep 为 true ，表示监测 对象内部属性的响应</li>
<li>sync 为 true ，表示 同步执行回调 </li>
</ul>
<h3 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h3><ul>
<li><p>在触发更新时，响应式数据抛出notify，执行 watcher的update<br>// * 如果此时 sync为true，会同步执行 watcher.run  即 执行 回调函数（newval,oldval）</p>
<ul>
<li>否则 将 watcher 添加到 异步队列中</li>
</ul>
</li>
<li><p>异步执行 watcher.run ，触发回调函数，需要注意如果 <strong>deep为true，即使 value值没变，也会触发回调函数</strong>。</p>
</li>
</ul>
<blockquote>
<p>如果在回调函数中 改变其他的响应式数据，触发更新，因为此时的 渲染watcher已经在queue队列中 ，所以无需再次添加</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">   <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">     <span class="keyword">this</span>.dirty = <span class="literal">true</span>  <span class="comment">// 不会直接进行更新</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;   <span class="comment">//同步</span></span><br><span class="line">     <span class="keyword">this</span>.run()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> run () &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">     <span class="keyword">const</span> value = <span class="keyword">this</span>.get()  <span class="comment">//得到值 触发 _update(_render())</span></span><br><span class="line">     <span class="keyword">if</span> ( <span class="comment">//watcher 监听</span></span><br><span class="line">       value !== <span class="keyword">this</span>.value ||</span><br><span class="line">       .</span><br><span class="line">       <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">       <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">       <span class="comment">// have mutated.</span></span><br><span class="line">       isObject(value) ||</span><br><span class="line">       <span class="keyword">this</span>.deep</span><br><span class="line">     ) &#123;</span><br><span class="line">       <span class="comment">// set new value</span></span><br><span class="line">       <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">       <span class="keyword">this</span>.value = value</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue) <span class="comment">// update</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">           handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed-amp-amp-watcher-差异"><a href="#computed-amp-amp-watcher-差异" class="headerlink" title="computed &amp;&amp; watcher 差异"></a>computed &amp;&amp; watcher 差异</h2><ul>
<li><p>computed是计算过程中的响应式数据数值发生变化，才会触发computed的重新计算，由于watcher没有回调函数，所以不需要将watcher加入到任务队列。 数据的重新计算也不是在触发数据的notify，而是在 render 需要使用该计算属性的时候</p>
</li>
<li><p>watcher 根据响应式数据的变化，触发 watcher的update 方法，其中就会把当前watcher添加到队列中，等待执行其回调函数</p>
</li>
<li><p>computed -&gt; computed watcher -&gt; 包含 lazy</p>
</li>
<li><p>watcher -&gt; user watcher -&gt; 包含 user immediate deep</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>6.组件更新</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/6.%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><ul>
<li>在响应式数据发送改变时， 会触发 订阅的 watcher 的 更新 </li>
<li>再次调用 vm._update(vm._render(),…)</li>
<li>其中会 执行 patch ，这是因为有旧的 渲染vnode，所以 会传入 <code>vm.$el = vm.__patch__(prevVnode, vnode)</code></li>
<li>在patch的过程中，会和首次渲染不同，这次会比较新旧vnode是否相同，<code>sameVnode(oldVnode, vnode)</code>，主要通过 key ，tag …判断<a id="more"></a>
<ul>
<li>如果新旧节点不同，那么就会创建新dom节点，更新父占位符节点，删除旧dom节点</li>
<li>如果相同，调用 patchVnode方法 ，比较他们的孩子节点<ul>
<li>新节点没有 text ,不是文本节点<ul>
<li>新旧节点都有 child 执行 updateChildren -&gt; diff算法</li>
<li>新节点有child，旧节点没有<ul>
<li>旧节点有text，则替换为空</li>
<li>插入新节点</li>
</ul>
</li>
<li>只有老的有child 没有新的，删除老的 child</li>
<li>如果都没有孩子节点，如果旧节点是 text，则将文本替换为空</li>
</ul>
</li>
<li>有 text ，文本节点，直接更新 文本， 进行文本替换</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; <span class="comment">//对比</span></span><br><span class="line">          <span class="comment">// patch existing root node   </span></span><br><span class="line">          patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否是相同的vnode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (  <span class="comment">// v-for :key undefined === undefined</span></span><br><span class="line">      (  <span class="comment">//普通节点</span></span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;  <span class="comment">//注释</span></span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)  <span class="comment">// </span></span><br><span class="line">      ) || (  <span class="comment">//异步占位符节点</span></span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="updateChildren-diff-算法"><a href="#updateChildren-diff-算法" class="headerlink" title="updateChildren diff 算法"></a>updateChildren diff 算法</h2><p>比较 新旧vnode的children  (updateChildren)</p>
<ol>
<li><p>比较 新旧 的 ， 如果相同 都会 执行 patchVnode</p>
<ul>
<li>两头 新旧的头指针 后移 一位</li>
<li>两尾 新旧的尾指针 前移 一位</li>
<li>老头新尾 <strong>将old start 移动到old end的后面</strong>，old start +1 ，new end -1</li>
<li>老尾新头 <strong>将old end 移动到old start的前面</strong>，old end -1 ， new start +1</li>
<li>以上均不成立，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125;</span><br><span class="line">          idxInOld = isDef(newStartVnode.key)</span><br><span class="line">            ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">          <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vnodeToMove = oldCh[idxInOld];</span><br><span class="line">            <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">              oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">              canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          newStartVnode = newCh[++newStartIdx];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, key</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>创建 key 到 数字下标的索引 {key:index}</p>
</li>
<li><p>在旧的vnode数组中查找 newStartVnode 的下标，newStartVnode没有key的话则查找相同节点 （tag相同）</p>
</li>
<li><p>没有找到的话,说明是新节点需要创建该节点的dom；如果找到了，则比较他们是否是相同的vnode，相同则 patchVnode并移动到oldStart前，不同则(当作不同的elm)创建插入新的dom （createElm 创建在 oldStartVnode.elm 之前）</p>
</li>
<li><p>newStartVnode = newCh[++newStartIdx];</p>
</li>
</ol>
</li>
<li><p>循环直到  oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx</p>
</li>
<li><p>比较 oldStartIdx  oldEndIdx</p>
<ul>
<li>oldStartIdx &gt; oldEndIdx 说明 新的节点比较多 ，添加 createElm 新的 newStartIdx, newEndIdx 的节点</li>
<li>newStartIdx &gt; newEndIdx 说明 新的节点少了 ， 删除旧的oldStartIdx 到 oldEndIdx 多余的节点 </li>
</ul>
</li>
</ol>
<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><ol>
<li>调用新vnode的prepatch钩子函数  -&gt; updateChildComponent 更新 vm实例的属性（$vnode,slot,props,listeners）</li>
<li>执行 update 钩子函数<ol start="0">
<li>ƒ updateAttrs(oldVnode, vnode)</li>
<li>ƒ updateClass(oldVnode, vnode)</li>
<li>ƒ updateDOMListeners(oldVnode, vnode)</li>
<li>ƒ updateDOMProps(oldVnode, vnode)</li>
<li>ƒ updateStyle(oldVnode, vnode)</li>
<li>ƒ update(oldVnode, vnode)</li>
<li>ƒ updateDirectives(oldVnode, vnode)</li>
</ol>
</li>
<li>更新dom<ol>
<li>比较他们的孩子节点 oldCh 与 ch 都存在且不相同时，使用 updateChildren 函数来更新子节点，这个后面重点讲。</li>
<li>如果只有 ch 存在，表示旧节点不需要了。如果旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下。</li>
<li>如果只有 oldCh 存在，表示更新的是空节点，则需要将旧的节点通过 removeVnodes 全部清除。</li>
<li>当只有旧节点是文本节点的时候，则清除其节点文本内容。</li>
<li>如果都不满足，则无事发生</li>
</ol>
</li>
<li>执行postPatch钩子函数</li>
</ol>
<h3 id="component-prepatch"><a href="#component-prepatch" class="headerlink" title="component prepatch"></a>component prepatch</h3><p>var child = vnode.componentInstance = oldVnode.componentInstance;<br>获得组件的vm实例 $forceupdate</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elm = vnode.elm = oldVnode.elm;</span><br><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            checkDuplicateKeys(ch);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, <span class="string">''</span>); &#125;</span><br><span class="line">          addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">          removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">          nodeOps.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组件的更新，是通过每一个vue实例的watcher派发更新的，每一步更新都是更新一个vue实例对应的dom。因为update事件被推送到任务队列时，是按watcher的id从小到大进行排序，所以会先更新用户watcher，再更新父watcher，再更新子watcher</p>
<ol>
<li>_render() 生成当前vm实例 新的vnode</li>
<li>_update() 执行 patch方法，由于此时存在旧vnode，如果新旧vnode不同（key tag），会调用 patchVnode，如果是不同的vnode，createELm 创建新的dom，并删去旧的dom</li>
<li>patchVnode 主要是进行更新dom操作 <ul>
<li>新旧节点的孩子节点存在 且不同，调用diff算法</li>
<li>比较 新旧节点的文本，进行更新</li>
</ul>
</li>
<li>diff算法</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>3.组件化</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/3.%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>首先一个 生成 Vue 实例，在执行其render的过程中，createComponent 会  生成 其组件vue构造函数，安装组件钩子函数,在new Vnode 传入构造函数生成 组件的 占位符 vnode</li>
<li>在 update -&gt; patch -&gt; createElm 中，通过调用 createComponent 来为 component组件占位符vnode节点 生成 vm 实例，以此触发 其 init 函数</li>
<li>在 init 函数中 会调用 vm实例的 mount 方法 -&gt; createElm ,这时的 vm实例中的 vnode不再是一个 组件，而是渲染vnode（渲染vnode就是组件最外层的标签），所以会 生成该vnode的真实dom，在对 子vnode进行渲染，执行 createChildren -&gt; createElm。<ul>
<li>如果不是 组件（组件 vnode 是有 复制的Vue对象，会有 init方法，vnode.data.hook.init） ，则 生成 真实 dom ，在 createElm 中 完成插入 父dom 中</li>
<li>如果是 组件 ，则重复上述 </li>
</ul>
</li>
<li>组件渲染完成后 ，占位符节点 在 createComponent 中 完成 插入到 dom 操作（渲染组件 vnode 由于没有parentElm （因为vuecomponent.$el 不存在），所以不会进行插入操作，渲染组件vnode.elm 会被赋值给 占位符vnode生成的vue实例 vm.$el, vm会被赋值给 占位符 vnode.componentInstance,在 占位符vnode进行插入dom时，调用 initComponent 会将占位符 vnode.componentInstance.$el 传给 占位符 vnode.elm ）</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComponent</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.data.pendingInsert)) &#123;</span><br><span class="line">        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><br><span class="line">        vnode.data.pendingInsert = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// !! --&gt; 将vue实例的dom实例 挂载到占位符vnode上</span></span><br><span class="line">      vnode.elm = vnode.componentInstance.$el; </span><br><span class="line">      <span class="comment">// &lt;-- !!</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue);</span><br><span class="line">        setScope(vnode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// empty component root.</span></span><br><span class="line">        <span class="comment">// skip all element-related modules except for ref (#3455)</span></span><br><span class="line">        registerRef(vnode);</span><br><span class="line">        <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line">        insertedVnodeQueue.push(vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="creayeElement-gt-createComponent-生成Vnode"><a href="#creayeElement-gt-createComponent-生成Vnode" class="headerlink" title="_creayeElement -&gt; createComponent 生成Vnode"></a>_creayeElement -&gt; createComponent 生成Vnode</h2><blockquote>
<p>$mount(挂载的dom实例)</p>
</blockquote>
<ol>
<li><p>根据tag类型，如果能在当前vm实例中<code>context.$options.components</code>中找到 tag ，那么这就是一个组件 ，则调用<code>createComponent()</code></p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> Ctor;</span><br><span class="line">      </span><br><span class="line">      ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag);</span><br><span class="line">      <span class="keyword">if</span> (config.isReservedTag(tag)) &#123; <span class="comment">// html标签</span></span><br><span class="line">        <span class="comment">// platform built-in elements</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            (<span class="string">"The .native modifier for v-on is only valid on components but it was used on &lt;"</span> + tag + <span class="string">"&gt;."</span>),</span><br><span class="line">            context</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">          config.parsePlatformTagName(tag), data, children,</span><br><span class="line">          <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">        <span class="comment">// component</span></span><br><span class="line">        vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">        <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">        <span class="comment">// parent normalizes children</span></span><br><span class="line">        vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">          tag, data, children,</span><br><span class="line">          <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// direct component options / constructor</span></span><br><span class="line">      vnode = createComponent(tag, data, context, children);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag 是<code>createElement</code>函数的第一个参数，由<code>render: h =&gt; h(App),</code>，这里例子中为App对象</p>
</blockquote>
</li>
<li><p>createComponent中 以Vue为源，复制生成一个Sub对象(VueComponent)，再调用<code>extend</code>方法扩展Sub对象，包括Vue上的静态方法，继承Vue的原型，cid，options，生命周期的钩子函数</p>
</li>
</ol>
<ul>
<li>Vue 原型上的方法（能直接调用的方法）：$set，$delete，$watch，$nextTick,$mount,$emit</li>
<li>整合 components options 和 vue.options</li>
<li>Vue 上的静态方法 use mixin extend</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createComponent()</span></span><br><span class="line"><span class="keyword">var</span> baseCtor = context.$options._base</span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)  <span class="comment">// Vue.extend</span></span><br><span class="line">  &#125;</span><br><span class="line">installComponentHooks(data); <span class="comment">// 为data 添加 componentVNodeHooks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue.extend</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span> <span class="comment">// Vue</span></span><br><span class="line">    <span class="keyword">const</span> SuperId = Super.cid</span><br><span class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sub 复制 Vue</span></span><br><span class="line">    <span class="comment">// ***</span></span><br><span class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>._init(options)   <span class="comment">// Vue._init</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    Sub[<span class="string">'super'</span>] = Super</span><br><span class="line">    <span class="comment">// ***</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将 props 和 computed属性 挂载到 vuecomponent 的原型 上，这样在生成vuecomponent 实例时就不需要再次挂载</span></span><br><span class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">    <span class="comment">// can have their private assets too.</span></span><br><span class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">    <span class="comment">// later at instantiation we can check if Super's options have</span></span><br><span class="line">    <span class="comment">// been updated.</span></span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache constructor</span></span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>再以Ctor (vuecomponent)对象为参数生成Vnode（占位符Vnode）(作为vnode中的componentOptions属性)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.on</span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    <span class="comment">// abstract components do not keep anything</span></span><br><span class="line">    <span class="comment">// other than props &amp; listeners &amp; slot</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// work around flow</span></span><br><span class="line">    <span class="keyword">const</span> slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">  installComponentHooks(data) <span class="comment">// 为data 添加 componentVNodeHooks  在这里挂载上了 data.hook.init</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组件的 vnode 是没有 children 的</p>
</blockquote>
</li>
</ol>
<h2 id="update-生成-dom"><a href="#update-生成-dom" class="headerlink" title="_update 生成 dom"></a>_update 生成 dom</h2><ol>
<li><p>_update 调用 setActiveInstance(vm) ，将 activeInstance设置为当前vm实例<br>，再调用patch 将 oldvnode 置为空vnode，其 $el 为传入的参数真正的dom</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.prototype._update</span></span><br><span class="line"> <span class="keyword">const</span> vm: Component = <span class="keyword">this</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode  <span class="comment">//旧的 vnode</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode <span class="comment">// vuecomponent 渲染vnode</span></span><br><span class="line"><span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>); <span class="comment">//第一次生成dom</span></span><br><span class="line">        <span class="comment">// 在patch的过程中会判断第一个参数传入的是不是真正的dom，以次来判断是否是第一次生成dom</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode); <span class="comment">//更新 dom 比较新旧vnode</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>createElm</code></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  nested,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>if(createComponent())</code> 判断是否是组件vnode</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//createElm</span></span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="keyword">const</span> children = vnode.children</span><br><span class="line">    <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line"></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">        ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">        : nodeOps.createElement(tag, vnode)</span><br><span class="line">      setScope(vnode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">        <span class="comment">// in Weex, the default insertion order is parent-first.</span></span><br><span class="line">        <span class="comment">// List items can be optimized to use children-first insertion</span></span><br><span class="line">        <span class="comment">// with append="tree".</span></span><br><span class="line">        <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">        <span class="keyword">if</span> (!appendAsTree) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">          &#125;</span><br><span class="line">          insert(parentElm, vnode.elm, refElm)</span><br><span class="line">        &#125;</span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">        <span class="keyword">if</span> (appendAsTree) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">          &#125;</span><br><span class="line">          insert(parentElm, vnode.elm, refElm)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">      vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>false 继续执行<code>createEle</code><ul>
<li>vnode.elm = 创建dom</li>
<li><code>createChildren</code><ul>
<li>重复步骤1</li>
</ul>
</li>
<li><code>insert</code> 将生成的节点插入parent节点中</li>
</ul>
</li>
</ul>
<ol start="3">
<li>如果是组件，createComponent 调用挂载在 占位符vnode上的 init方法</li>
<li>init 会调用 createComponentInstanceForVnode， 进而执行 vnode.componentOptions.Ctor 也就是vuecomponent构造函数并且vm实例 挂载到占位符vnode.componentInstance 上</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should've created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode's elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init </span></span><br><span class="line">init (vnode: VNodeWithData, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vnode.componentInstance &amp;&amp;</span><br><span class="line">    !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">    vnode.data.keepAlive</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">    <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">    componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">      vnode,</span><br><span class="line">      activeInstance <span class="comment">// vuecomponent 组件的parent</span></span><br><span class="line">    )</span><br><span class="line">    child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating) <span class="comment">//渲染子组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件的实例化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">      _isComponent: <span class="literal">true</span>,</span><br><span class="line">      _parentVnode: vnode,<span class="comment">// 占位符vnode</span></span><br><span class="line">      parent: parent <span class="comment">//activeInstance 当前vm实例</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//生成的vuecomponent实例的 父节点是占位符vnode</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Ctor 构造函数 执行 Vue._init 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue._init</span></span><br><span class="line"><span class="comment">//组件 合并配置</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">initLifecycle(vm) <span class="comment">//建立父子 vm的联系</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  parent.$children.push(vm); 父vm实例中添加子vm实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// initInternalComponent</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options);  <span class="comment">//extends 子组件Vue实例</span></span><br><span class="line">    <span class="comment">// doing this because it's faster than dynamic enumeration.</span></span><br><span class="line">    <span class="keyword">var</span> parentVnode = options._parentVnode;</span><br><span class="line">    opts.parent = options.parent;</span><br><span class="line">    opts._parentVnode = parentVnode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vnodeComponentOptions = parentVnode.componentOptions;</span><br><span class="line">    opts.propsData = vnodeComponentOptions.propsData;</span><br><span class="line">    opts._parentListeners = vnodeComponentOptions.listeners; <span class="comment">// event相关</span></span><br><span class="line">    opts._renderChildren = vnodeComponentOptions.children; <span class="comment">// 默认插槽相关</span></span><br><span class="line">    opts._componentTag = vnodeComponentOptions.tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">      opts.render = options.render;</span><br><span class="line">      opts.staticRenderFns = options.staticRenderFns;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>Vue._init 中调用 $mount 来 将 vuecomponent实例挂载到页面上</li>
</ol>
<ul>
<li>在重复上述步骤时， vm.$vnode = _patentVnode ，将占位符vnode，传给组件实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$vnode = _parentVnode; <span class="comment">//占位符vnode</span></span><br><span class="line">vnode.parent = _parentVnode;</span><br></pre></td></tr></table></figure></li>
<li>生成 执行render函数，生成渲染vnode， vnode.parent = _parentVnode</li>
<li>再次调用update， vm._vnode = 渲染vnode, <code>activeinstance</code> = vm (保存当前vm，对于组件来说就是 vuecomponent实例)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm._vnode = vnode; <span class="comment">//渲染vnode</span></span><br><span class="line"><span class="keyword">var</span> restoreActiveInstance = setActiveInstance(vm);</span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br></pre></td></tr></table></figure></li>
<li>再次调用 patch ，如果是组件重复上述步骤，不是 为渲染vnode 创建 原生dom节点，</li>
</ul>
<ol start="7">
<li>当组件渲染完成后 将生产的dom节点挂载到了 <strong>vuecomponent.$el</strong></li>
<li>initComponent 将占位符 vnode.componentInstance.$el 传给 <strong>占位符 vnode.elm</strong>）</li>
<li>插入到父dom中 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//createComponent </span></span><br><span class="line"><span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">          initComponent(vnode, insertedVnodeQueue);</span><br><span class="line">          insert(parentElm, vnode.elm, refElm);</span><br><span class="line">          <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComponent</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.data.pendingInsert)) &#123;</span><br><span class="line">        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><br><span class="line">        vnode.data.pendingInsert = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// !! --&gt; 将vue实例的dom实例 挂载到占位符vnode上</span></span><br><span class="line">      vnode.elm = vnode.componentInstance.$el; </span><br><span class="line">      <span class="comment">// &lt;-- !!</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue);</span><br><span class="line">        setScope(vnode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// empty component root.</span></span><br><span class="line">        <span class="comment">// skip all element-related modules except for ref (#3455)</span></span><br><span class="line">        registerRef(vnode);</span><br><span class="line">        <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line">        insertedVnodeQueue.push(vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
<blockquote>
<p> vnode.componentInstance 占位符vue实例 ，只有占位符才有</p>
</blockquote>
<blockquote>
<p><code>vm.$vnode</code> 表示占位符,也就是父Vnode <code>vm._vnode</code> 表示渲染vnode</p>
</blockquote>
<blockquote>
<p><code>activeInstance</code> 作用就是保持当前上下文的 Vue 实例</p>
</blockquote>
<h2 id="配置合并"><a href="#配置合并" class="headerlink" title="配置合并"></a>配置合并</h2><ul>
<li>对于通过<code>Vue.mixin()</code>方法定义在Vue上的属性，会直接调用 <code>MergeOptions()</code></li>
<li>对于<code>new Vue()</code>实例中，执行<code>_init</code>方法会进行配置合并<ul>
<li>普通的Vue实例，调用  <code>MergeOptions()</code><ul>
<li><code>mergeField()</code> 根据不同的配置，会提供不同的合并策略</li>
</ul>
</li>
<li>组件，调用  <code>initInternalComponent()</code></li>
</ul>
</li>
<li>子组件的配置合并<ul>
<li>子组件在复制Vue生成Sub时,会调用<code>MergeOpetions()</code>合并Vue上的options和组件的<code>extendoptions</code>（也就是组件exports default抛出的内容）到 <code>Sub.options</code></li>
<li>在实例化子组件Vue实例时，会执行<code>_init()</code>方法，调用 <code>initInternalComponent()</code><ul>
<li>合并Sub上定义的options，只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。</li>
<li>复制 <code>{_isComponent: true,_parentVnode: vnode,parent: parent}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><ul>
<li>全局注册<ul>
<li>通过<code>Vue.component(&#39;app&#39;,App)</code>注册全局组件,该方法会为组件建立一个VueComponent构造器，保存在全局 <strong>Vue.options.components</strong>中，在后面createElement用到该组件时，会从其中查找</li>
<li>每个组件的创建都是通过 Vue.extend 继承而来，会把 Vue.options 合并到Sub.options，在组件的实例化阶段，会执行 merge options 逻辑，把 Sub.options.components 合并到 vm.$options.components 上。所以在其他组件中通过resolveAsset()找到全局组件的属性定义，进而生成构造函数，所以也可以使用全局组件。</li>
<li>可以是 conponent directive全局指令 filter过滤器 都可以进行全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [</span><br><span class="line">  <span class="string">'component'</span>,</span><br><span class="line">  <span class="string">'directive'</span>,</span><br><span class="line">  <span class="string">'filter'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      id: string,</span></span></span><br><span class="line"><span class="function"><span class="params">      definition: Function | Object</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition <span class="comment">//构造器 在Vue.options上添加属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>局部注册<ul>
<li>形式如下</li>
<li>Vue 的实例化阶段<code>initInternalComponent()</code>合并 option 的逻辑,所以就把 components 合并到 vm.$options.components 上 (vm是局部的组件vue实例)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><h4 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'app'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">"./App.vue"</span>],resolve);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>通过<code>Vue.component(&#39;app&#39;,App)</code>注册全局组件，会直接把工厂函数保存在Vue.options.components中</li>
<li>在执行到  createELement -&gt; createComponent,因为他是一个工厂函数，而不是Object，所以执行resolveAsyncComponent()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFactory;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">      asyncFactory = Ctor;</span><br><span class="line">      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</span><br><span class="line">      <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">        <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">        <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">          asyncFactory,</span><br><span class="line">          data,</span><br><span class="line">          context,</span><br><span class="line">          children,</span><br><span class="line">          tag</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>其中会设置 resolve方法，<code>const res = factory(resolve, reject)</code>, 此时返回的值为undefined 所以会执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAsyncPlaceholder</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: ?string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> node = createEmptyVNode()</span><br><span class="line">  node.asyncFactory = factory</span><br><span class="line">  node.asyncMeta = &#123; data, context, children, tag &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个空vnode，在html节点中插入注释节点</li>
<li>在异步组件加载完成后，在 factory.resolved 中缓存加载完的组件构造器，再次调用时，判断 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行resolve函数，触发 当前vm 的$forceupdate,c触发watcher 的 update方法，渲染异步组件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// cache resolved</span></span><br><span class="line">  <span class="comment">//res 就是获得的组件属性</span></span><br><span class="line">  factory.resolved = ensureCtor(res, baseCtor)<span class="comment">//生成构造器</span></span><br><span class="line">  <span class="comment">// invoke callbacks only if this is not a synchronous resolve</span></span><br><span class="line">  <span class="comment">// (async resolves are shimmed as synchronous during SSR)</span></span><br><span class="line">  <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">    forceRender(<span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    owners.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="返回一个-Promise"><a href="#返回一个-Promise" class="headerlink" title="返回一个 Promise"></a>返回一个 Promise</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>同上，通过<code>Vue.component(&#39;app&#39;,App)</code>注册全局组件，会直接把工厂函数保存在Vue.options.components中</li>
<li>在执行到  createELement -&gt; createComponent,因为他是一个工厂函数，而不是VueComponent构造器，所以执行resolveAsyncComponent()</li>
<li>设置resolve方法，执行<code>const res = factory(resolve, reject)</code>,由于返回的res是一个promise对象，所以会设置promise的then回调函数，<code>res.then(resolve, reject)</code>来执行设定的resolve方法。</li>
<li>同上，创建一个空vnode，在html节点中插入注释节点</li>
<li>同上，在异步组件加载完成后，执行resolve函数，执行forceRender =&gt;触发 当前vm 的 watcher 的 update方法，渲染异步组件</li>
</ol>
<h4 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LoadingComponent  = &#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;loading&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ErrorComponent  = &#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;error&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>,AsyncComponent);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置resolve方法，执行<code>const res = factory(resolve, reject)</code>,由于返回的res是一个对象，res.component是一个promise对象，所以会设置<code>res.component.then(resolve, reject)</code>的回调函数<ul>
<li>如果设置了 res.error, factory.errorComp = error构造器</li>
<li>如果设置了 res.loading, factory.loadingComp = loading构造器<ul>
<li>如果没有设置delay，直接返回factory.loadingComp</li>
<li>否则 设置timeout，等待delay时间结束，执行<code>factory.loading = true;forceRender(false)</code>来渲染loading组件</li>
</ul>
</li>
<li>如果设置了timeout，设置timeout，等待时间结束，执行reject方法</li>
</ul>
</li>
</ol>
<blockquote>
<p>由于 factory.error 的判断在 resolved之前，会直接return，所以执行了报错，就算resolve返回了结果，也不会再渲染了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下对于promise异步组件 高级异步组件</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPromise(res)) &#123;</span><br><span class="line">        <span class="comment">// () =&gt; Promise</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(factory.resolved)) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPromise(res.component)) &#123; <span class="comment">//高级异步组件</span></span><br><span class="line">        res.component.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.error)) &#123;</span><br><span class="line">          factory.errorComp = ensureCtor(res.error, baseCtor)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.loading)) &#123;</span><br><span class="line">          factory.loadingComp = ensureCtor(res.loading, baseCtor)</span><br><span class="line">          <span class="keyword">if</span> (res.delay === <span class="number">0</span>) &#123;</span><br><span class="line">            factory.loading = <span class="literal">true</span>  <span class="comment">//直接渲染loading</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timerLoading = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// factory.resolve = undefined</span></span><br><span class="line">              timerLoading = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123;</span><br><span class="line">                factory.loading = <span class="literal">true</span></span><br><span class="line">                forceRender(<span class="literal">false</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, res.delay || <span class="number">200</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.timeout)) &#123;</span><br><span class="line">          timerTimeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            timerTimeout = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">if</span> (isUndef(factory.resolved)) &#123;</span><br><span class="line">              reject(</span><br><span class="line">                process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">                  ? <span class="string">`timeout (<span class="subst">$&#123;res.timeout&#125;</span>ms)`</span></span><br><span class="line">                  : <span class="literal">null</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, res.timeout)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>2.生命周期</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<ul>
<li><p>_init</p>
<ul>
<li>beforeCreate (initLifeCycle,initEvents,initRender)</li>
<li>created 可以获得data,props (initInjections,initState,initProvide)，在这里已经完成了 数据data computed的响应式处理以及 watch event的事件回调<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initLifecycle(vm);</span><br><span class="line">initEvents(vm);</span><br><span class="line">initRender(vm);</span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>); <span class="comment">// vue-router vuex</span></span><br><span class="line">initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm);  <span class="comment">//data props methods 挂载到 vue实例上</span></span><br><span class="line">initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>$mount </p>
<ul>
<li>beforeMount 先父后子， mount函数执行之前，也就是vue实例生成真实dom被挂载之前</li>
<li>mounted 先子后父  生成真实dom<ul>
<li>根节点，在$mount的结尾执行</li>
<li><code>patch()</code>末尾执行<code>invokeInsertHook()</code>，执行<code>insertedVnodeQueue</code>中<code>vnode.data.hook.insert()-&gt;callHook(vm,&#39;mounted&#39;)</code><ul>
<li>在<code>createEle()</code>中<code>insertedVnodeQueue</code>递归添加了子组件的vnode，通过<code>invokeCreateHooks()</code>添加，</li>
<li>在<code>createComponent()</code>中调用<code>initComponent() -&gt; invokeCreateHooks()-&gt;invokeCreateHooks() /insertedVnodeQueue.push(vnode)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>schedules -&gt; flushSchedulerQueue()</p>
<ul>
<li>beforeUpdate 数据更新前调用，可以访问现有的dom<ul>
<li>watcher.before()</li>
</ul>
</li>
<li>updated 由于数据改变导致虚拟dom重新渲染和生成dom之后，组件mod已经更新完毕<ul>
<li>callUpdatedHooks()</li>
</ul>
</li>
</ul>
</li>
<li><p>$destory</p>
<ul>
<li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed  Vue实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
</li>
</ul>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><ul>
<li>beforeCreate ：是拿不到props，methods，data，computed和watch的<ul>
<li>主要是用来混入vue-router、vuex等三方组件</li>
<li>在实例化 Vue 的阶段，在 _init 方法中执行的，定义在 src/core/instance/init.js 中</li>
</ul>
</li>
<li>created      ：可以拿到props，methods，data，computed和watch <ul>
<li>函数都是在实例化 Vue 的阶段，在 _init 方法中执行的，定义在 src/core/instance/init.js 中</li>
</ul>
</li>
<li>beforeMount  ：确保有render函数<ul>
<li>在 mount阶段，也就是 DOM 挂载之前，在 mountComponent 函数中执行，定义在 当前lifecycle.js 中</li>
</ul>
</li>
<li>Mounted      ：<ol>
<li>表示父子组件全部挂载完毕，<br>调用在 当前lifecycle.js 中 </li>
<li>表示子组件挂载完毕，调用在 定义在 vdom/patch.js的invokeInsertHook函数执行定义在 vdom/create-component.js 中的insert 这个钩子函数 </li>
</ol>
</li>
<li>beforeUpdate ：<ul>
<li>数据渲染之前，数据更新之后执行</li>
<li>在组件已经 mounted 之后（vm._isMounted == true），才会去调用 </li>
<li>在渲染 Watcher 的 before 函数中执行,定义在 当前lifecycle.js 中</li>
</ul>
</li>
<li>update ：在数据重渲染（Virtual DOM re-render and patch）之后执行<ul>
<li>在flushSchedulerQueue 函数调用时执行，它的定义在 src/core/observer/scheduler.js 中：</li>
</ul>
</li>
<li>beforeDestroy：先父后子执行</li>
<li>destroyed    ：先子后父执行，可以做一些定时器的销毁工作<ul>
<li>钩子函数的执行时机在组件销毁的阶段，最终会调用 $destroy 方法，它的定义在 当前lifecycle.js 中</li>
</ul>
</li>
<li>activated 和 deactivated 钩子函数是专门为 keep-alive 组件定制的钩子</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>1.数据驱动</title>
    <url>/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化，在Vue原型上部署各种方法，</li>
<li><code>new Vue</code>时执行<code>Vue.prototype._init()</code><ul>
<li>initState() =&gt; initData()</li>
</ul>
</li>
<li>执行 <code>Vue.prototype.$mount</code><ul>
<li>编译生成 render 函数</li>
<li>mountComponent <ul>
<li>new Watcher =&gt; this.get =&gt; this.getter() =&gt; vm._update(vm._render(), hydrating)</li>
</ul>
</li>
<li>Vue.prototype._render()<ul>
<li>render.call(vm._renderProxy, vm.$createElement)</li>
</ul>
</li>
<li>Vue.prototype._update()<ul>
<li>patch()<a id="more"></a>
<img src="http://103.14.34.148:9000/imgs/blog/img/loading-dot.png" alt=""><h2 id="data的代理"><a href="#data的代理" class="headerlink" title="data的代理"></a>data的代理</h2></li>
</ul>
</li>
</ul>
</li>
<li><code>initMixin(Vue)</code>会在Vue原型上定义初始化方法<code>_init</code></li>
<li>在实例一个Vue对象时，执行Vue原型上的<code>_init</code>方法, mergeOptions 会将 options 挂载到 vm.$options 上，包括data属性放在实例的<code>$options.data</code>中</li>
<li>进入 <code>initState(实例)</code></li>
<li><code>initState(实例)</code> =&gt; <code>data,props,methods,computed,watch</code>的初始化，着重讲data的初始化</li>
<li><code>initData()</code> =&gt; 取得<code>this.$options.data</code> =&gt; 放入 <code>this._data</code></li>
<li>判断是否和 <code>props,methods</code>重复定义</li>
<li><code>Object.defineProperty</code>进行代理，重定义<code>this.key</code>的setter，getter，在获取data时由 <code>this.key</code> =&gt;<code>this._data.key</code> </li>
<li><strong>observe 实现数据响应</strong>  </li>
</ol>
<h2 id="mount-方法-Vue的实例挂载-gt-html节点上"><a href="#mount-方法-Vue的实例挂载-gt-html节点上" class="headerlink" title="$mount()方法 Vue的实例挂载 =&gt; html节点上"></a>$mount()方法 Vue的实例挂载 =&gt; html节点上</h2><p>Vue._init -&gt; Vue.$mount -&gt; 生成render函数 -&gt; 调用默认Vue.$mount -&gt; mountComponent -&gt; new reder watcher -&gt; watcher.get() -&gt; vm._update(vm._render())</p>
<ol>
<li>在 Runtime Only的情形下，只调用 <code>Vue.prototype.$mount</code>，不会把template转为render函数</li>
<li>在 Runtime + Compiler，会重写<code>mount</code>方法，首先获取<code>el = el所指向的dom</code>，（<code>!= &lt;body&gt; &lt;html&gt;</code>）</li>
<li>如果没有定义<code>render</code>函数，如果定义了<code>template</code>,那么就让<code>template</code>等于所对应的dom的序列化html片段,没有定义的话就是<code>el</code>所指向的<code>dom</code>序列</li>
<li>通过 <code>template</code> 编译生成<code>render</code>函数</li>
<li>调用原先的Vue原型上的<code>mount</code>方法，执行 <code>mountComponent</code></li>
<li>在Vue实例上挂载<code>$el</code>，判断是否有render函数，执行钩子函数</li>
<li>创建渲染 <code>render watcher</code>， 添加<code>watcher</code>实例到Vue实例上，设置<code>watcher.getter</code>方法</li>
<li>执行 <code>watcher.get()</code>，执行<code>watcher.getter()</code>，执行<code>vm._update(vm._render(), hydrating)</code>， <code>vm._render()</code>生成vdom，<code>vm._update</code>渲染dom节点</li>
</ol>
<blockquote>
<p>通过<code>render watcher</code>包装<code>vm._update(vm._render(), hydrating)</code>进行渲染，是为了在数据发生变化时，也会触发页面渲染</p>
</blockquote>
<h3 id="render-生成一个vNode"><a href="#render-生成一个vNode" class="headerlink" title="render() 生成一个vNode"></a>render() 生成一个vNode</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义了render函数，render函数的参数就是 $createElement函数（生成vnode）</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App), <span class="comment">//vnode = render.call(vm._renderProxy, vm.$createElement)</span></span><br><span class="line">  store,</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>
<ol>
<li><code>initMixin</code> <code>_init</code><ul>
<li><code>initLifecycle()</code> 执行 <code>core/instance/lifeCycle.js</code>中声明了 <code>Vue.prototype._update</code></li>
<li>如果不是生产模式，调用<code>initProxy</code>，否则  <code>vm._renderProxy = vm</code> <ul>
<li>为vm做代理 （has或get）</li>
</ul>
</li>
<li><code>initRender()</code> 执行 <code>core/instance/render.js</code>中声明了 <code>Vue.prototype._render</code></li>
</ul>
</li>
<li>mount()的过程中执行了<code>vm._update(vm._render(), hydrating)</code></li>
<li><code>vm._render()</code>执行了<code>vnode = render.call(vm._renderProxy, vm.$createElement)</code>，<code>render</code>就是在<code>mount</code>过程中生成的<code>render函数</code>         </li>
<li>最后判断生成的vNode是否是单个</li>
</ol>
<h3 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h3><h3 id="update-vnode渲染成dom"><a href="#update-vnode渲染成dom" class="headerlink" title="update vnode渲染成dom"></a>update vnode渲染成dom</h3><p>用于在初始化生成dom以及数据更新时，更新dom</p>
<p>执行 <code>vm.__patch__</code></p>
<h4 id="patch-函数柯里化"><a href="#patch-函数柯里化" class="headerlink" title="patch 函数柯里化"></a>patch 函数柯里化</h4><p><code>const patch: Function = createPatchFunction({ nodeOps, modules })</code><br>vue平台相关的，</p>
<ul>
<li>nodeOps 操作真实dom的api  </li>
<li>modules  把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的,一些模块的钩子函数的实现<br>通过柯里化，把差异的参数提前固定到函数中</li>
</ul>
<ol>
<li><code>platforms\web\runtime\index.js</code> 声明 <code>Vue.prototype.__patch__ = inBrowser ? patch : noop</code></li>
<li><code>patch = createPatchFunction({ nodeOps, modules })</code> 对patch方法进行封装</li>
</ol>
<p>执行：</p>
<ol>
<li>如果oldVnode是一个真实的dom节点，则转化成空的Vnode统一生成dom方法的参数</li>
<li>createElm方法生成真实dom，其中通过调用 createChildren 来生成子节点，并递归调用createElm方法</li>
<li>将生成的字节的插入父节点中</li>
<li>删去真实dom中oldVnode.elm</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>css题目</title>
    <url>/2019/11/23/interview/css/</url>
    <content><![CDATA[<h1 id="第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现"><a href="#第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现" class="headerlink" title="第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现"></a>第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现</h1><p><a href="https://www.jianshu.com/p/81ef7e7094e8" target="_blank" rel="noopener">答案</a></p>
<h1 id="第2天-CSS3有哪些新增的特性？"><a href="#第2天-CSS3有哪些新增的特性？" class="headerlink" title="第2天 CSS3有哪些新增的特性？"></a>第2天 CSS3有哪些新增的特性？</h1><p>边框圆角<br>border-radius<br>盒子阴影<br>box-shadow<br>文字阴影<br>text-shadow<br>2d、3d变换<br>transform<br>rotate()<br>scale()<br>skew()<br>translate()<br>过度动画<br>transition<br>自定义动画<br>animation</p>
<h1 id="第3天-在页面上隐藏元素的方法有哪些？"><a href="#第3天-在页面上隐藏元素的方法有哪些？" class="headerlink" title="第3天 在页面上隐藏元素的方法有哪些？"></a>第3天 在页面上隐藏元素的方法有哪些？</h1><p>disaplay: none; 页面不会渲染<br>visibility: hidden; 页面会渲染只是不限显示<br>opacity: 0; 看不见，但是会占据空间,可以点击</p>
<h1 id="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"><a href="#CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"></a>CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？</h1><p><a href="https://blog.csdn.net/sjinsa/article/details/70768483" target="_blank" rel="noopener">答案</a></p>
<p>!important &gt; 内联样式 &gt; id &gt; class(属性选择器[]、伪类 :) &gt; 标签(伪元素) &gt; 通用选择器 &gt; 继承 &gt; 默认</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>html题目</title>
    <url>/2019/11/23/interview/html/</url>
    <content><![CDATA[<h1 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">"***.css"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>link是HTML标签，@import是css提供的。</li>
<li>link引入的样式页面加载时同时加载，@import引入的样式需等页面加载完成后再加载。</li>
<li>link没有兼容性问题，@import不兼容ie5以下。</li>
<li>link可以通过js操作DOM动态引入样式表改变样式，而@import不可以。</li>
</ol>
<h1 id="html的元素有哪些（包含H5）？"><a href="#html的元素有哪些（包含H5）？" class="headerlink" title="html的元素有哪些（包含H5）？"></a>html的元素有哪些（包含H5）？</h1><p>行内元素<br>a<br>b<br>span<br>i<br>em<br>strong<br>block<br>input<br>button<br>select<br>form<br>块级元素<br>div<br>p<br>ul<br>ol<br>li<br>h1~h6<br>textarea<br>H5新增<br>header<br>section<br>asize<br>footer<br>nav<br>article</p>
<h1 id="HTML5的文件离线储存怎么使用，工作原理是什么？"><a href="#HTML5的文件离线储存怎么使用，工作原理是什么？" class="headerlink" title="HTML5的文件离线储存怎么使用，工作原理是什么？"></a>HTML5的文件离线储存怎么使用，工作原理是什么？</h1><h2 id="1、cookie"><a href="#1、cookie" class="headerlink" title="1、cookie"></a>1、cookie</h2><p>（1）本身用于客户端和服务端通信<br>（2）但是它有本地存储的功能，于是就被“借用”<br>（3）document.cookie = …获取和修改即可<br>（4）cookie用于存储的缺点<br>①存储量太小，只有4kb<br>②所有http请求都带着，会影响获取资源的效率<br>③api简单，需要封装才能用document.cookie</p>
<h2 id="2、localStorage-sesseionStorage"><a href="#2、localStorage-sesseionStorage" class="headerlink" title="2、localStorage,sesseionStorage"></a>2、localStorage,sesseionStorage</h2><p>（1）html5专门为存储而设计，最大容量5M<br>（2）api简单易用<br>（3）lcoalStorage.setItem(key, value);localStorage.getItem(key);<br>（4）ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装 </p>
<h2 id="3、sessionStorage"><a href="#3、sessionStorage" class="headerlink" title="3、sessionStorage"></a>3、sessionStorage</h2><p>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h2 id="LocalForage"><a href="#LocalForage" class="headerlink" title="LocalForage"></a>LocalForage</h2><p>Mozilla 开发了一个叫 localForage 的库 ，使得离线数据存储在任何浏览器都是一项容易的任务。localForage 是一个使用非常简单的 JavaScript 库的，提供了 get，set，remove，clear 和 length 等等 API，还具有以下特点：<br>支持回调的异步 API；<br>支持 IndexedDB，WebSQL 和 localStorage 三种存储模式；<br>支持 BLOB 和任意类型的数据，让您可以存储图片，文件等。<br>支持 ES6 Promises</p>
<table>
<tr>
  <th></th><th>cookie</th><th>localstorage</th><th>sessionstorage</th><th>session</th>
</tr>
<tr>
  <td></td><td colspan="4" style="text-align:center">k-v存储 同域名可用</td>
</tr>
<tr>
  <td>存储位置</td><td colspan="3" style="text-align:center">客户端</td><td style="text-align:center">服务端</td>
</tr>
<tr>
  <td>特点</td><td style="text-align:center">随请求头每次提交</td><td style="text-align:center">不随头提交 可长时保存</td><td style="text-align:center">不随头提交页面关闭即失效</td><td style="text-align:center">安全</td>
</tr>
<tr>
  <td>跨页</td><td style="text-align:center" colspan="2">可跨页，不可跨域</td><td style="text-align:center">不可跨页，不可跨域</td><td style="text-align:center">可跨页，不可跨域</td>
</tr>
</table>


<h1 id="简述超链接target属性的取值和作用"><a href="#简述超链接target属性的取值和作用" class="headerlink" title="简述超链接target属性的取值和作用"></a>简述超链接target属性的取值和作用</h1><p><code>&lt;a&gt;</code> 标签的 target 属性规定在何处打开链接文档。</p>
<p>语法：<code>&lt;a target=&quot;value&quot;&gt;</code><br>属性值：<br>|值 |描述|<br>|–|–|<br>|_blank|在新窗口中打开被链接文档。|<br>|_self|默认。在相同的框架中打开被链接文档。|<br>|_parent|在父框架集中打开被链接文档。|<br>|_top|在整个窗口中打开被链接文档。|<br>|framename|在指定的框架中打开被链接文档。|</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript题目</title>
    <url>/2019/11/23/interview/js/</url>
    <content><![CDATA[<h1 id="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"><a href="#用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值" class="headerlink" title="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"></a>用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值</h1><blockquote>
<p>描述：这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）：<br>(a) 生成一个长度为5的空数组arr。<br>(b) 生成一个（2－32）之间的随机整数rand。<br>(c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到arr内[需要使用递归实现，不能使用for/while等循环]<br>(d) 最终输出一个长度为5，且内容不重复的数组arr。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildArray</span>(<span class="params">arr, length, min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">    <span class="keyword">if</span> (!arr.includes(num)) &#123; arr.push(num); &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length === length ? arr : buildArray(arr, length, min, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = buildArray([], <span class="number">5</span>, <span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">console</span>.table(result);</span><br></pre></td></tr></table></figure>

<h1 id="写一个方法去掉字符串中的空格"><a href="#写一个方法去掉字符串中的空格" class="headerlink" title="写一个方法去掉字符串中的空格"></a>写一个方法去掉字符串中的空格</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trim = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内所有的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内两头的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*/</span>,<span class="string">""</span>); <span class="comment">//去除字符串内左侧的空格</span></span><br><span class="line">str.replace(<span class="regexp">/(\s*$)/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内右侧的空格</span></span><br></pre></td></tr></table></figure>
<h1 id="写一个方法把下划线命名转成大驼峰命名"><a href="#写一个方法把下划线命名转成大驼峰命名" class="headerlink" title="写一个方法把下划线命名转成大驼峰命名"></a>写一个方法把下划线命名转成大驼峰命名</h1><p>function toCamelCase(str) {<br>  if (typeof str !== ‘string’) {<br>    return str;<br>  }<br>  return str<br>    .split(‘_’)<br>    .map(item =&gt; item.charAt(0).toUpperCase() + item.substr(1, item.length))<br>    .join(‘’);<br>}</p>
<h1 id="写一个把字符串大小写切换的方法"><a href="#写一个把字符串大小写切换的方法" class="headerlink" title="写一个把字符串大小写切换的方法"></a>写一个把字符串大小写切换的方法</h1><p>function caseConvertEasy(str) {<br>  return str.split(‘’).map(s =&gt; {<br>    if (s.charCodeAt() &lt;= 90) {<br>      return s.toLowerCase()<br>    }<br>    return s.toUpperCase()<br>  }).join(‘’)<br>}</p>
<h1 id="JavaScript跨域总结与解决办法"><a href="#JavaScript跨域总结与解决办法" class="headerlink" title="JavaScript跨域总结与解决办法"></a>JavaScript跨域总结与解决办法</h1><p><a href="https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3" target="_blank" rel="noopener">https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2018/12/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="请求速度"><a href="#请求速度" class="headerlink" title="请求速度"></a>请求速度</h2><h2 id="缓存-路径选择"><a href="#缓存-路径选择" class="headerlink" title="缓存 路径选择"></a>缓存 路径选择</h2><h2 id="http请求大小-减少http请求"><a href="#http请求大小-减少http请求" class="headerlink" title="http请求大小 减少http请求"></a>http请求大小 减少http请求</h2><h2 id="首屏-vue服务端渲染"><a href="#首屏-vue服务端渲染" class="headerlink" title="首屏 vue服务端渲染"></a>首屏 vue服务端渲染</h2><h2 id="减少请求数量"><a href="#减少请求数量" class="headerlink" title="减少请求数量"></a>减少请求数量</h2><h2 id="减少请求大小"><a href="#减少请求大小" class="headerlink" title="减少请求大小"></a>减少请求大小</h2><h3 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h3><p>不显示空格、制表符、换行符，以及压缩注释</p>
<h3 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h3><ul>
<li>去掉回车和空格</li>
<li>无效代码删除</li>
<li>css语义合并</li>
</ul>
<h3 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h3><ul>
<li>无效字符的删除，注释回车空格</li>
<li>代码语义的缩减和优化 </li>
<li>代码混乱降低代码可读性，代码保护，防止内部逻辑泄露</li>
</ul>
<h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><p>虽然使用keep-alive保证长连接，但依旧是串行的请求，多次发送请求来获得不同的资源</p>
<p>文件合并，只需发起一次请求</p>
<p>存在问题：</p>
<ul>
<li><p>首屏渲染等待合并后的js文件加载完后才会进行渲染，首屏渲染时间增加</p>
</li>
<li><p>缓存失效，更改一小部分js代码，就需要重新下载新的合并的js文件</p>
</li>
<li><p>公共库合并，公共库代码改动较少，业务代码打包成一个文件</p>
</li>
<li><p>不同页面的js文件单独打包</p>
</li>
</ul>
<h2 id="图片相关优化"><a href="#图片相关优化" class="headerlink" title="图片相关优化"></a>图片相关优化</h2><ul>
<li>雪碧图，将多张图片合并到一张单独的图片，来减少http请求数量</li>
<li>image inline，使用base64格式保存在html页面中，减少http请求</li>
<li>使用矢量图 svg</li>
</ul>
<h2 id="css-js-加载"><a href="#css-js-加载" class="headerlink" title="css js 加载"></a>css js 加载</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><ul>
<li>顺序执行，并发加载，但是同一个域名下并发加载的数量有限</li>
<li>css header中阻塞页面的渲染，而@import所引用的 css 会等到<strong>页面加载完</strong>才被加载</li>
<li>css 阻塞js执行，不阻塞js的加载<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> <span class="string">"***.css"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><ul>
<li>直接引入的js的会阻塞页面的渲染（同步加载），（defer async异步加载）</li>
<li>js的执行不会阻塞资源的加载</li>
<li>js顺序执行，会阻塞之后的js执行</li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>较少无效的资源加载，由于同一个域名下资源的请求数量有限，防止图片的加载阻塞js文件的加载</p>
<ol>
<li>设置 data-src = url;</li>
<li>当图片进入可视区域，将 src设置为 data-src</li>
</ol>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>图片等静态资源在使用之前提前请求，当需要使用该资源时直接从缓存中加载</p>
<ul>
<li>设置 display:none</li>
<li>使用Image对象 <code>var image = new Image(); imgahe.src=url</code></li>
<li>XMLHttpRequest 请求图片,但会有跨域问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLhttpRequest()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="减少-重绘-回流"><a href="#减少-重绘-回流" class="headerlink" title="减少 重绘 回流"></a>减少 重绘 回流</h2><p>ui的渲染线程会冻结 js线程的执行</p>
<ul>
<li>将会触发回流的样式，使用不触发回流的方式实现</li>
<li>将频繁重绘回流的dom元素作为一个单独的图层，那么他的重绘回流只会影响当前图层。（少用，图层的合并计算量非常大）<ul>
<li>创建图层的条件： perspective transform video webgl canvas 动画 </li>
</ul>
</li>
<li></li>
</ul>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>域名下的所有请求都会带上cookie，造成流量的浪费， </p>
<p>解决：cdn域名和主站域名要分开，在请求静态文件时不携带cookie</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>进行本地缓存，（js方法，css，icon图片，浏览器能力检测结果）提升首屏渲染速度，以及函数调用的速度</p>
<p>setItem getItem</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>不小心将页面刷新，也能将信息从sessionStorage中读取</p>
<h3 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h3><p>存储客户端大量的结构化数据</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><p>减少前端的计算</p>
<h3 id="vue-ssr"><a href="#vue-ssr" class="headerlink" title="vue-ssr"></a>vue-ssr</h3><p>服务端渲染</p>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<h2 id="首次加载白屏时间"><a href="#首次加载白屏时间" class="headerlink" title="首次加载白屏时间"></a>首次加载白屏时间</h2><p>可以通过 perpormance 来获取相关信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> timing = performance.timing,</span><br><span class="line">    start = timing.navigationStart,</span><br><span class="line">    dnsTime = <span class="number">0</span>,</span><br><span class="line">    tcpTime = <span class="number">0</span>,</span><br><span class="line">    firstPaintTime = <span class="number">0</span>,</span><br><span class="line">    domRenderTime = <span class="number">0</span>,</span><br><span class="line">    loadTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dnsTime = timing.domainLookupEnd - timing.domainLookupStart; <span class="comment">//DNS解析时间</span></span><br><span class="line">tcpTime = timing.connectEnd - timing.connectStart; <span class="comment">//TCP建立时间</span></span><br><span class="line">firstPaintTime = timing.responseStart - start; <span class="comment">//首屏时间</span></span><br><span class="line">domRenderTime = timing.domContentLoadedEventEnd - start; <span class="comment">//dom渲染完成时间</span></span><br><span class="line">loadTime = timing.loadEventEnd - start; <span class="comment">//页面onload时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'DNS解析时间:'</span>, dnsTime, </span><br><span class="line">            <span class="string">'\nTCP建立时间:'</span>, tcpTime, </span><br><span class="line">            <span class="string">'\n首屏时间:'</span>, firstPaintTime,</span><br><span class="line">            <span class="string">'\ndom渲染完成时间:'</span>, domRenderTime, </span><br><span class="line">            <span class="string">'\n页面onload时间:'</span>, loadTime);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>减少网络请求数量和请求大小，以及传输数据的大小</p>
<ul>
<li>合并文件，文件的压缩（去除空格、注释、换行符），图片（雪碧图，image inline，base64）头部压缩</li>
<li>cdn 域名和服务器域名区分开，提高并行的请求数量，也可以减少不必要的cookie</li>
<li>缓存 DNS 结果</li>
<li>缓存一些静态资源，如icon、js通用方法到localStorage</li>
</ul>
</li>
<li><p>将javascript脚本放在底部，js的执行会阻塞页面的渲染</p>
<ul>
<li>html顺序解析执行，加载是并发的</li>
<li>css 在head中通过 link方法引入，css加载会阻塞页面的渲染</li>
<li>css 加载 阻塞 js的执行，不阻塞加载</li>
<li>直接引入的js加载会阻塞 页面渲染  （defer async）</li>
<li>js顺序执行，阻塞后续js的执行</li>
</ul>
</li>
<li><p>将CSS样式表放在顶部，因为页面的渲染需要css的加载完毕，非则会出现白屏，所以使用 <code>&lt;link&gt;</code> 来代替 @import</p>
</li>
<li><p>懒加载 预加载</p>
</li>
<li><p>减少重绘回流</p>
<ul>
<li>css <ul>
<li>尽量使用不触发回流的方式来实现样式</li>
<li>尽量修改dom树末端的dom样式</li>
<li>复杂的动画，让其脱离文档流</li>
</ul>
</li>
<li>js<ul>
<li>对于获取布局信息，尽量保存在变量中</li>
<li>一次性修改样式 display：none 脱离文档流 （现代浏览器已优化）className</li>
<li>使用 GPU 加速，transition：transform opacity</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与异步</title>
    <url>/2018/12/22/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h1><ul>
<li>同步 <ul>
<li>如果在函数返回的时候，调用者就能够得到预期结果</li>
<li>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</li>
</ul>
</li>
<li>异步<ul>
<li>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li>
<li>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</li>
</ul>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>new Promise直接执行，返回Promise对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这一段是 同步执行函数（resolve()和reject()是异步的）</span></span><br><span class="line">    <span class="keyword">if</span>(successed)</span><br><span class="line">    &#123;</span><br><span class="line">        resolve(value); <span class="comment">//成功返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);  <span class="comment">//失败返回错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">// resolve回调函数</span></span><br><span class="line">    consoe.log(then)</span><br><span class="line">&#125;,</span><br><span class="line">(error)=&gt;&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
例如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">//2.(tick1)主代码-同步执行函数</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">//3.(tick1)主代码-同步执行函数</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>)     <span class="comment">//5.(tick1)promise回调-微任务</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;          <span class="comment">//6.(tick2)-宏任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">//4.(tick1)主代码-宏任务</span></span><br></pre></td></tr></table></figure>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>) <span class="comment">//2.(tick1)主代码-async1</span></span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)   <span class="comment">//7.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)       <span class="comment">//3.(tick1)主代码-async2 返回Promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)   <span class="comment">//9.(tick2)setTimeout -第二轮宏任务</span></span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">// 4.(tick1)主代码</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">// 5.(tick1)主代码</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) <span class="comment">// 8.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">// 6.(tick1)主代码</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     </span><br><span class="line">        resolve()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="keyword">await</span> async2();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="comment">// 第三轮 9</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="comment">// 第二轮 7</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">	&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             <span class="comment">// 第二轮 6</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout3'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);        <span class="comment">// 3</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);        <span class="comment">// 5 第一轮微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);          <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2018/12/22/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h1><p>JS 执行是单线程的， 它是基于事件循环的。 事件循环大致分为以下几个步骤：</p>
<ol>
<li><p>所有同步任务都在主线程上执行， 形成一个执行栈（ execution context stack）。</p>
</li>
<li><p>主线程之外， 还存在一个 “任务队列”（task queue）。 只要异步任务有了运行结果， 就在 “任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦 “执行栈”<br>中的所有同步任务执行完毕， 系统就会读取 “任务队列”，<br>看看里面有哪些事件。 那些对应的异步任务， 于是结束等待状态， 进入执行栈， 开始执行。</p>
</li>
<li><p>主线程不断重复上面的第三步。</p>
</li>
</ol>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/event-loop.png" alt="事件循环"></p>
<p>  主线程的执行过程就是一个 tick， 而所有的异步结果都是通过“ 任务队列” 来调度。 消息队列中存放的是一个个的任务（ task）。 规范中规定 task 分为两大类， 分别是 macro task 和 micro task， 并且每个 macro task 结束后， 都要清空所有的 micro task。</p>
<p>关于 macro task 和 micro task 的概念， 这里不会细讲， 简单通过一段代码演示他们的执行顺序：</p>
<p>  ``<br>`js<br>for (macroTask of macroTaskQueue) {<br>    // 1. Handle current MACRO-TASK<br>    handleMacroTask();</p>
<pre><code>// 2. Handle all MICRO-TASK
for (microTask of microTaskQueue) {
    handleMicroTask(microTask);
}</code></pre><p>}<br>`<br>``<br>在浏览器环境中，<br>常见的 macro task 有 setTimeout、setImmediate MessageChannel、 postMessage；<br>常见的 micro task 有 MutationObsever 和 Promise.then。</p>
<h3 id="浏览器下事件循环-Event-Loop"><a href="#浏览器下事件循环-Event-Loop" class="headerlink" title="浏览器下事件循环(Event Loop)"></a>浏览器下事件循环(Event Loop)</h3><p>主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue （在执行微任务的时候，如果又有微任务进入队列，则在此次循环中执行）</li>
<li>更新 render （视图更新）</li>
<li>主线程重复执行上述步骤<br>上述为一轮事件循环</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/browser-deom1-excute-animate.gif" alt=""></p>
<h4 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 微任务"></a>宏任务 微任务</h4><ul>
<li>微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)</li>
<li>宏任务 macrotask(task): setTimout / <strong>script（整体代码）</strong> / IO（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） / UI Rendering（页面渲染）<ul>
<li>宏任务优先级 优先执行冒泡的事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序的script代码也算宏任务，所以第一次事件循环首先执行的是script代码，再去清空微任务队列</p>
</blockquote>
<p>特点</p>
<ul>
<li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</li>
<li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li>
<li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li>
</ul>
<p>总结</p>
<ul>
<li>事件循环是js实现异步的核心</li>
<li>每轮事件循环分为3个步骤：<br>  (a) 执行macrotask队列的一个任务<br>  (b) 执行完当前microtask队列的所有任务<br>  (c) UI render</li>
</ul>
<p>浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定</p>
<p><a href="http://lynnelv.github.io/js-event-loop-browser" target="_blank" rel="noopener">参考来源</a></p>
<h1 id="Vue-2-5-0的实现（nextTick）"><a href="#Vue-2-5-0的实现（nextTick）" class="headerlink" title="Vue 2.5.0的实现（nextTick）"></a>Vue 2.5.0的实现（nextTick）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use microtask by default, but expose a way to force (macro) task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine (macro) task defer implementation.</span></span><br><span class="line"><span class="comment">// Technically setImmediate should be the ideal choice, but it's only available</span></span><br><span class="line"><span class="comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span></span><br><span class="line"><span class="comment">// events triggered in the same loop is by using MessageChannel.</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  <span class="comment">// PhantomJS</span></span><br><span class="line">  MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine microtask defer implementation.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fallback to macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn._withTask || (fn._withTask = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    useMacroTask = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    useMacroTask = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next-tick.js 申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0；而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。</p>
<p>next-tick.js 对外暴露了 2 个函数，先来看 nextTick，这就是我们在上一节执行 nextTick(flushSchedulerQueue) 所用到的函数。它的逻辑也很简单，把传入的回调函数 cb 压入 callbacks 数组，最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数。</p>
<p>这里使用 callbacks 而不是直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</p>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全</title>
    <url>/2018/12/22/%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h1><ol>
<li><p>xss攻击   </p>
<ul>
<li><p>借助js实现的攻击，在服务端没有对 &lt;&gt; 进行转译显示的时候发生。导致黑客可以在别人的浏览器上运行任意js代码。</p>
</li>
<li><p>解决方案：在网页内容输出的时候做转译，将&lt;&gt;转译为<code>&amp;lt;</code> 和 <code>&amp;gt;</code></p>
</li>
<li><p>nodejs中通过escape库简单搞定</p>
</li>
</ul>
</li>
<li><p>sql注入攻击</p>
<ul>
<li>利用服务端拼接sql字符串，拼接出各种sql，在服务端执行。使服务端数据泄露，甚至被任意篡改。    </li>
<li>解决方案：sql预编译。</li>
</ul>
</li>
<li><p>响应头设置<code>x-frame-options</code>  </p>
<ul>
<li>限制当前页面被其他页面以iframe引用</li>
</ul>
</li>
<li><p>响应头设置<code>content-security-policy</code></p>
<ul>
<li>限制当前页面去引用其他页面资源</li>
</ul>
</li>
</ol>
<p><a href="https://github.com/sunwu51/WebSecurity" target="_blank" rel="noopener">参考github</a></p>
<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p> <a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">XSS攻击</a>: 注入恶意代码</p>
<pre><code>* 分类
    * 存储型XSS 
        * 攻击者将恶意代码提交到目标网站的数据库中。
        * 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
    * 反射型XSS
        * 攻击者构造出特殊的 URL，其中包含恶意代码。
        * 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。（比如URL中的参数）
    * DOM型XSS
        * 攻击者构造出特殊的 URL，其中包含恶意代码。
        * 用户打开带有恶意代码的 URL。
        * 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
* 解决
    * 转义页面上的输入内容和输出内容
    * cookie 设置 httpOnly,禁止javascript读取cookie
    * 设置验证码，防止脚本冒充提交危险操作</code></pre><p>例如：</p>
<p>攻击者发现 <code>http://weibo.com/pub/star/g/xyyyd</code> 这个 URL 的内容未经过滤直接输出到 HTML 中。</p>
<p>于是攻击者构建出一个 URL，然后诱导用户去点击：</p>
<p><code>http://weibo.com/pub/star/g/xyyyd&quot;&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://weibo.com/pub/star/g/xyyyd"</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//xxxx.cn/image/t.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">"&gt;按分类检索&lt;/a&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure>
<p>攻击者发现<code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb</code> 这个 URL 的参数 uin、domain 未经转义直接输出到 HTML 中。</p>
<p>于是攻击者构建出一个 URL，并引导用户去点击： <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B</code></p>
<p>用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">getTop().location.href=<span class="string">"/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa"</span>+<span class="string">"&amp;t="</span>+<span class="string">"&amp;d=bbbb"</span>;<span class="keyword">return</span> <span class="literal">false</span>;&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(document.cookie)&lt;/</span>script&gt;<span class="string">"+"</span>...</span><br></pre></td></tr></table></figure>
<p>用户通过文本框输入的信息来显示在页面上，那么在文本框输入如下内容<br><code>&lt;img src = &quot;abc&quot; onerror = &quot;alert(1)&quot; /&gt;</code></p>
<pre><code></code></pre><h4 id="CSRF-跨站请求伪造，防护"><a href="#CSRF-跨站请求伪造，防护" class="headerlink" title="CSRF: 跨站请求伪造，防护:"></a>CSRF: 跨站请求伪造，防护:</h4><p>简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<ul>
<li>解决办法<ul>
<li>验证HTTP Referer<ul>
<li>Referer字段记录请求来源地址 检验是否是同一个源</li>
</ul>
</li>
<li>在请求地址中添加takon验证<ul>
<li>HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token</li>
<li>服务器现在页面埋入特定标志，在用户请求时带上此标记，来判断请求是否合法</li>
</ul>
</li>
<li>不被第三方网站访问到用户的cookie sameSite标记</li>
</ul>
</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><a href="https://www.bilibili.com/video/av66187268" target="_blank" rel="noopener">参考视频</a><br>明文传输：裸奔<br>对称加密：key唯一=明文<br>非对称加密： 服务端到客户端的传输不安全<br>非对称协商key+key用来对称加密：中间人劫持问题<br><img src="http://103.14.34.148:9000/imgs/blog/img/%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt=""><br>HTTPS：CA的csk认证服务端pk得到license+客户端操作系统cpk解析license得pk，pk加密非对称协商key+key用来对称加密<br><img src="http://103.14.34.148:9000/imgs/blog/img/https.jpg" alt=""></p>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2018/12/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="AMD-“Asynchronous-Module-Definition”"><a href="#AMD-“Asynchronous-Module-Definition”" class="headerlink" title="AMD(“Asynchronous Module Definition”)"></a>AMD(“Asynchronous Module Definition”)</h2><ul>
<li>采用异步方式加载模块 require([module], callback);</li>
</ul>
<h2 id="CMD-“common-module-definition”"><a href="#CMD-“common-module-definition”" class="headerlink" title="CMD(“common module definition”)"></a>CMD(“common module definition”)</h2><h3 id="CommonJS-node"><a href="#CommonJS-node" class="headerlink" title="CommonJS(node)"></a>CommonJS(node)</h3><ul>
<li>不适用于浏览器环境 <strong>同步</strong>加载</li>
<li>require方式引入模块  <strong>值拷贝</strong>，<strong>导出值变化不会影响导入值</strong></li>
<li>module.exports导出接口 </li>
</ul>
<h1 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h1><ul>
<li>ES6 ：export import 值 <strong>异步</strong> 加载<ul>
<li>静态化 先于模块内其他语句执行，命令具有提升效果</li>
<li>export输出文件内部变量、函数、类 export {a,b as B,c}; import {a,B,c} from ‘ ‘</li>
<li>export default  为模块指定默认输出， 一个模块只能有一个默认。本质上，export default就是输出一个叫做default的变量或方法 <ul>
<li>export default a; import a from ‘ ‘</li>
</ul>
</li>
<li>import  命令具有提升效果 指向 <strong>内存地址</strong>，<strong>导入值会随导出值而变化</strong><ul>
<li>import * from “” 模块的整体加载，加载文件中全部的export </li>
</ul>
</li>
<li>import() 函数 动态加载 返回一个 Promise 对象<ul>
<li>加载模块成功以后，这个模块会作为一个对象，当作then方法的参数<h3 id="require与import的区别"><a href="#require与import的区别" class="headerlink" title="require与import的区别"></a>require与import的区别</h3></li>
</ul>
</li>
</ul>
</li>
<li>require支持 动态导入（地址中包含变量），import 不支持，正在提案 (babel 下可支持) -&gt;import()</li>
<li>require是 <strong>同步</strong> 导入，import属于 <strong>异步</strong> 导入</li>
<li>require是 <strong>值拷贝</strong>，导出值变化不会影响导入值；import指向 <strong>内存地址</strong>，导入值会随导出值而变化       </li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出单个变量</span><br><span class="line">var name &#x3D; nirean;</span><br><span class="line">export &#123;name&#125;</span><br><span class="line">&#x2F;&#x2F;输出一组变量</span><br><span class="line">var name &#x3D; nirean;</span><br><span class="line">bar age &#x3D; 22;</span><br><span class="line">function getHabby()&#123;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;name , age, geyHabby&#125;;</span><br><span class="line">&#x2F;&#x2F;as 重命名</span><br><span class="line">export &#123;name as myname&#125;;</span><br><span class="line">&#x2F;&#x2F; circle.js输出两个函数 import * 整体加载</span><br><span class="line"> </span><br><span class="line">export function area(radius) &#123;</span><br><span class="line">  return Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">export function circumference(radius) &#123;</span><br><span class="line">  return 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line">import * as circle from &#39;.&#x2F;circle&#39;;</span><br><span class="line">console.log(&#39;圆面积：&#39; + circle.area(4));</span><br><span class="line">console.log(&#39;圆周长：&#39; + circle.circumference(14));</span><br><span class="line">&#x2F;&#x2F; export default 不需要&#123; &#125;</span><br><span class="line">export default getName;</span><br><span class="line">import getName from &#39;...&#39;;</span><br><span class="line">&#x2F;&#x2F; export default 为模块指定默认输出</span><br><span class="line">export default function()&#123;&#125;;</span><br><span class="line">import getName from &#39;...&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>NodeJS中的commonJS ：<strong>require exports module.exports</strong><ul>
<li>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作 不适合浏览器</li>
<li>require()用来引入外部模块； <ul>
<li>读入并执行一个JavaScript文件，然后返回该模块的exports对象</li>
<li>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性</li>
</ul>
</li>
<li>exports对象用于导出当前模块的方法或变量，唯一的导出口；</li>
<li>module.export nodeJS仅仅为了方便，用了一个变量exports直接指向了module.exports了</li>
<li>module对象就代表模块本身。</li>
</ul>
</li>
<li>AMD define<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports.x &#x3D; x;  var y &#x3D; require(&quot;&quot;); y.x</span><br><span class="line">module.exports &#x3D; x; var y &#x3D; require(&quot;&quot;); y</span><br><span class="line">module.exports &#x3D; &#123;x:x&#125;; var y &#x3D; require(&quot;&quot;); y.x</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器架构</title>
    <url>/2018/12/22/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h1><ul>
<li>用户界面</li>
<li>主进程</li>
<li>内核<ul>
<li>渲染引擎</li>
<li>JS引擎<ul>
<li>执行栈</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>消息队列<ul>
<li>微任务</li>
<li>宏任务</li>
</ul>
</li>
</ul>
</li>
<li>网络异步线程</li>
<li>定时器线程<h3 id="浏览器下事件循环-Event-Loop"><a href="#浏览器下事件循环-Event-Loop" class="headerlink" title="浏览器下事件循环(Event Loop)"></a>浏览器下事件循环(Event Loop)</h3>事件循环是指: 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出<strong>一个事件</strong>。同一次事件循环中，微任务永远在宏任务之前执行<br>，清空微任务列表，执行一个宏任务，循环再清微任务列表，再执行宏任务，</li>
</ul>
</li>
<li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</li>
<li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li>
<li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li>
<li>微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)</li>
<li>宏任务 macrotask(task): setTimout / script（整体代码） / IO（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） / UI Rendering（页面渲染）/ <ul>
<li>宏任务优先级 优先执行冒泡的事件<h3 id="从输入-url-到展示的过程"><a href="#从输入-url-到展示的过程" class="headerlink" title="从输入 url 到展示的过程"></a>从输入 url 到展示的过程</h3></li>
</ul>
</li>
<li>DNS 解析 域名 -&gt; ip</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面<h3 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h3>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</li>
</ul>
</li>
<li>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</li>
<li>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践:"></a>最佳实践:</h4></li>
</ul>
</li>
</ul>
</li>
<li>css<ul>
<li>避免使用table布局 </li>
<li>将动画效果应用到position属性为absolute或fixed的元素上</li>
</ul>
</li>
<li>javascript<ul>
<li>避免频繁操作样式，可汇总后统一 一次修改</li>
</ul>
</li>
<li><ul>
<li>尽量使用class进行样式修改</li>
<li>减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入</li>
<li>极限优化时，修改样式可将其display: none后修改</li>
<li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3></li>
</ul>
</li>
<li>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</li>
<li>持久性存储，可以分为 浏览器端 与 服务器端<ul>
<li>浏览器:<ul>
<li>cookie: 通常用于存储用户身份，登录状态等<ul>
<li>document.cookie = </li>
<li>http 中自动携带， 体积上限为 4K， 可自行设置过期时间</li>
</ul>
</li>
<li>localStorage / sessionStorage: 长久储存/窗口关闭删除<ul>
<li>体积限制为 4~5M</li>
<li>localStorage.setItem(key,value) 存储自动转化为字符串</li>
</ul>
</li>
<li>indexDB</li>
</ul>
</li>
<li>服务器:<ul>
<li>分布式缓存 redis</li>
<li>数据库<h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3>现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。</li>
</ul>
</li>
</ul>
</li>
<li>Worker 线程一旦新建成功，就会始终运行</li>
</ul>
<ol>
<li>同源限制<br>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</li>
<li>DOM 限制<br>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</li>
<li>通信联系<br>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</li>
<li>脚本限制<br>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li>
<li>文件限制<br>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</li>
</ol>
<ul>
<li><p>主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3></li>
<li><p>意外的全局变量: 无法被回收</p>
</li>
<li><p>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</p>
</li>
<li><p>事件监听: 没有正确销毁 (低版本浏览器可能出现)</p>
</li>
<li><p>闭包: 会导致父级中的变量无法被释放</p>
</li>
<li><p>dom 引用: dom 元素被删除时，内存中的引用未被正确清空</p>
<h3 id="V8垃圾回收机制-v8引擎"><a href="#V8垃圾回收机制-v8引擎" class="headerlink" title="V8垃圾回收机制 v8引擎"></a>V8垃圾回收机制 <a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener">v8引擎</a></h3><p>垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。</p>
</li>
<li><p>新生代空间: 用于存活较短的对象</p>
<ul>
<li>又分成两个空间: from 空间 与 to 空间</li>
<li>Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法<ul>
<li>存活的对象从 from space 转移到 to space</li>
<li>清空 from space</li>
<li>from space 与 to space 互换</li>
<li>完成一次新生代GC</li>
</ul>
</li>
</ul>
</li>
<li><p>老生代空间: 用于存活时间较长的对象</p>
<ul>
<li>从 新生代空间 转移到 老生代空间 的条件<ul>
<li>经历过一次以上 Scavenge GC 的对象</li>
<li>当 to space 体积超过25%</li>
</ul>
</li>
<li>标记清除算法: 标记存活的对象，未被标记的则被释放<ul>
<li>增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能</li>
<li>并发标记(最新技术): 不阻塞 js 执行 在 GC 扫描和标记活动对象时，它允许 JavaScript 应用程序继续运行。测试显示</li>
</ul>
</li>
<li>压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3></li>
</ul>
</li>
<li><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密</p>
</li>
<li><p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密<br>用的端口也不一样，前者是80，后者是443</p>
<h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4></li>
<li><p>无法复用链接，完成即断开，重新慢启动和 TCP 3次握手 </p>
<ul>
<li>TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动</li>
<li>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，</li>
</ul>
</li>
<li><p>head of line blocking: 线头阻塞，导致请求之间互相影响 第一个请求阻塞后，后面的请求都需要等待</p>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4></li>
<li><p>长连接(默认 keep-alive)，复用。 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</p>
</li>
<li><p>host 字段指定对应的虚拟站点 同一个IP同一个端口不同的虚拟Web站点</p>
</li>
<li><p>新增功能:</p>
<ul>
<li>断点续传 要求服务器从文件XXXX字节处开始传送</li>
<li>身份认证</li>
<li>状态管理</li>
<li>cache 缓存<ul>
<li>Cache-Control</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Etag<h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>多路复用。 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 双向数据流</p>
</li>
<li><p>二进制分帧层。应用层http和传输层tcp之间 将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码</p>
</li>
<li><p>首部压缩。压缩http请求报文头部 首部压缩使得整个HTTP数据包小了很多，传输也就会更快</p>
</li>
<li><p>服务端推送。 一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>较为安全的网络传输协议 需要进行非对称的加解密，且需要三次握手</p>
</li>
<li><p>证书(公钥)</p>
</li>
<li><p>SSL 加密</p>
</li>
<li><p>端口 443</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3></li>
<li><p>三次握手</p>
<ul>
<li>第一次握手(SYN=1, seq=x):客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。</li>
<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</li>
<li>第三次握手(ACK=1，ACKnum=y+1).客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1.发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</li>
</ul>
</li>
<li><p>四次挥手 断开连接</p>
<ul>
<li>第一次挥手(FIN=1，seq=x)假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。</li>
<li>第二次挥手(ACK=1，ACKnum=x+1)服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</li>
<li>第三次挥手(FIN=1，seq=y)服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li>
<li>第四次挥手(ACK=1，ACKnum=y+1)客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
<li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</li>
</ul>
</li>
<li><p>滑动窗口: 流量控制 </p>
<ul>
<li>接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的<ul>
<li>ACK：期望接收到的下一字节的序号  当前的窗口大小</li>
</ul>
</li>
<li>接受窗口</li>
<li>发送窗口</li>
</ul>
</li>
<li><p>拥塞处理</p>
<ul>
<li>慢开始 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度</li>
<li>拥塞避免 一种处理丢失分组的方法 出现超时和接收到重复的确认时使用</li>
<li>快速重传 如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失</li>
<li>快速恢复  丢失的分组通过快速重传过程发送完，并被目的主机接受后，为了快速的恢复到较高的传输速度，就会进入快速恢复阶段<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><a href="https://juejin.im/entry/5ad86c16f265da505a77dca4" target="_blank" rel="noopener">缓存</a></h3></li>
</ul>
</li>
<li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p>
</li>
<li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p>
</li>
<li><p>强缓存 </p>
<ul>
<li>Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存</li>
<li>Cache-Control(到某个时间为止)的 max-age （存放多久）优先级高于 Expires</li>
</ul>
</li>
<li><p>协商缓存</p>
<ul>
<li>当缓存已经过期时，使用协商缓存。浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</li>
<li>唯一标识方案: Etag(response 携带) &amp; If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，</li>
<li>最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的Last-Modified)<ul>
<li>如果一致，则直接返回 304 通知浏览器使用缓存</li>
<li>如不一致，则服务端返回新的资源</li>
</ul>
</li>
<li>Last-Modified 缺点：<ul>
<li>周期性修改，但内容未变时，会导致缓存失效</li>
<li>最小粒度只到 s， s 以内的改动无法检测到</li>
</ul>
</li>
<li>Etag 的优先级高于 Last-Modified<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3>服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
</ul>
</li>
<li><p><code>&lt;cookie name&gt; = &lt;cookie value&gt;</code></p>
<ul>
<li>name 名称：一个唯一确定cookie的名称，部分大小写，cookie的名字必须是经过URL编码的，一般可以采用某个前缀在加上当前时间的做法，这样的话名称能够确保是唯一的，也比较方便。</li>
<li>value 值：存储在cookie中的字符串值，必须经过被URL编码</li>
</ul>
</li>
<li><p>作用域 cookie应该被发送给哪些URL</p>
<ul>
<li>domain 域：对于哪个域是有效的，如果没有设置的话，默认来自设置cookie的那个域，在上诉例子中就是<code>.Mozilla.org</code></li>
<li>path 路径：指定域中的那个路径，应该向服务器发送cookie，<code>/</code> 表示没有限制</li>
</ul>
</li>
<li><p>失效时间</p>
<ul>
<li>expires 失效时间：表示cookie何时应该被删除的时间戳，这个日期是GMT格式的日期，如果设置是以前的时间，cookie会被立刻删除。上诉cookie的失效时间是Feb,13-Mar-2018 11:47:50。</li>
<li>Max-Age</li>
</ul>
</li>
<li><p>安全标志</p>
<ul>
<li>HttpOnly 禁止JavaScript访问cookie，阻止XSS攻击</li>
<li>SameSite 服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">" name=value; domain=.mozilla.org; expires=Feb, 13-Mar-2018 11:47:50; path=/; security = true"</span></span><br></pre></td></tr></table></figure>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li>1xx: 接受，继续处理</li>
<li><strong>200: 成功，并返回数据</strong></li>
<li>201: 已创建</li>
<li>202: 已接受</li>
<li>203: 成为，但未授权</li>
<li><strong>204: 成功，无内容</strong></li>
<li>205: 成功，重置内容</li>
<li>206: 成功，部分内容</li>
<li>301: 永久移动，重定向</li>
<li>302: 临时移动，可使用原有URI</li>
<li><strong>304: 资源未修改，可使用缓存</strong></li>
<li><strong>305: 需代理访问</strong></li>
<li>400: 请求语法错误</li>
<li>401: 要求身份认证</li>
<li><strong>403: 拒绝请求</strong></li>
<li><strong>404: 资源不存在</strong></li>
<li><strong>500: 服务器错误</strong><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h3></li>
</ul>
<ol>
<li>GET把参数包含在URL中，而POST将数据放在BODY中。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。</li>
<li>GET 会被历史保存记录，POST中的参数不会被保留</li>
<li>GET只能进行url编码，POST支持更多编码类型（请求头中的Content-Type属性表示编码方式）</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET能被缓存，而POST不能</li>
<li>GET是幂等(请求次数与资源无关)的。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。<br>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li>
</ol>
<ul>
<li>get: <ul>
<li>缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，</li>
<li>发送一个TCP请求 </li>
<li>幂等</li>
</ul>
</li>
<li>post: 安全、大数据、更多编码类型 发送两个TCP请求 </li>
<li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3>无需刷新页面也可以获得服务器的数据</li>
</ul>
<p>JavaScript执行异步网络请求，在现代浏览器上写AJAX主要依靠XMLHttpRequest对象</p>
<p>只能请求同源</p>
<ol>
<li>创建XHR对象</li>
<li>设置 <code>readyStateChange</code> 的回调函数</li>
<li>设置 timeout ontimeout的回调函数，等待响应时间</li>
<li>open 打开请求 设置请求方式，url，以及是否异步发送请求</li>
<li>send 发送请求，设置 请求主体数据</li>
<li>服务器接收消息并将消息填充到XHR中<ul>
<li>status http状态码<ul>
<li>200 请求成功</li>
<li>304 服务器文件为改变，可以直接使用缓存</li>
</ul>
</li>
<li>responseText 响应主体返回的文本</li>
<li>responseXML   响应的XML DOM 文档</li>
<li>statusText 状态具体信息</li>
<li>readyState 请求相应过程<ul>
<li>4 请求完成<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function success(text) &#123;</span><br><span class="line">    var textarea &#x3D; document.getElementById(&#39;test-response-text&#39;);</span><br><span class="line">    textarea.value &#x3D; text;</span><br><span class="line">&#125;</span><br><span class="line">function fail(code) &#123;</span><br><span class="line">    var textarea &#x3D; document.getElementById(&#39;test-response-text&#39;);</span><br><span class="line">    textarea.value &#x3D; &#39;Error code: &#39; + code;</span><br><span class="line">&#125;</span><br><span class="line">var request &#x3D; new XMLHttpRequest(); &#x2F;&#x2F; 新建XMLHttpRequest对象</span><br><span class="line">request.onreadystatechange &#x3D; function () &#123; &#x2F;&#x2F; 状态发生变化时，函数被回调</span><br><span class="line">    if (request.readyState &#x3D;&#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; 成功完成</span><br><span class="line">        &#x2F;&#x2F; 判断响应结果:</span><br><span class="line">        if (request.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">            &#x2F;&#x2F; 成功，通过responseText拿到响应的文本:</span><br><span class="line">            return success(request.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 失败，根据响应码判断失败原因:</span><br><span class="line">            return fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; HTTP请求还在继续...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 发送请求:</span><br><span class="line">request.open(&#39;GET&#39;, &#39;&#x2F;api&#x2F;categories&#39;);</span><br><span class="line">request.send();</span><br><span class="line">alert(&#39;请求已发送，请等待响应...&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3>同源是指”协议+域名+端口”三者相同<br>跨域指一个域下的文档或脚本试图去请求另一个域下的资源，我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4>是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据<br>通过动态创建script，再请求一个带参网址实现跨域通信<br>src=’<a href="http://localhost:9871/api/jsonp?msg=helloJsonp&amp;callback=jsonpCb&#39;" target="_blank" rel="noopener">http://localhost:9871/api/jsonp?msg=helloJsonp&amp;callback=jsonpCb&#39;</a><br>其中？后面为参数 有 </li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>msg：helloJsonp， </li>
<li>callback=jsonCb  <ul>
<li>callback 为后端定义的接受返回函数名字的属性，主要看后端规定的叫什么名字，不一定要是callback。</li>
<li>jsonCb表示后端返回的数据Json的名字，jsonCb({name:”123”});</li>
<li>jsonpCb表示前端在接受到数据后执行的回调函数名字<h4 id="CROS"><a href="#CROS" class="headerlink" title="CROS"></a>CROS</h4></li>
</ul>
</li>
<li>简单请求<ul>
<li>浏览器直接发出CORS请求，在头信息之中，增加一个Origin字段 </li>
<li>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段<ul>
<li>Access-Control-Allow-Origin。该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials。该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li>
<li>Access-Control-Expose-Headers。该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</li>
</ul>
</li>
</ul>
</li>
<li>非简单请求<ul>
<li>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<ul>
<li>Access-Control-Request-Method。该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers。该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</li>
</ul>
</li>
<li>服务器确认跨域请求，返回<ul>
<li>Access-Control-Allow-Methods。该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li>
<li>Access-Control-Allow-Headers。如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Allow-Credentials。该字段与简单请求时的含义相同。</li>
<li>Access-Control-Max-Age。该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</li>
</ul>
</li>
<li>接下来浏览器再次发出请求，和简单请求一样。<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4></li>
</ul>
</li>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt; </span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);</span><br><span class="line">    iframe.onload &#x3D; function() &#123;</span><br><span class="line">        var data &#x3D; &#123;</span><br><span class="line">            name: &#39;aym&#39;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain2.com&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&#39;message&#39;, function(e) &#123;</span><br><span class="line">        alert(&#39;data from domain2 ---&gt; &#39; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;b.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#39;message&#39;, function(e) &#123;</span><br><span class="line">        alert(&#39;data from domain1 ---&gt; &#39; + e.data);</span><br><span class="line">        var data &#x3D; JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number &#x3D; 16;</span><br><span class="line">            &#x2F;&#x2F; 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain1.com&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="nginx反向代理跨域"><a href="#nginx反向代理跨域" class="headerlink" title="nginx反向代理跨域"></a>nginx反向代理跨域</h4>以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端</li>
<li>可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。</li>
<li>通过缓存静态资源，加速Web请求。</li>
<li>实现负载均衡。<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3></li>
<li>XSS攻击: 注入恶意代码<ul>
<li>cookie 设置 httpOnly</li>
<li>转义页面上的输入内容和输出内容</li>
</ul>
</li>
<li>CSRF: 跨站请求伪造，防护:<ul>
<li>get 不修改数据    </li>
<li>不被第三方网站访问到用户的 cookie</li>
<li>设置白名单，不被第三方网站请求</li>
<li>请求校验</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2018/12/22/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><h1 id="ACCESS-CONTROL-ALLOW-ORIGIN响应头"><a href="#ACCESS-CONTROL-ALLOW-ORIGIN响应头" class="headerlink" title="ACCESS-CONTROL-ALLOW-ORIGIN响应头"></a>ACCESS-CONTROL-ALLOW-ORIGIN响应头</h1><h1 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location /a/ &#123;</span><br><span class="line">  proxy_pass http://192.168.0.12:80/;   # 将url/a路径反向代理到http://192.168.0.12:80/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> location /a &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  proxy_pass http://192.168.0.12:80/;   <span class="comment"># 将url/a路径反向代理到http://192.168.0.12:80/a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    upstream group1&#123;                  # 负载均衡</span><br><span class="line">      server http://192.168.0.12:80 weight=10; #配置权重 10：1</span><br><span class="line">      server http://192.168.0.12:81 weight=1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gzip  on; # 开启gzip加速网页加载</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">	      default_type  text/html;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_pass http://group1/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>跨标签页通讯</title>
    <url>/2018/12/22/%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h4 id="postMessage-子页面"><a href="#postMessage-子页面" class="headerlink" title="postMessage 子页面"></a>postMessage 子页面</h4><ul>
<li>父页面 通过 window.open() 或 iframe标签 打开子页面</li>
<li>子页面对象调用 postMessage(msg,targetOrigin)发送消息<ul>
<li>targetOrigin 表示可以获得<strong>该消息所在的域</strong>也可以设置为”*”，表示任何域名都可取得消息</li>
</ul>
</li>
<li>子页面中，通过window.addEventListener(“message”,(evt)=&gt;{},false)取得消息<ul>
<li>evt中 data为传递的消息 <h4 id="localStorage-同源"><a href="#localStorage-同源" class="headerlink" title="localStorage 同源"></a>localStorage 同源</h4></li>
</ul>
</li>
<li>localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。</li>
<li>直接在window对象上添加监听即可：</li>
<li>onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行：localStorage.setItem(‘a’, ‘b’)代码，同样是不会触发监听函数的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onstorage &#x3D; (e)&#x3D;&gt;&#123;&#125;</span><br><span class="line">window.addEventListener(&#39;storage&#39;,fn);</span><br></pre></td></tr></table></figure>
<h4 id="定时器setInterval-cookie-同域"><a href="#定时器setInterval-cookie-同域" class="headerlink" title="定时器setInterval+cookie 同域"></a>定时器setInterval+cookie 同域</h4></li>
<li>document.cookie = 改变cookie的值</li>
<li>setInterval(getcookie(),100);<h4 id="html5浏览器的新特性SharedWorker"><a href="#html5浏览器的新特性SharedWorker" class="headerlink" title="html5浏览器的新特性SharedWorker"></a>html5浏览器的新特性SharedWorker</h4></li>
<li>普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。</li>
<li>SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)<h4 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h4>在浏览器和服务器之间建立一个不受限的双向通信的通道<br>WebSocket连接必须由浏览器发起，特点：</li>
</ul>
<ol>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>
</ol>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax和axios和fetch</title>
    <url>/2018/11/21/ajax&amp;axios&amp;fetch/</url>
    <content><![CDATA[<p>XMLHTTPRequest -&gt; Jquery $.ajax 默认form表单形式Post<br>XMLHTTPRequest -&gt; axios 默认json形式Post</p>
<p>fetch</p>
<p>浏览器中地址栏输入<code>data:text/html,&lt;h1&gt;hello&lt;/h1&gt;</code>可以直接使用html标签生成页面</p>
<figure class="highlight plain"><figcaption><span>src</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">header[url(query),method,header]</span><br><span class="line">body[a&#x3D;b&amp;c&#x3D;d] form类型</span><br><span class="line">body[&#123;a:&quot;b&quot;&#125;] json类型</span><br><span class="line"></span><br><span class="line"># ajax</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;http:&#x2F;&#x2F;localhost:8099&quot;,</span><br><span class="line">    success:function(data)&#123;console.log(data)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>响应结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: GET /</span><br><span class="line">query: &#123;&#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>POST 方法默认’content-type’: ‘application/x-www-form-urlencoded; charset=UTF-8’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">10</span>&#125;,</span><br><span class="line">    url:<span class="string">"http://localhost:8099"</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log(data)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: POST /</span><br><span class="line">query: &#123;&#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'4'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded; charset=UTF-8'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">a</span>: <span class="string">'10'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>GET方法data放在url的query中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method:<span class="string">"GET"</span>,</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">10</span>&#125;,</span><br><span class="line">    url:<span class="string">"http://localhost:8099"</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log(data)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: GET /?a=<span class="number">10</span></span><br><span class="line">query: &#123; <span class="attr">a</span>: <span class="string">'10'</span> &#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>修改POST的’content-type’:’application/json’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    headers:&#123;<span class="string">'content-type'</span>:<span class="string">'application/json'</span>&#125;,</span><br><span class="line">    data:<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="number">10</span>&#125;),</span><br><span class="line">    url:<span class="string">"http://localhost:8099"</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log(data)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: POST /</span><br><span class="line">query: &#123;&#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'8'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>浏览器自带</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://localhost:8099'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.json()).then(<span class="function"><span class="params">d</span>=&gt;</span><span class="built_in">console</span>.log(d))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: GET /</span><br><span class="line">query: &#123;&#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://localhost:8099'</span>,&#123;</span><br><span class="line">  method:<span class="string">"POST"</span>,</span><br><span class="line">  headers:&#123;<span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>&#125;,</span><br><span class="line">  body:<span class="string">"a=12&amp;b=23"</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>res.json()).then(<span class="function"><span class="params">d</span>=&gt;</span><span class="built_in">console</span>.log(d))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url: POST /</span><br><span class="line">query: &#123;&#125;</span><br><span class="line">headers &#123;</span><br><span class="line">  host: <span class="string">'localhost:8099'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'9'</span>,</span><br><span class="line">  origin: <span class="string">'null'</span>,</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'</span>,</span><br><span class="line">  <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-site'</span>: <span class="string">'cross-site'</span>,</span><br><span class="line">  <span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line">  <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">  <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span></span><br><span class="line">&#125;</span><br><span class="line">body [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">a</span>: <span class="string">'12'</span>, <span class="attr">b</span>: <span class="string">'23'</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="axios-前后端均可使用"><a href="#axios-前后端均可使用" class="headerlink" title="axios(前后端均可使用)"></a>axios(前后端均可使用)</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">12</span>&#125;,</span><br><span class="line">    url:<span class="string">"http://localhost:8099"</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res.data)&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    headers:&#123;<span class="string">'content-type'</span>:<span class="string">'application/x-www-form-urlencoded'</span>&#125;,</span><br><span class="line">    data:<span class="string">"a=123&amp;b=abc"</span>,</span><br><span class="line">    url:<span class="string">"http://localhost:8099"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind和new</title>
    <url>/2018/11/21/bind%E5%92%8Cnew/</url>
    <content><![CDATA[<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><p>bind() 方法会 <strong>1. 创建一个新函数</strong> ，当这个新函数被调用时，它 <strong>2. 指定this值</strong> 是传递给 bind() 的第一个参数，传入bind方法的第二个以及以后的 <strong>3. 传入参数</strong> 加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 <strong>4. 可以用来柯里化</strong><br>bind返回的绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h1 id="bind模拟"><a href="#bind模拟" class="headerlink" title="bind模拟"></a>bind模拟</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>                                                       <span class="comment">// 2. 指定this值</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);                                     <span class="comment">// 3. 传入参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                                                 <span class="comment">// 1. 创建一个新函数</span></span><br><span class="line">    args = args.concat([...arguments])                                    <span class="comment">// 4. 柯里化（补充参数）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> func ? <span class="keyword">this</span>.fn(...args) : context.fn(...args)  <span class="comment">// 5.实现函数构造化的new值绑定</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.prototype = <span class="keyword">this</span>.prototype                                         <span class="comment">// 5. 修改返回函数的原型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整模拟见<a href="./javascript/call&apply&bind/bind.js">bind</a></p>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p> new 创建的实例:</p>
<ol>
<li>访问到构造函数里的属性</li>
<li>访问到原型里的属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">	<span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line">	<span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配</title>
    <url>/2018/11/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h3 id="手机端不同设备的适配"><a href="#手机端不同设备的适配" class="headerlink" title="手机端不同设备的适配"></a>手机端不同设备的适配</h3><h4 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h4><p>通过@media来获取设备的各种属性，根据设备属性的条件来应用不同的CSS</p>
<p>例：1px边框的适配</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span>  (<span class="attribute">-webkit-min-device-pixel-ratio:</span> <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="selector-class">.c</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-meta-gt-rem"><a href="#lt-meta-gt-rem" class="headerlink" title="&lt;meta&gt; + rem"></a>&lt;meta&gt; + rem</h4><ul>
<li><code>name = &#39;viewport&#39;</code>, 它提供有关视口初始大小的提示，仅供移动设备使用</li>
<li>content<ul>
<li>width    一个正整数或者字符串 device-width    以pixels（像素）为单位， 定义viewport（视口）的宽度。</li>
<li>height    一个正整数或者字符串 device-height    以pixels（像素）为单位， 定义viewport（视口）的高度。</li>
<li>initial-scale    一个0.0 到10.0之间的正数    定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。</li>
<li>maximum-scale    一个0.0 到10.0之间的正数    定义缩放的最大值；它必须大于或等于minimum-scale的值，不然会导致不确定的行为发生。</li>
<li>minimum-scale    一个0.0 到10.0之间的正数    定义缩放的最小值；它必须小于或等于maximum-scale的值，不然会导致不确定的行为发生。</li>
<li>user-scalable    一个布尔值（yes 或者no）    如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。</li>
</ul>
</li>
</ul>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>根据根元素（即html）的<code>font-size</code>来设置大小，比如html的字体大小设置为<code>16px</code>，那么<code>2rem = 32px</code>。</p>
<p>这里区分一下<strong>em</strong>，em是根据父元素的字体大小来设置的</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>通过meta来进行缩放</li>
<li>设置html的字体大小，后面的大小单位全都使用rem</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale = 1,maxinum-scale = 1,minimum-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>  </span><br><span class="line">            </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">"meta[name=viewport]"</span>);  </span></span><br><span class="line"><span class="actionscript">              <span class="comment">//下面是根据设备像素设置viewport  </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">1</span>) &#123;  </span></span><br><span class="line"><span class="actionscript">        viewport.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'</span>);  </span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="javascript">     <span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">2</span>) &#123;  </span></span><br><span class="line"><span class="actionscript">       viewport.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'</span>);  </span></span><br><span class="line">     &#125;          </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;  </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> fontsize = <span class="number">10</span> * (docEl.clientWidth / <span class="number">320</span>) + <span class="string">'px'</span>;  </span></span><br><span class="line">    docEl.style.fontSize = fontsize;   </span><br><span class="line">                </span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端理论</category>
      </categories>
      <tags>
        <tag>前端理论</tag>
      </tags>
  </entry>
  <entry>
    <title>选择器</title>
    <url>/2018/11/21/%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<ul>
<li>类型选择器    </li>
<li>后代选择器    两个选择器之间的空格</li>
</ul>
<p>id &gt; class &gt; 标签</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>a:visted \ :link<br>a:hover \ :active \ :focus<br>a:last-child …</p>
<p>连接伪类</p>
<p>a:visited:hover</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p> a::first-line<br> a::first-letter<br> a::before<br> a::after</p>
<h3 id="通用选择器-匹配所有可用元素"><a href="#通用选择器-匹配所有可用元素" class="headerlink" title="通用选择器 * 匹配所有可用元素"></a>通用选择器 * 匹配所有可用元素</h3><h3 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h3><ul>
<li>子选择器 &gt;  只选择元素的直接后代 不同于后代选择器（h1 em { }）</li>
<li>相邻同胞选择器 + 选择同一个父元素下某个元素之后的元素 （h2 + p 选择h2之后相邻的p）</li>
<li>属性选择器 [] 选择某个属性是否存在 或 某个属性的值 来寻找元素<ul>
<li>E[att]</li>
<li>E[att=”val”]</li>
<li>E[att~=”val”] 匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素 (rel=”friend met colleage co-worker”)</li>
<li>E[att|=”val”] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值 其中一个值以”val”开头的E元素 (lang=”zh-CN”)</li>
<li>[attr^=value] 表示带有以 attr 命名的属性，且属性值是以”value”开头的元素。</li>
<li>[attr$=value] 表示带有以 attr 命名的属性，且属性值是以”value”结尾的元素。</li>
<li>[attr*=value] 表示带有以 attr 命名的属性，且属性值包含有”value”的元素。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>call和apply</title>
    <url>/2018/11/21/call%E5%92%8Capply/</url>
    <content><![CDATA[<h1 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h1><p>扩充作用域apply和call  </p>
<ol>
<li>方法（非继承):apply() 和 call()  </li>
</ol>
<ul>
<li>在特定的作用域中调用函数,实际上等于设置函数体内 this 对象的值</li>
<li>call()  arg[0]:运行函数的作用域 arg[1<del>n]:参数1</del>n</li>
<li>apply() arg[0]:运行函数的作用域 arg[1]:参数数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.call(<span class="keyword">this</span>, arg1, arg2); <span class="comment">// 使用 call，参数列表</span></span><br><span class="line">func.apply(<span class="keyword">this</span>, [arg1, arg2]) <span class="comment">// 使用 apply，参数数组</span></span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>Array.prototype.push.apply(arr1, arr2); 等价于<br>arr1.push(…arr2)</p>
<h2 id="数组最大值"><a href="#数组最大值" class="headerlink" title="数组最大值"></a>数组最大值</h2><p>Math.max.apply(Math, numbers);   等价于<br>Math.max(…numbers)</p>
<h2 id="使用原型上的方法"><a href="#使用原型上的方法" class="headerlink" title="使用原型上的方法"></a>使用原型上的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line">isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);           <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用 toString()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString(); 	<span class="comment">// "1,2,3"</span></span><br><span class="line"><span class="string">"123"</span>.toString(); 		<span class="comment">// "123"</span></span><br><span class="line"><span class="number">123.</span>toString(); 		<span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>).toString(); <span class="comment">// "123"</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">123</span>).toString(); <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure>

<h2 id="类数组对象（Array-like-Object）使用数组方法"><a href="#类数组对象（Array-like-Object）使用数组方法" class="headerlink" title="类数组对象（Array-like Object）使用数组方法"></a>类数组对象（Array-like Object）使用数组方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domNodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br><span class="line">domNodes.unshift(<span class="string">"h1"</span>);</span><br><span class="line"><span class="comment">// TypeError: domNodes.unshift is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> domNodeArrays = <span class="built_in">Array</span>.prototype.slice.call(domNodes);</span><br><span class="line">domNodeArrays.unshift(<span class="string">"h1"</span>); <span class="comment">// 505 不同环境下数据不同</span></span><br><span class="line"><span class="comment">// (505) ["h1", html.gr__hujiang_com, head, meta, ...]</span></span><br></pre></td></tr></table></figure>

<h2 id="调用父构造函数实现继承"><a href="#调用父构造函数实现继承" class="headerlink" title="调用父构造函数实现继承"></a>调用父构造函数实现继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=[<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码，继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="call的模拟实现"><a href="#call的模拟实现" class="headerlink" title="call的模拟实现"></a>call的模拟实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> args =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); </span><br><span class="line">bar.apply(foo,args)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">  context.fn = <span class="keyword">this</span>;                              <span class="comment">// 1. foo.fn = bar</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);               <span class="comment">// 2. foo.fn()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn                               <span class="comment">// 3. delete foo.fn()</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="apply-模拟实现"><a href="#apply-模拟实现" class="headerlink" title="apply 模拟实现"></a>apply 模拟实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context,args</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">  context.fn = <span class="keyword">this</span>;                              <span class="comment">// 1. foo.fn = bar</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'CreateListFromArrayLike called on non-object'</span>)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);               <span class="comment">// 2. foo.fn(...args)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn                               <span class="comment">// 3. delete foo.fn()</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS知识点</title>
    <url>/2018/11/21/css/</url>
    <content><![CDATA[<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>通过box-sizing设置</p>
<ul>
<li>content-box 标准模型<ul>
<li>宽高不包括边框</li>
</ul>
</li>
<li>border-box  IE模型<ul>
<li>宽高包括边框border和padding</li>
</ul>
</li>
</ul>
<h3 id="JS获取宽高"><a href="#JS获取宽高" class="headerlink" title="JS获取宽高"></a>JS获取宽高</h3><ul>
<li>dom.offsetHeight 最佳</li>
<li>dom.style.height 只能获取内联样式</li>
<li>dom.getBoundingClientRect().width/height 根据元素在视窗中的绝对位置来获取宽高的</li>
<li>window.getComputedStyle(dom).width/height</li>
<li>dom.currentStyle.width/height  页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。<br><a href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener"></a><br><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener"></a></p>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p><a href="https://juejin.im/post/5b876f86518825431079ddd6" target="_blank" rel="noopener"></a><br><a href="https://juejin.im/post/5b876f86518825431079ddd6#heading-8" target="_blank" rel="noopener"></a></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div &gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>层叠上下文的background/border &lt; z-index小于0 &lt; block &lt; float &lt; inline &lt; z-index=0,auto &lt; z-index大于0</p>
<p>如果产生了层叠上下文 那么比较其背景与子元素<br>没有的话就是普通元素 block</p>
<h3 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h3><p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" target="_blank" rel="noopener">flex</a></p>
<p>.parent {<br>    display: flex;<br>    justify-content: center;<br>}</p>
<p>.parent {<br>    display: flex;<br>    align-items: center;<br>}</p>
<ul>
<li><p>水平居中</p>
<ul>
<li>行内元素: text-align: center</li>
<li>块级元素: margin: 0 auto</li>
<li>absolute + transform</li>
<li>flex + justify-content: center</li>
</ul>
</li>
</ul>
<ul>
<li><p>垂直居中</p>
<ul>
<li>line-height: height</li>
<li>absolute + transform</li>
<li>flex + align-items: center</li>
<li>table <table> <tr> <td>12 </td> </tr> </table></li>
</ul>
</li>
</ul>
<ul>
<li><p>水平垂直居中</p>
<ul>
<li>absolute + transform</li>
<li>flex + justify-content + align-items</li>
<li>fixed margin:auto left:0 right:0 right:0 bottom：0</li>
</ul>
</li>
</ul>
<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important &gt; 内联样式 &gt; id &gt; class(属性选择器[]、伪类 :) &gt; 标签(伪元素) &gt; 通用选择器 &gt; 继承 &gt; 默认</p>
<p>后定义的优先级较高</p>
<p><a href="./选择器.md">css选择器参考</a></p>
<h3 id="display：none-visibility-0的区别"><a href="#display：none-visibility-0的区别" class="headerlink" title="display：none visibility=0的区别"></a>display：none visibility=0的区别</h3><ul>
<li>display:none 是真的在页面上消失，不占用空间</li>
<li>visibility=0 是不见了，但还是占了空间</li>
</ul>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul>
<li><p>static </p>
</li>
<li><p>absolute  元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。如果没有就是相对于body</p>
</li>
<li><p>relative 相对自己原来的位置</p>
</li>
<li><p>fixed 相对窗口的绝对定位定位</p>
<ul>
<li>top bottom left right 是相对于最外边距的距离。（content + padding + border + margin）<h3 id="浮动清除-（去除浮动影响，防止父级高度塌陷）"><a href="#浮动清除-（去除浮动影响，防止父级高度塌陷）" class="headerlink" title="浮动清除 （去除浮动影响，防止父级高度塌陷）"></a>浮动清除 （去除浮动影响，防止父级高度塌陷）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;2&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;3&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过增加尾元素清除浮动 :after / <br> : clear: both</p>
<ul>
<li>clear:both 左右两侧均不能出现浮动元素</li>
</ul>
</li>
</ul>
<p>(::after 是css3提出的 和 :after相同 ，都是伪元素，作为已选中元素的最后一个子元素。为了兼容性 建议使用:after)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#clear&#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;2&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner&quot;&gt;3&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建父级 BFC </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer&#123;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父级设置高度</li>
</ul>
<h3 id="与-import-的区别"><a href="#与-import-的区别" class="headerlink" title=" 与 @import 的区别"></a><link> 与 @import 的区别</h3><ul>
<li>link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css<link rel="stylesheet" href="****.css" type="text/css">
<style type="text/css">
@import "***.css"
</style></li>
<li>当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载</li>
<li>@import需要 IE5 以上才能使用</li>
<li>link可以使用 js 动态引入，@import不行</li>
</ul>
<h3 id="CSS预处理器-Sass-Less-Postcss"><a href="#CSS预处理器-Sass-Less-Postcss" class="headerlink" title="CSS预处理器(Sass/Less/Postcss)"></a>CSS预处理器(Sass/Less/Postcss)</h3><ul>
<li>Less</li>
<li>Sass/Scss</li>
<li>postCSS</li>
<li><a href="https://www.jianshu.com/p/a99764ff3c41" target="_blank" rel="noopener">scss</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="img/css.jpg" alt="css"></p>
<h3 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h3><p>flex: flex-grow, (flex-shark,flex-basis)的简写  </p>
<ul>
<li>默认: =&gt;0 1 auto （等比缩小）</li>
<li>auto:=&gt; 1 1 auto（等比放大缩小）</li>
<li>none:=&gt; 0 0 auto （原来大小）</li>
<li>flex:1 =&gt; 1 1 auto（等比放大缩小）  </li>
</ul>
<p>flex：0.125 flex：0.5 flex 0.25<br>  即flex-grow总和小于1时，占用剩余空间的12.5% 50% 25% ，剩余空间占比1：4：2 剩下12.5%不被占用<br><img src="img/css-flex.png" alt="flex"></p>
<h3 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC:块级格式化上下文"></a>BFC:块级格式化上下文</h3><p>规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。从上至下排列、上下margin合并、除float元素外的box的margin-box与BFC的左边相接、BFC不会被float元素覆盖、BFC内元素布局不会影响外部布局</p>
<h3 id="IFC："><a href="#IFC：" class="headerlink" title="IFC："></a>IFC：</h3><p> content box/area的高由font-size/line-height决定的；<br>content box/area的宽等于其子行级盒子的外宽度(margin+border+padding+content width)之和。<br>当inline-level box宽度大于父容器宽度时会被拆分成多个inline-level box<br>IFC则是表示盒子从左到右的水平排列方式<br><a href="https://juejin.im/entry/587c41f91b69e6006bf1b8ec" target="_blank" rel="noopener">IFC</a></p>
<h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p>.block {}<br>.block__element {}<br>.block__element–modifier {}</p>
<h3 id="block-inline"><a href="#block-inline" class="headerlink" title="block inline"></a>block inline</h3><p>block 块元素    inline 内联元素</p>
<p>常见的块元素有：div, p, h1~h6, table, form, ol, ul等</p>
<p>常见的内联元素有：span, a, strong, em, label, input, select, textarea, img, br等</p>
<p>block:</p>
<ol>
<li>独占一行</li>
<li>设置width,height、margin和padding属性。</li>
</ol>
<p>inline:</p>
<ol>
<li>共占一行至换行</li>
<li>width,height无效、水平方向margin和padding产生边距效果，竖直方向无效</li>
</ol>
<p>inline-block：<br>多个元素可以同排一行，且元素具有block的属性，可设置宽高，是block和inline元素的综合体。</p>
<h3 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h3><p>可替换元素（replaced element）的展现效果不是由 CSS 来控制的，CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。<br>典型的可替换元素有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>object-fit：指定可替换元素的内容对象在元素盒区域中的填充方式。<br>object-position<br>指定可替换元素的内容对象在元素盒区域中的位置。</p>
<h3 id="文本截断"><a href="#文本截断" class="headerlink" title="文本截断"></a>文本截断</h3><p>单行文本截断： text-overflow:ellipsis<br>多行文本截断：<br>display: -webkit-box;<br>  overflow: hidden;<br>  -webkit-line-clamp: 2;<br>  -webkit-box-orient: vertical;</p>
<p>CSS方法：<br>::after {<br>    content:”…”;<br>    font-weight:bold;<br>    position:absolute;<br>    bottom:0;<br>    right:0;<br>    padding:0 20px 1px 45px;<br>    background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);<br>}</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>scale(-1,-1) 等价于旋转180度</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 ES7 ES8</title>
    <url>/2018/11/21/ES6&amp;ES7&amp;ES8/</url>
    <content><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol用于属性私有化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _gender = <span class="built_in">Symbol</span>(<span class="string">'gender'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">name,age,gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>[_gender] = gen</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  P.prototype.getGen=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[_gender]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> P;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span> age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Matt'</span>,<span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _gender = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">name,age,gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    _gender = gen</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  P.prototype.getGen=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _gender</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> P;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p><a href="../解构赋值">解构赋值</a></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[index])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj)&#123; <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj)&#123; <span class="comment">// a b</span></span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要添加迭代器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys=<span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> values=<span class="built_in">Object</span>.values(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> length = keys.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: i&gt;=length,</span><br><span class="line">        value:values[i++]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br>浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br></pre></td></tr></table></figure>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个原型为null的空对象</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 以字面量方式创建的空对象就相当于:</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  <span class="comment">// foo会成为所创建对象的数据属性</span></span><br><span class="line">  foo: &#123; </span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">"hello"</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// bar会成为所创建对象的访问器属性</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Setting `o.bar` to"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深冻结函数.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取回定义在obj上的属性名</span></span><br><span class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在冻结自身之前冻结属性</span></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop = obj[name];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果prop是个对象，冻结它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop == <span class="string">'object'</span> &amp;&amp; prop !== <span class="literal">null</span>)</span><br><span class="line">      deepFreeze(prop);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冻结自身(no-op if already frozen)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h1><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h2><p>1.基本用法：</p>
<p>[‘a’, ‘b’, ‘c’].includes(‘a’)     // true<br>[‘a’, ‘b’, ‘c’].includes(‘d’)     // false<br>2.接收俩个参数：要搜索的值和搜索的开始索引</p>
<p>[‘a’, ‘b’, ‘c’, ‘d’].includes(‘b’)         // true<br>[‘a’, ‘b’, ‘c’, ‘d’].includes(‘b’, 1)      // true<br>[‘a’, ‘b’, ‘c’, ‘d’].includes(‘b’, 2)      // false<br>3.与ES6中的indexOf()比较</p>
<p>有些时候是等效的</p>
<p>[‘a’, ‘b’, ‘c’].includes(‘a’)          //true<br>[‘a’, ‘b’, ‘c’].indexOf(‘a’) &gt; -1      //true</p>
<h2 id="求幂"><a href="#求幂" class="headerlink" title="求幂"></a>求幂</h2><p>3 ** 2  //9<br>效果同<br>Math.pow(3, 2) //9</p>
<p>var b = 3;<br>b **= 2;</p>
<h1 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h1><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>var obj = { foo: ‘bar’, baz: 42 };<br>    console.log(Object.keys(obj)) //[“foo”, “baz”]<br>    console.log(Object.values(obj)) //[“bar”, 42]<br>    console.log(Object.entries(obj)) //[[“foo”, “bar”], [“baz”, 42]]</p>
<h2 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h2><p>‘Vue’.padStart(10)           //‘       Vue’<br>‘React’.padStart(10)         //‘     React’<br>‘JavaScript’.padStart(10)    //‘JavaScript’<br>‘Vue’.padEnd(10, ‘<em>*’)           //‘Vue</em><em>_</em><em>*</em>‘<br>‘React’.padEnd(10, ‘Hello’)      //‘ReactHello’<br>‘JavaScript’.padEnd(10, ‘Hi’)    //‘JavaScript’<br>‘JavaScript’.padEnd(8, ‘Hi’)     //‘JavaScript’</p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>返回目标对象中所有属性的属性描述符，该属性必须是对象自己定义的，不能是从原型链继承来的。<br>ES6 的getOwnPropertyDescriptor()返回目标对象可枚举属性的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'霖呆呆'</span>,</span><br><span class="line">    <span class="keyword">get</span> gender() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'gender'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> grad(d) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(d)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'id'</span>))</span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"> &#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数支持尾部逗号"><a href="#函数参数支持尾部逗号" class="headerlink" title="函数参数支持尾部逗号"></a>函数参数支持尾部逗号</h2><h2 id="修饰器Decorator"><a href="#修饰器Decorator" class="headerlink" title="修饰器Decorator"></a>修饰器Decorator</h2><p>es6中实现一个装饰器代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSometing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDecorator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapped = myDecorator(doSometing)</span><br><span class="line">doSometing(<span class="string">'lindaidai'</span>)</span><br><span class="line">  <span class="comment">//Hellowlindaidai</span></span><br><span class="line"></span><br><span class="line">wrapped(<span class="string">'lindaidai'</span>)</span><br><span class="line">  <span class="comment">//start </span></span><br><span class="line">  <span class="comment">//Hellowlindaidai</span></span><br><span class="line">  <span class="comment">//end</span></span><br></pre></td></tr></table></figure>

<p>es8装饰器<br>修饰器不能用于函数<br>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@addSkill</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSkill</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.say = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@looks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looks</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am handsome'</span>)</span><br><span class="line">    target.looks = <span class="string">'handsome'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person[<span class="string">'looks'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//I am handsome</span></span><br><span class="line"><span class="comment">//handsome</span></span><br></pre></td></tr></table></figure>
<p>在修饰器@looks中添加一个console.log()语句，却发现它是最早执行的，其次才打印出handsome。</p>
<p>这是因为装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数<br><a href="https://www.jianshu.com/p/13c5d002478b" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性</title>
    <url>/2018/11/21/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>对象属性的相关介绍</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"matt"</span>,</span><br><span class="line">  cell: <span class="string">"1234"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var func = &#123;</span></span><br><span class="line"><span class="comment">//     func1: function() &#123;&#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   // 获取对象的指定属性的属性描述符</span></span><br><span class="line"><span class="comment">// console.log(Object.getOwnPropertyDescriptor(person, "name"))</span></span><br><span class="line"><span class="comment">//   // &#123; value: 'matt', writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。</span></span><br><span class="line"><span class="comment">//  configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性（包括configurable）是否可以被修改。</span></span><br><span class="line"><span class="comment">//  当writable属性设置为false时，该属性被称为“不可写”。它不能被重新分配。严格模式重写会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(Object.getOwnPropertyDescriptor(func, "func1"))</span></span><br><span class="line"><span class="comment">//   // &#123; value: [Function: func1], writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person.name = "nirean"</span></span><br><span class="line"><span class="comment">// console.log("writable:true " + person.name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (let prop in person) &#123;</span></span><br><span class="line"><span class="comment">//   console.log("enumerable:true " + prop)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete person.name</span></span><br><span class="line"><span class="comment">// console.log("configurable:true " + person.name)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"static"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"nirean"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"writable:false "</span> + person.name) <span class="comment">// static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"enumerable:false "</span> + prop) <span class="comment">// 没有name属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"configurable:false "</span> + person.name) <span class="comment">// 无法删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temperature = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> archive = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'temperature'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get!'</span>);</span><br><span class="line">      <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">      temperature = value;</span><br><span class="line">      archive.push(&#123; <span class="attr">val</span>: temperature &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.getArchive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();</span><br><span class="line">arc.temperature; <span class="comment">// 'get!'</span></span><br><span class="line">arc.temperature = <span class="number">11</span>;</span><br><span class="line">arc.temperature = <span class="number">13</span>;</span><br><span class="line">arc.getArchive(); <span class="comment">// [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值</title>
    <url>/2018/11/21/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//默认值 只有在值为undefined时生效</span></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">2</span>,b=<span class="number">1</span>] = [<span class="number">1</span>,<span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>

<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量名必须和属性名对应才能取到值</span></span><br><span class="line"><span class="keyword">var</span> &#123;foo,boo&#125; = &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">boo</span>:<span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="comment">//如果变量名和属性名不一致</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">foo</span>:name,<span class="attr">boo</span>:str&#125; = &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">boo</span>:<span class="string">"hello"</span>&#125;;</span><br><span class="line">name <span class="comment">//1</span></span><br><span class="line">str <span class="comment">//"hello"</span></span><br><span class="line"><span class="comment">//定义默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//在对一个已经声明的变量进行结构时，需要用大括号包住</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="字符串解构赋值"><a href="#字符串解构赋值" class="headerlink" title="字符串解构赋值"></a>字符串解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串被当作数值处理，一个下标存放一个字母</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// 'h'</span></span><br><span class="line">b <span class="comment">// 'e'</span></span><br><span class="line">c <span class="comment">// 'l'</span></span><br></pre></td></tr></table></figure>

<h4 id="数值和布尔值解构赋值"><a href="#数值和布尔值解构赋值" class="headerlink" title="数值和布尔值解构赋值"></a>数值和布尔值解构赋值</h4><ul>
<li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;toString&#125; = <span class="number">123</span>;</span><br><span class="line">toString === <span class="built_in">Number</span>.prototype.toString; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;toString&#125; = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">//Uncaught TypeError: Cannot destructure property `string` of 'undefined' or 'null'.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">[x,y]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+<span class="string">" "</span>+y);</span><br><span class="line">&#125;</span><br><span class="line">print([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//解构使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">[x=<span class="number">0</span>,y=<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+<span class="string">" "</span>+y);</span><br><span class="line">&#125;</span><br><span class="line">print([<span class="literal">undefined</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//参数为对象的情况 解构使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">&#123;x=<span class="number">0</span>,y=<span class="number">0</span>&#125; = &#123;&#125;</span>)</span>&#123; <span class="comment">// = &#123;&#125; 避免没有参数的情况 默认参数为&#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(x+<span class="string">" "</span>+y);</span><br><span class="line">&#125;</span><br><span class="line">print(&#123;<span class="attr">y</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">//在没有输入参数时，参数的默认值为&#123; x: 0, y: 0 &#125;，而不是解构的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 交换两个数据</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">[b,a] = [a,b];</span><br><span class="line"><span class="comment">//2. 返回对象，数组更好取值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:<span class="string">'zz'</span>,</span><br><span class="line">        age:<span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;name,age&#125; = getData();</span><br><span class="line"><span class="comment">//3. 传参 更方便的将变量名 和一组参数对应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printData</span>(<span class="params">&#123;name,age&#125;</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name+<span class="string">" "</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">printData(&#123;<span class="attr">name</span>:<span class="string">'zz'</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;);</span><br><span class="line"><span class="comment">//4. 函数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">&#123;x=<span class="number">0</span>,y=<span class="number">0</span>&#125; = &#123;&#125;</span>)</span>&#123; <span class="comment">// = &#123;&#125; 避免没有参数的情况 默认参数为&#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(x+<span class="string">" "</span>+y);</span><br><span class="line">&#125;</span><br><span class="line">print(&#123;<span class="attr">y</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">//5.Map遍历</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">map.set(<span class="number">2</span>,<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">" "</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6. 加载模块时，往往需要指定输入哪些方法</span></span><br><span class="line"><span class="keyword">var</span> &#123;getData,printData&#125; = <span class="built_in">require</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>express</title>
    <url>/2018/11/21/express/</url>
    <content><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>Express框架建立在node.js内置的http模块上。</p>
<p>Express框架的核心是对http模块的再包装。</p>
<p>Express框架等于在http模块之上，加了一个中间层。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。</p>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a>use</h4><p>use是express注册中间件的方法，它返回一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">"/home"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br><span class="line"><span class="comment">//等同于 app.listen(1337);</span></span><br></pre></td></tr></table></figure>

<h3 id="all方法和HTTP动词方法"><a href="#all方法和HTTP动词方法" class="headerlink" title="all方法和HTTP动词方法"></a>all方法和HTTP动词方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。</p>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径参数</span></span><br><span class="line">app.get(<span class="string">"/path/:id"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params.id)</span><br><span class="line">  res.send(req.params.id)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串 ？username=aaa&amp;age=10</span></span><br><span class="line">app.get(<span class="string">"/querystring"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.query.username)</span><br><span class="line">  res.send(req.query.username)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单 可以用restlet模拟请求</span></span><br><span class="line">app.use(express.urlencoded()&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;) </span><br><span class="line">app.post(<span class="string">'/form'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">  res.send(req.body.username)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json</span></span><br><span class="line">app.use(express.json()) </span><br><span class="line">app.post(<span class="string">'/json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">  res.send(req.body.username)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(req.body.username) <span class="comment">// 纯文本</span></span><br><span class="line">res.json(&#123;<span class="attr">a</span>:<span class="string">"12"</span>,<span class="attr">b</span>:<span class="string">"1111"</span>&#125;) <span class="comment">// json</span></span><br></pre></td></tr></table></figure>

<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(req.headers.a)  <span class="comment">// 获取请求头</span></span><br><span class="line">res.header(<span class="string">"b"</span>,<span class="string">"c"</span>)         <span class="comment">// 设置响应头</span></span><br></pre></td></tr></table></figure>

<h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><h3 id="指定静态文件目录"><a href="#指定静态文件目录" class="headerlink" title="指定静态文件目录"></a>指定静态文件目录</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>,express.static(<span class="string">'public'</span>)) <span class="comment">// public路径下的index.html</span></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Express-Router"><a href="#Express-Router" class="headerlink" title="Express.Router"></a>Express.Router</h3><p>express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'首页'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'关于'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="comment">// Router.route(api)</span></span><br><span class="line">router.route(<span class="string">'/api'</span>)</span><br><span class="line">	.post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">		Bear.find(<span class="function"><span class="keyword">function</span>(<span class="params">err, bears</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (err) res.send(err);</span><br><span class="line">			res.json(bears);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br></pre></td></tr></table></figure>
<p><a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" rel="noopener">参考</a><br><a href="https://expressjs.com/zh-cn/guide/routing.html" target="_blank" rel="noopener">api</a></p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>flex</title>
    <url>/2018/11/21/flex/</url>
    <content><![CDATA[<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><ul>
<li>容器<ul>
<li>flex-direction 主轴方向<ul>
<li>row</li>
<li>row-reverse</li>
<li>column</li>
<li>column-reverse</li>
</ul>
</li>
<li>flex-wrap 是否换行<ul>
<li>nowrap</li>
<li>wrap</li>
<li>wrap-reserve</li>
</ul>
</li>
<li>flex-flow ：flex-direction flex-wrap</li>
<li>justify-content 同一行内 所有元素在一行的水平位置<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-between</li>
<li>space-round</li>
</ul>
</li>
<li>align-items   同一行 所有元素 在一行的垂直位置<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
</li>
<li>align-content 各行 在垂在方向上 的对齐方式<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-between</li>
<li>space-round</li>
<li>strech</li>
</ul>
</li>
</ul>
</li>
<li>项目<ul>
<li>order 根据order从小到大排列显示项目 </li>
<li>flex-grow 有剩余空间是否放大<ul>
<li>默认0,不放大 </li>
<li>number(!=0)，每个项目根据数字比例放大</li>
<li>可以设置flex-basis:0,依据flex-grow来均分容器</li>
</ul>
</li>
<li>flex-shrink 空间不足是否缩小<ul>
<li>默认1，缩小</li>
<li>0 不缩小</li>
</ul>
</li>
<li>flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 来改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的宽或者高（取决于主轴的方向）的尺寸大小</li>
<li>flex：flex-grow,flex-shrink,flex-basis</li>
<li>align-self<ul>
<li>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript知识点</title>
    <url>/2018/11/21/javascript/</url>
    <content><![CDATA[<h1 id="复制变量、作用域和垃圾收集"><a href="#复制变量、作用域和垃圾收集" class="headerlink" title="复制变量、作用域和垃圾收集"></a>复制变量、作用域和垃圾收集</h1><h2 id="赋值变量"><a href="#赋值变量" class="headerlink" title="赋值变量"></a>赋值变量</h2><ol>
<li>复制变量和传参：基本变量完全独立，引用类型的指针指向存储在堆中的同一个对象。</li>
<li>typeof 操作符用于检测基本类型值。instanceof 操作符检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 true。当然，如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false，因为基本类型不是对象。<a href="javascript/test1.js">test1</a></li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li>EC（执行环境）&lt;————&gt;VO(变量对象)</li>
<li>代码执行时，创建<br>Scope Chain： 当前VO ——&gt;外部EC ——&gt; …… ——&gt; 全局EC<br>标识符解析： ——————————————————————&gt;</li>
<li>var没有块级作用域, let有块级作用域。<a href="javascript/test2.js">test2</a></li>
<li>函数内部初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。在严格模式下，初始化未经声明的变量会导致错误。<a id="more"></a>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li>
<li>标记清除 （从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。）</li>
<li>引用计数（js对象循环引用，IE8的DOM/BOM对象循环引用）-手动null</li>
</ol>
<h1 id="数组类型的常用操作方法"><a href="#数组类型的常用操作方法" class="headerlink" title="数组类型的常用操作方法"></a>数组类型的常用操作方法</h1><ol>
<li>数组的每一项可以保存任何类型的数据</li>
<li>数组大小动态调整</li>
<li>创建方式：<ul>
<li>new Array() <a href="javascript/test3.js">test3</a></li>
<li>使用字面量[]</li>
</ul>
</li>
<li>数组的length可以设置，非只读的，可以通过length添加或者移除数组元素</li>
<li>检测数组<ul>
<li>value instanceof Array</li>
<li>Array.isArray(value)</li>
</ul>
</li>
<li>转换方法<ul>
<li>toString() <a href="javascript/test4.js">test4</a></li>
<li>valueOf()</li>
<li>join    </li>
</ul>
</li>
<li>变异方法 <ul>
<li>push() pop()栈方法</li>
<li>shift() unshifit() 队列方法</li>
<li>reverse() 反转 sort（）字典序排序</li>
<li>带compare函数的sort() 数值排序 <a href="javascript/test5.js">test5</a></li>
<li>splice() —- 拼接（起始位置、要删除的项数（0）和要插入的项）</li>
</ul>
</li>
<li>非变异方法<ul>
<li>concat() 方法 —- 创建数组副本(有参数的拼在数组末尾)</li>
<li>slice() 方法 —- 截取部分数组    </li>
</ul>
</li>
<li>位置方法indexOf() lastIndexOf()</li>
<li>迭代方法（非变异） <ul>
<li>every()：数组中每一项都满足函数条件，则返回 true。</li>
<li>filter()：筛选数组中满足函数条件的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回运行结果组成的新数组。</li>
<li>some()：数组中只要有一项满足函数条件，则返回 true。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li>归并方法（非变异）</li>
</ol>
<ul>
<li>reduce()方法从数组的第一项开始，逐个遍历到最后。</li>
<li>reduceRight()则从数组的最后一项开始，向前遍历到第一项。   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> prev + cur; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="常用引用类型（Object、Array、Function、Date、RegExp）"><a href="#常用引用类型（Object、Array、Function、Date、RegExp）" class="headerlink" title="常用引用类型（Object、Array、Function、Date、RegExp）"></a>常用引用类型（Object、Array、Function、Date、RegExp）</h1></li>
</ul>
</li>
</ol>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><ol>
<li><p>函数声明： 声明提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式： 不提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>函数重复声明会覆盖：没有重载</p>
</li>
<li><p>函数可以作为函数参数、可以作为结果返回</p>
</li>
<li><p>函数的属性和方法(函数也是Object，包含属性和方法)   </p>
<ol>
<li>特殊对象：arguments和this<ul>
<li>arguments 对象是类数组（它并不是 Array 的实例）</li>
<li>arguments.callee 指向拥有这个 arguments 对象的函数本身</li>
<li>(function || arguments.callee).caller 调用当前函数的函数的引用(全局函数的引用)</li>
<li>arguments.length 实现-重载</li>
</ul>
</li>
<li>属性：length和prototype     <ul>
<li>prototype 是保存函数所有实例方法的真正所在</li>
<li>prototype 不可枚举  </li>
</ul>
</li>
</ol>
</li>
<li><p>扩充作用域apply和call  </p>
<ol>
<li>方法（非继承):apply() 和 call()  </li>
</ol>
<ul>
<li>在特定的作用域中调用函数,实际上等于设置函数体内 this 对象的值</li>
<li>call()  arg[0]:运行函数的作用域 arg[1<del>n]:参数1</del>n</li>
<li>apply() arg[0]:运行函数的作用域 arg[1]:参数数组</li>
</ul>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>简单类型：undefined null boolean number string </li>
<li>复杂类型：object<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3></li>
<li>undefined</li>
<li>boolean </li>
<li>number </li>
<li>string </li>
<li>object -&gt; 对象或null</li>
</ul>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><table>
<thead>
<tr>
<th>type</th>
<th>true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>任何大于0的数</td>
<td>0和NaN</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象，包括{},[]</td>
<td>null</td>
</tr>
<tr>
<td>undefined</td>
<td></td>
<td>undefined</td>
</tr>
<tr>
<td>### Number</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* Infinity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* NaN</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* NaN不等于任何数 包括自身</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* parseInt(“ “,10);</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* parseFloat(“ “) ;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### String</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* num.toString(10);</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* String(num); String(‘111’) === ‘111’</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* slice() substr() substring()  start end 截取</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* concat()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* charAt() charCodeAt()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* indexOf() lastIndexOf()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* search() 第一次出现位置 replace() match() 返回数组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* split()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Object</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* constructor  返回构造函数 创建当前对象的函数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* hasOwnProperty() 自己是否有某个属性</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* isPrototypeOf() 是否是该对象的原型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* propertyIsEnumerable() 该属性能否用for-in枚举 一定是自身属性且可枚举</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### function 参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 实际传递参数和声明的参数数量不需要一样</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* arguments 可以获得传递的参数数组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* length 参数数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* arguments[0] 调用参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 修改arguments 会同时修改传递的参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 区分String对象 string基本数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### for if 语句中声明的变量会添加到当前的执行环境中 注意区分函数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Array</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* isArray() toString() valueOf() join()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* push() pop() shift() unshift()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*  reverse() 转置 sort()  return&lt;0 a在前</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* concat() 连接 slice() 起始 和 结束位置 不包括结束位置 splice()  删除起始位置 长度 替换</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* indexOf() lasetIndexOf()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* every()  全为true 返回true some() 任一为true 返回true  forEach() filter() 所有ture 组成数组 map() 返回数组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* reduce() reduceRight()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Date</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Function</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 函数内部属性</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* arguments.callee 指向拥有该arguments的函数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* this 引用的是函数执行的环境对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* caller 当前函数的函数的引用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 函数属性和方法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* length 参数个数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* prototype  —————-见后续</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* apply(),call()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* bind() 会创建函数实例</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="词法作用域（静态作用域）"><a href="#词法作用域（静态作用域）" class="headerlink" title="词法作用域（静态作用域）"></a>词法作用域（静态作用域）</h1><p>函数的作用域在 <strong>函数定义</strong> 的时候就决定了。（除了this引用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();    <span class="comment">// foo中value的作用域为全局EC而不是bar的函数EC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 结果是1 不是2</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域-（编译）"><a href="#作用域-（编译）" class="headerlink" title="作用域 （编译）"></a>作用域 （编译）</h3><p>上下文中声明的 变量和声明的作用范围</p>
<ul>
<li>全局作用域 不带有声明关键字的变量，JS 会默认帮你声明一个全局变量</li>
<li>块级作用域 用let声明 const （es6） 是必须有一个 { } 包裹：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;for (let x...)的循环在每次迭代时都为x创建新的绑定 相当于下面的例子</span><br><span class="line">var a &#x3D; [];</span><br><span class="line">&#123; var k;</span><br><span class="line">    for (k &#x3D; 0; k &lt; 10; k++) &#123;</span><br><span class="line">      let i &#x3D; k; &#x2F;&#x2F;注意这里，每次循环都会创建一个新的i变量</span><br><span class="line">      a[i] &#x3D; function () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</p>
<h1 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="headerlink" title="执行上下文和执行栈"></a>执行上下文和执行栈</h1><p>全局代码初始化时首先ECS压入一个全局EC<br>遇到函数执行时，创建一个函数EC。</p>
<ul>
<li>ECStack管理EC的压栈和出栈。</li>
<li>每个EC对应一个作用域链Scope，VO|AO（AO，VO只能有一个），this。</li>
<li>函数EC中的Scope在进入函数EC时创建，用来有序访问该EC对象AO中的变量和函数。</li>
<li>函数EC中的AO在进入函数EC时，确定了Arguments对象的属性；在执行函数EC时，其它变量属性具体化。</li>
<li>函数的[[scope]]属性在函数创建时就已经确定，并保持不变</li>
</ul>
<h2 id="执行上下文-（执行）"><a href="#执行上下文-（执行）" class="headerlink" title="执行上下文 （执行）"></a>执行上下文 （执行）</h2><ol>
<li>全局EC： window（浏览器）、exports（node）</li>
<li>函数EC： 函数每次被调用时创建</li>
<li><del>evalEC： 不常见</del></li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>  存储代码执行期间创建的所有EC<br>  <img src="img/js1-ec.jpg" alt="ES"></p>
<p>  EC分为两个阶段，进入执行上下文和执行代码。</p>
<h4 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程:"></a>代码执行过程:</h4><ul>
<li>创建 全局上下文 (global EC)</li>
<li>全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被* push到执行栈顶层</li>
<li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li>
<li>函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li>
<li>执行到最后，执行环境栈中只有全局执行上下文，等到应用程序结束才会销毁</li>
</ul>
<h2 id="EC的创建阶段与执行阶段"><a href="#EC的创建阶段与执行阶段" class="headerlink" title="EC的创建阶段与执行阶段"></a>EC的创建阶段与执行阶段</h2><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>  //1. 确认this</span></span><br><span class="line"><span class="xml">  VO = &#123;...&#125;                  //2. 与EC相关的数据作用域，存储了EC中定义的变量和函数声明。</span></span><br><span class="line"><span class="xml">  ScopeChain = &#123;...&#125;          //3. 作用域链</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>全局上下文中的变量对象就是全局对象window（浏览器）、moudle（node）<br>（全局对象是由 Object 构造函数实例化的一个对象）</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="1-this-Binding-确认this"><a href="#1-this-Binding-确认this" class="headerlink" title="1. this Binding (确认this)"></a>1. this Binding (确认this)</h4><p>this: 指代函数当前的运行环境<br><img src="img/js1-thisBinding.jpg" alt="ThisBinding"><br>说人话就是，谁调用了函数。例如:</p>
<ul>
<li><p>隐式绑定obj.fn()，便是 obj 调用了函数，既函数中的 this === obj</p>
</li>
<li><p>默认绑定fn()，这里可以看成 window.fn()，因此 this === window</p>
</li>
<li><p>显示绑定:</p>
<ul>
<li>call: fn.call(target, 1, 2)</li>
<li>apply: fn.apply(target, [1, 2])</li>
<li>bind: fn.bind(target)(1,2) 返回新函数 其中this指向target</li>
<li>target 绑定null或者undefined时this为默认绑定</li>
</ul>
</li>
<li><p>new运算过程绑定</p>
<ul>
<li>生成新对象</li>
<li>链接到原型 新对象.<code>_proto_</code> = 对象.prototype </li>
<li>绑定this 指向新对象</li>
<li>返回新对象 </li>
</ul>
</li>
<li><p>=&gt; 绑定：根据外层（函数或者全局）作用域（词法作用域）来决定this。箭头函数的this无法通过bind，call，apply来直接修改</p>
<h4 id="2-VO"><a href="#2-VO" class="headerlink" title="2. VO"></a>2. VO</h4><p>VO = {<br>arguments: {        // 全局EC没有</p>
<pre><code>0: 形参值,
length: 1</code></pre><p>},<br>形参名：形参值，<br>变量名：undefined     // 变量声明<br>函数名：<ref to func> // 函数声明<br>}</p>
</li>
</ul>
<p>全局EC 拥有一个全局对象（window）及关联的方法属性（例数组方法）、用户自定义全局变量（a、b、c）创建时let、const变量未初始化（无变量提升，使用会报ReferenceError）var变量undefined（变量提升）</p>
<p>函数EC的VO初始化只包括 Arguments 对象</p>
<p>js引擎 单线程顺序 <del>y一行一行</del> 一段一段执行<br>当执行一段代码的时候，会进行一个“准备工作”<br>同一EC下：</p>
<ol>
<li><p><a href="javascript/执行上下文栈和变量对象/变量提升.js">变量提升</a> </p>
<p> （变量声明提升到函数顶部 例：var a = 2中 var a提升到顶部）  </p>
</li>
<li><p><a href="javascript/执行上下文栈和变量对象/函数提升.js">函数提升</a> </p>
<p> (function a(){} 的&lt; a func &gt;提升到顶部，后的同名声明覆盖前声明)</p>
</li>
<li><p><a href="javascript/执行上下文栈和变量对象/声明优先级函数大于变量.js">优先级：函数 &gt; 变量</a><br> （function a（）{}的&lt; a function&gt; 优先与var a = function(){}的 var a）</p>
</li>
</ol>
<h4 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h4><p>执行上下文中包含作用域链Scope。指向变量对象VO|AO的指针列表<br>当代码在<strong>一个环境中</strong>执行时，会创建变量对象的<strong>一个作用域链</strong>，VO激活了变成AO</p>
<p>Scope = [AO].concat([[Scope]]);   </p>
<ul>
<li>Scope ：作用域链</li>
<li>AO: 当前活动对象</li>
<li>[[Scope]]：指向父级变量对象和父级EC作用域链</li>
</ul>
<p>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去（词法环境的）父作用域找，一直找到全局上下文的变量对象，也就是全局对象。</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><h4 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h4><p>顺序执行代码，根据代码，修改VO的值</p>
<h1 id="执行上下文栈和变量对象"><a href="#执行上下文栈和变量对象" class="headerlink" title="执行上下文栈和变量对象"></a>执行上下文栈和变量对象</h1><p>执行上下文栈ECS根据函数执行顺序对全局EC和函数EC依次入出栈</p>
<h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><p>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；</p>
<pre><code>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</code></pre><p><img src="img/js-mem.png" alt="1"></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包:<br>（在特定的时机下去运行特定的函数）<br>闭包的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级EC的变量对象和作用域链，因此可以继续访问到父级的变量对象，<strong>除了this和arguments</strong>这样的函数称为闭包。</p>
<ol>
<li>一个函数（比如，内部函数从父函数中返回）</li>
<li>能访问上级函数作用域中的变量（哪怕上级函数上下文已经销毁）</li>
</ol>
<p>（函数中访问全局变量也是一种闭包）</p>
<p> <strong>是闭包中的变量并不保存中栈内存中，而是保存在堆内存中</strong><br>即使外部函数已经返回，闭包仍能访问和更新外部函数定义的变量</p>
<ul>
<li><p>多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</p>
<ul>
<li><p>变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 </p>
<ul>
<li>(function(msg){<br>  return function(){console.log(msg);}<br>})(i)</li>
</ul>
</li>
<li><p>使用setTimeout包裹，通过第三个参数传入</p>
<ul>
<li>第三个参数及以后的参数都可以作为func函数的参数</li>
</ul>
</li>
<li><p>使用 块级作用域，让变量成为自己上下文的属性，避免共享<br>  for(let i;i&lt;3;i++)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setData()&#123;</span><br><span class="line">    var data &#x3D; [];</span><br><span class="line">    for(var i&#x3D;0;i&lt;3;i++)&#123;</span><br><span class="line">        data[i] &#x3D; (function(i)&#123;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                 console.log(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);             </span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">var data &#x3D; setData();</span><br><span class="line">data[1]();</span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  setTimeout((msg)&#x3D;&gt;&#123;</span><br><span class="line">    data[msg] &#x3D; function()&#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,0,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><a href="https://muyiy.cn/blog/2/2.2.html#%E9%9D%A2%E8%AF%95%E5%BF%85%E5%88%B7%E9%A2%98" target="_blank" rel="noopener">闭包经典题</a><br>[闭包题2]（<a href="https://www.cnblogs.com/xxcanghai/p/4991870.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xxcanghai/p/4991870.html）</a></p>
<h1 id="匿名函数表达式与具名函数表达式"><a href="#匿名函数表达式与具名函数表达式" class="headerlink" title="匿名函数表达式与具名函数表达式"></a>匿名函数表达式与具名函数表达式</h1><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。</p>
<h3 id="预先设置一些参数"><a href="#预先设置一些参数" class="headerlink" title="预先设置一些参数"></a>预先设置一些参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">"，b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind(..)进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2，b:3</span></span><br></pre></td></tr></table></figure>
<h3 id="curry"><a href="#curry" class="headerlink" title="curry"></a><a href="https://muyiy.cn/blog/6/6.2.html#%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">curry</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length; 	</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;			</span><br><span class="line">    <span class="keyword">return</span> args.length &gt;= length	</span><br><span class="line">    	? fn.apply(<span class="keyword">this</span>, args)			</span><br><span class="line">      : currying(fn.bind(<span class="keyword">this</span>, ...args), length - args.length) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：fn.length: 实参长度<br>arguments.length:型参长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = currying(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>)(<span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>)(<span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>, <span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<h1 id="深浅拷贝原理"><a href="#深浅拷贝原理" class="headerlink" title="深浅拷贝原理"></a>深浅拷贝原理</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>如果属性是基本类型，拷贝的就是基本类型的值，<br>如果属性是引用类型，拷贝的就是内存地址 </p>
<ul>
<li>Object.assigh(目标对象，源对象..) 返回目标对象<ul>
<li>Object.assign() 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象</li>
<li>可以用于复制对象的方法</li>
<li>原型链上的属性和不可枚举的属性不能复制  </li>
<li>属性的值为对象 依旧只是引用</li>
</ul>
</li>
<li>展开运算符 …<ul>
<li>对象展开运算符让你可以通过展开运算符 (…) , 以更加简洁的形式将一个对象的可枚举属性拷贝至另一个对象</li>
<li>对象字面量的展开操作符能将源对象中的可枚举的属性复制到目标对象上</li>
</ul>
</li>
<li>slice(0)     // Array.prototype.slice()</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>完全改变source变量之后对 copy 没有任何影响。</p>
<ul>
<li>使用 JSON.parse(JSON.stringify(object)); <ul>
<li>具有循环引用的对象时，报错</li>
<li>当值为函数、undefined、或symbol时，无法拷贝</li>
</ul>
</li>
<li>递归进行逐一赋值</li>
</ul>
<h2 id="简单浅拷贝"><a href="#简单浅拷贝" class="headerlink" title="简单浅拷贝"></a>简单浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单深拷贝"><a href="#简单深拷贝" class="headerlink" title="简单深拷贝"></a>简单深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">           copy[key] = copyObj(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            copy[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="./深拷贝.js">深拷贝</a></p>
<h2 id="Object-assign-模拟实现"><a href="#Object-assign-模拟实现" class="headerlink" title="Object.assign 模拟实现"></a>Object.assign <a href="https://muyiy.cn/blog/4/4.2.html#object-assign-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">模拟实现</a></h2><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol>
<li>原生情况下挂载在 Object 上的属性是不可枚举的，<br>但是直接在 Object 上挂载属性 a 之后是可枚举的<br>可以通过Object.defineProperty设置不可枚举属性   <ul>
<li>enumerable: false,   </li>
<li>writable: true,   </li>
<li>configurable: true。</li>
</ul>
</li>
<li>检查枚举情况<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	value: ƒ, </span></span><br><span class="line"><span class="comment">//  writable: true, </span></span><br><span class="line"><span class="comment">//  enumerable: true,  // 注意这里是 true</span></span><br><span class="line"><span class="comment">//  configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.propertyIsEnumerable(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><ul>
<li>属性<ul>
<li>数值属性<ul>
<li>value  （和writable enumerable configurable）</li>
</ul>
</li>
<li>访问器属性 （没有数值 在调用时用来改变数值属性的值）<ul>
<li>set get 读取和写入数据时调用的函数 （和enumerable configurable）</li>
</ul>
</li>
<li>definePropety(对象名，属性名，{描述符：值})</li>
<li>definePropeties(对象名，{ { }})</li>
<li>getOwnPropertyDescriptor(对象，属性名)</li>
</ul>
</li>
<li>hasOwnProperty 实例属性 不向上检查原型链</li>
<li>for-in 或者propName-in-Obj无论是原型还是实例中的属性都可以遍历</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul>
<li>工厂模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hi "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jack = createPerson(<span class="string">"jack"</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
<li>构造函数模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hi "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nire = <span class="keyword">new</span> Person(<span class="string">"nire"</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure></li>
<li>原型模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Man = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Man.prototype.sexule = <span class="string">"man"</span>;</span><br><span class="line">Man.prototype.getGirl = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nirean = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>Symbol 作为构造函数来说并不完整，因为不支持语法 new Symbol()，但其原型上拥有 constructor 属性，即 Symbol.prototype.constructor。</li>
<li>引用类型的 constructor 可以修改，</li>
<li>基本类型<ul>
<li>number boolean string 的constructor只读的</li>
<li>null 和 undefined 没有 constructor。</li>
</ul>
</li>
<li><strong>proto</strong> 是每个实例上都有的属性，prototype 是构造函数的属性，在实例上并不存在，所以这两个并不一样，但 p.<strong>proto</strong> 和 Parent.prototype 指向同一个对象。</li>
<li><strong>proto</strong> 属性在 ES6 时被标准化，但因为性能问题并不推荐使用，推荐使用 Object.getPrototypeOf()。</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul>
<li>每个对象拥有一个原型对象，通过 <strong>proto</strong> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这就是<strong>原型链</strong>。</li>
<li>当访问一个对象的属性 / 方法时，它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，一层一层向上查找，直到找到一个名字匹配的属性 / 方法或到达原型链的末尾（null）。</li>
<li>原型链的构建依赖于 <strong>proto</strong>，一层一层最终链接到 null。</li>
<li>instanceof 原理就是实例一层一层查找 <strong>proto</strong>，如果和实例的constructor.prototype 相等则返回 true，如果一直没有查找成功则返回 false。</li>
</ul>
<h2 id="Object-create-和-new-Object-的区别"><a href="#Object-create-和-new-Object-的区别" class="headerlink" title="Object.create() 和 new Object()的区别"></a>Object.create() 和 new Object()的区别</h2><p>new 的模拟实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">	<span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">	<span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出 Object.create(Con.prototype)与new Con()相比，少了Con.apply(obj, arguments)的过程<br>let a = Object.create(b): 创建一个空对象a，a.<strong>proto</strong>指向b<br>let a = new B()，B是一个 constructor，也是一个 function，B身上有着 prototype 的引用，只要随时调用 a = new B()，我就会将 a.<strong>proto</strong> 指向到B的 prototype 对象。</p>
<h3 id="object-create-模拟实现"><a href="#object-create-模拟实现" class="headerlink" title="object.create()模拟实现"></a>object.create()模拟实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    f.prototype = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>借用构造函数<ul>
<li>并没有改变原型链，只是调用了超类中的语句</li>
</ul>
</li>
</ul>
<h2 id="原型链式继承"><a href="#原型链式继承" class="headerlink" title="原型链式继承"></a>原型链式继承</h2><p>a继承b</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// A.prototype.constructor = B 解决constructor被篡改的问题</span></span><br><span class="line"><span class="comment">// 相当于 A.prototype.__proto__ = B.prototype</span></span><br></pre></td></tr></table></figure>

<p>A instanceof B  a是b的实例吗<br>A.prototype.isPrototypeOf(B)  a是b的原型吗</p>
<h2 id="其他继承方案"><a href="#其他继承方案" class="headerlink" title="其他继承方案"></a>其他继承方案</h2><ul>
<li>借用构造函数： <ul>
<li>并没有改变原型链，只是调用了超类中的语句 <code>SuperType.call(this)</code></li>
</ul>
</li>
<li>组合继承:<ul>
<li>原型链 继承 原型属性和方法</li>
<li>使用构造函数继承 实例属性</li>
</ul>
</li>
<li>原型式继承： <ul>
<li>通过一个已存在的对象创建另一个相似对象，不用写构造函数</li>
<li>Object.create()</li>
<li>引用属性会被共享</li>
</ul>
</li>
<li>寄生式继承： <ul>
<li>在 <strong>原型式继承</strong> 产生的实例上直接添加属性和方法</li>
</ul>
</li>
<li>寄生组合式继承: <ul>
<li>组合继承中的new SuperType（）替换成 Object.create(superType.prototype) <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);</span><br><span class="line"><span class="comment">// 原型链式继承中 new SuperType（）替换成 Object.create(superType.prototype)，减少一次父类构造函数调用</span></span><br><span class="line">subType.prototype = prototype;                      <span class="comment">// 原型链式继承1</span></span><br><span class="line">prototype.constructor = subType;                    <span class="comment">// 原型链式继承2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>混入式继承： <code>Object.assign(MyClass.prototype, OtherSuperClass.prototype);</code></li>
<li>ES6 类继承：extends实现和寄生组合式继承方式一样</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/js-prototype.jpg" alt="prototypr"></p>
<h1 id="高阶函数map-filter-reduce"><a href="#高阶函数map-filter-reduce" class="headerlink" title="高阶函数map/filter/reduce"></a>高阶函数map/filter/reduce</h1><p>const arr1 = [1, 2, 3, 4, 0];</p>
<h2 id="Array-prototypr-map"><a href="#Array-prototypr-map" class="headerlink" title="Array.prototypr.map"></a>Array.prototypr.map</h2><p>const arr2 = arr1.map((item,index,self) =&gt; item * 2);// [2,4,6,8,0]</p>
<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h2><p>let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {<br>  return accumulator + currentValue;<br>},100); // 110</p>
<h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h2><p>const arr2 = arr1.filter( (element, index, self) =&gt; {<br>    return self.indexOf( element ) === index + 1;<br>}); // [1, 2, 3, 4]</p>
<h2 id="isType"><a href="#isType" class="headerlink" title="isType"></a>isType</h2><p>let isString = obj =&gt; Object.prototype.toString.call( obj ) === ‘[object String]’;</p>
<p>let isArray = obj =&gt; Object.prototype.toString.call( obj ) === ‘[object Array]’;</p>
<p>let isNumber = obj =&gt; Object.prototype.toString.call( obj ) === ‘[object Number]’;</p>
<p><a href="https://www.cnblogs.com/zhizhic/p/9988947.html" target="_blank" rel="noopener">js判断变量是不是数组的方法</a></p>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return [].concat.(...this.map(item =&gt;(Array.isArray(item)?item.flat():[item])))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> item<span class="number">-0</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arr.flat()</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="keyword">this</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组乱序"><a href="#数组乱序" class="headerlink" title="数组乱序"></a>数组乱序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="script-引入方式"><a href="#script-引入方式" class="headerlink" title="script 引入方式"></a>script 引入方式</h1><ul>
<li><p>html 静态<code>&lt;script&gt;</code>引入</p>
</li>
<li><p>js 动态插入<code>&lt;script&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">'test.js'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadJsCode</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    <span class="comment">//for Chrome Firefox Opera Safari</span></span><br><span class="line">    script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">    <span class="comment">//for IE</span></span><br><span class="line">    <span class="comment">//script.text = code;</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadJsCode(<span class="string">'alert(2)'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;script defer&gt;</code>:异步加载，元素解析完成后执行,但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成</p>
</li>
<li><p><code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染  下载完后立即执行</p>
<ul>
<li>没有这两个标签 浏览器会在遇到js代码就立即执行，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</li>
<li>两者都会并行下载，不会影响页面的解析 defer会在元素渲染完之后执行 ，async下载完后立即执行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>IIFE和函数表达式</title>
    <url>/2018/11/21/IIFE%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 带函数名的函数表达式（var）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"变量名:"</span>, a) <span class="comment">// 函数名: [Function: b]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"函数名:"</span>, b) <span class="comment">// 函数名: [Function: b]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 带函数名的函数表达式（let）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"变量名:"</span>, a) <span class="comment">//  变量名: [Function: b]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"函数名:"</span>, b) <span class="comment">//  函数名: [Function: b]</span></span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  b = <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"变量名:"</span>, a) <span class="comment">//  10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"函数名:"</span>, b) <span class="comment">//  函数名: [Function: b]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 带函数名的IIFE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log("变量名:", a) //  ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"函数名:"</span>, b) <span class="comment">//  函数名: [Function: b]</span></span><br><span class="line">    <span class="comment">// a = 10                  // ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">  b = <span class="number">100</span></span><br><span class="line">    <span class="comment">// console.log("变量名:", a) //  ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"函数名:"</span>, b) <span class="comment">//  函数名: [Function: b]</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript知识点整理</title>
    <url>/2018/11/21/js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="map传参"><a href="#map传参" class="headerlink" title="map传参"></a>map传参</h1><p>[‘1’, ‘2’, ‘3’].map(parseInt)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>)</span>&#123;   </span><br><span class="line">    <span class="comment">// Return element for new_array   </span></span><br><span class="line"> &#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<ul>
<li>callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</li>
<li>parseInt(string, radix) 接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。<br>返回[1, NaN, NaN]</li>
</ul>
<h1 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖 节流"></a>防抖 节流</h1><p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的情况会每隔一定时间（参数wait）调用函数。</p>
<a id="more"></a>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 立即执行的情况</span></span><br><span class="line">        <span class="comment">// if (immediate) &#123;</span></span><br><span class="line">        <span class="comment">//     // 如果已经执行过，不再执行</span></span><br><span class="line">        <span class="comment">//     var callNow = !timeout;</span></span><br><span class="line">        <span class="comment">//     timeout = setTimeout(function()&#123;</span></span><br><span class="line">        <span class="comment">//         timeout = null;</span></span><br><span class="line">        <span class="comment">//     &#125;, wait)</span></span><br><span class="line">        <span class="comment">//     if (callNow) func.apply(context, args)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// else &#123;</span></span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h1><h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><ul>
<li>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</li>
<li>Set 是以 [value, value]的形式储存元素，</li>
<li>向 Set 加入值的时候，不会发生类型转换(类似于a 不等于 “a”, NaN等于 NaN)</li>
<li>遍历方法：keys(）等价于values()、entries()、forEach()</li>
</ul>
<h2 id="字典Map"><a href="#字典Map" class="headerlink" title="字典Map"></a>字典Map</h2><ul>
<li>Map 是以 [key, value] 的形式储存</li>
<li>new Map([[key1,value1],[key2,value2],[key3,value3]])</li>
<li>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样就视为两个键</li>
</ul>
<h3 id="Tips：变量回收"><a href="#Tips：变量回收" class="headerlink" title="Tips：变量回收"></a>Tips：变量回收</h3><p>Javascript是可以使用delete来手动删除变量，通过这样的方法让GC来回收内存，但在JS中并不是所有的对象都可以被删除的，delete 在JS中通过 var\function 声明因含有DontDelete，而不可被删除； 但是对象的属性、数组成员却是可以删除的； 因此如果我们要回收某个对象可以使用Object来封装一下。</p>
<h3 id="Tips：弱引用"><a href="#Tips：弱引用" class="headerlink" title="Tips：弱引用"></a>Tips：弱引用</h3><p>WeakSet/WeakMap 中对对象的引用不会被考虑进垃圾回收机制，即只要没有其他的对象引用该对象，则该对象就会被回收，而不管它在不在 WeakSet。弱引用不需要手动null。</p>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 和 Set 类似，都是不重复的值的集合，但是和 Set 有两点不同：</p>
<ol>
<li><p>WeakSet 只能存放对象</p>
</li>
<li><p>WeakSet 的对象都是弱引用</p>
<blockquote>
<p>WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收<br>WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在</p>
</blockquote>
</li>
<li><p>WeakSet 没有size属性，不支持遍历（故没有 forEach 方法)</p>
<blockquote>
<p>垃圾回收机制何时运行是不可预测的，所以 ES6 规定 WeakSet 不能被遍历</p>
</blockquote>
<p>JavaScript 会在执行内存回收时，清除掉 被引用次数为0 的那部分内存；而 WeakSet 是只能储存对象的（或者说只能储存内存指针而非静态值）、并且它对对象的引用将不计入对象的引用次数，当清除对象属性、对应的内存被清理之后，WeakSet 中记录的内存地址上不再有内容，它将自动断开与这条引用的关联 —— 也正因如此，它所储存的内容会受到开发者对其他对象操作的被动影响，所以 WeakSet 在设计上就设计成了没有“长度”、“遍历”概念的特殊弱引用 Set 型。</p>
</li>
</ol>
<p>应用场景：用于存储DOM节点，而不用担心这些节点从文档移除时会引发内存泄露</p>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ol>
<li>WeakMap只能接受对象作为键名字(null除外)</li>
<li>WeakMap键名指向对象不会计入对象的引用数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(counter, action) &#123;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.set(<span class="keyword">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.get(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br></pre></td></tr></table></figure>
Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</li>
</ol>
<h1 id="ES5-ES6-的继承区别"><a href="#ES5-ES6-的继承区别" class="headerlink" title="ES5/ES6 的继承区别"></a>ES5/ES6 的继承区别</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">A.__proto__ === B;  <span class="comment">//继承属性</span></span><br><span class="line">A.prototype.__proto__ == B.prototype;<span class="comment">//继承方法</span></span><br></pre></td></tr></table></figure>

<p><img src="http://103.14.34.148:9000/imgs/blog/img/100-js-prototype.jpg" alt="es5/6继承"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colorpoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y,color)&#123;</span><br><span class="line">        <span class="keyword">super</span>(x,y); <span class="comment">//调用父类的constructor(x,y)</span></span><br><span class="line">        <span class="keyword">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="comment">//调用父类的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。因此，只有调用super之后，才可以使用this关键字。</p>
<p>Tips:</p>
<ul>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li>
<li>class 必须使用 new 调用</li>
</ul>
<h1 id="3-个判断数组的方法"><a href="#3-个判断数组的方法" class="headerlink" title="3 个判断数组的方法"></a>3 个判断数组的方法</h1><ul>
<li><p>Object.prototype.toString.call([]); // “[object Array]”</p>
<ul>
<li>Object.prototype.toString.call(‘An’) // “[object String]”</li>
<li>Object.prototype.toString.call(1) // “[object Number]”</li>
<li>Object.prototype.toString.call(Symbol(1)) // “[object Symbol]”</li>
<li>Object.prototype.toString.call(null) // “[object Null]”</li>
<li>Object.prototype.toString.call(undefined) // “[object Undefined]”</li>
<li>Object.prototype.toString.call(function(){}) // “[object Function]”</li>
<li>Object.prototype.toString.call({name: ‘An’}) // “[object Object]”</li>
</ul>
</li>
<li><p>[]  instanceof Array; // true  </p>
<ul>
<li>instanceof是判断类型的prototype是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// Object.setPrototypeOf(obj, Array.prototype)</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Array.isArray([]) // true</p>
</li>
</ul>
<h1 id="let-和-const-声明的全局变量"><a href="#let-和-const-声明的全局变量" class="headerlink" title="let 和 const 声明的全局变量"></a>let 和 const 声明的全局变量</h1><p>并没有在全局对象中，只是一个块级作用域（Script）中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//1       有暂时性死区，a不能在let声明前调用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="IIFE-立即执行函数表达式-和函数表达式与函数声明与匿名函数"><a href="#IIFE-立即执行函数表达式-和函数表达式与函数声明与匿名函数" class="headerlink" title="IIFE(立即执行函数表达式)和函数表达式与函数声明与匿名函数"></a>IIFE(立即执行函数表达式)和函数表达式与函数声明与匿名函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'use strict' // TypeError: Assignment to constant variable.</span></span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a() <span class="comment">// [Function: b]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></li>
<li>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</li>
<li>IIFE中的函数是函数表达式，而不是函数声明。</li>
<li><strong>在非匿名自执行函数中，函数变量为只读状态无法修改</strong>；</li>
</ul>
<h1 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">102</span>, <span class="number">22</span>].sort();</span><br><span class="line"><span class="comment">// [102, 15, 22, 29, 3, 8]</span></span><br><span class="line"></span><br><span class="line"> [<span class="number">3</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">102</span>, <span class="number">22</span>].sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;<span class="keyword">return</span> a - b&#125;);</span><br><span class="line"> <span class="comment">// [3, 8, 15, 22, 29, 102]</span></span><br></pre></td></tr></table></figure>

<h1 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h1><p><strong>当对象的length属性为非负整数，同时splice属性为函数时， 对象就变成伪数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'2'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">'length'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'splice'</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="number">1</span>)</span><br><span class="line">obj.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类数组（ArrayLike）：<br>一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike的出现则提供了一个中间数据桥梁，ArrayLike有数组的特性， 但是对ArrayLike的扩展并不会影响到原生的数组。</p>
</li>
<li><p>push方法：<br>push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。 唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。</p>
</li>
</ul>
<h1 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h1><ul>
<li>Function.prototype.apply和Function.prototype.call 的作用是一样的，区别在于传入参数的不同；</li>
<li>第一个参数都是，指定函数体内this的指向；</li>
<li>第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply把它传给函数作为参数，call从第二个开始传入的参数是不固定的，都会传给函数作为参数。</li>
<li><a href="https://blog.csdn.net/QDY5945/article/details/101671581" target="_blank" rel="noopener">call比apply的性能要好</a>，平常可以多用call。例如obj.call(obj, …params)</li>
</ul>
<h1 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h1><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li>没有 this，它会从自己的作用域链的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）；</li>
<li>没有 arguments，当在箭头函数中调用 aruguments 时同样会向作用域链中查询结果；</li>
<li>没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto，同时执行一次构造函数绑定this，所以箭头函数无法new</li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>let obj = new Object()<br>let Con = [].shift.call(arguments)<br>obj.<strong>proto</strong> = Con.prototype<br>Con.call(obj,arguments) </p>
<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><ul>
<li>普通函数 this是看情况指向的，一般优先级是 new &gt; bind &gt; obj. &gt; window </li>
</ul>
<h1 id="a-b-c-d-和-a-‘b’-‘c’-‘d’-，性能比较"><a href="#a-b-c-d-和-a-‘b’-‘c’-‘d’-，性能比较" class="headerlink" title="a.b.c.d 和 a[‘b’][‘c’][‘d’]，性能比较"></a>a.b.c.d 和 a[‘b’][‘c’][‘d’]，性能比较</h1><p>a.b.c.d 比 a[‘b’][‘c’][‘d’] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> recast = <span class="built_in">require</span>(<span class="string">'recast'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code1 = <span class="string">`a.b.c.d`</span></span><br><span class="line"><span class="keyword">const</span> code2 = <span class="string">`a['b']['c']['d']`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="keyword">const</span> ast1 = recast.parse(code1);</span><br><span class="line"><span class="keyword">const</span> ast2 = recast.parse(code2);</span><br></pre></td></tr></table></figure>

<h1 id="ES6-转ES5"><a href="#ES6-转ES5" class="headerlink" title="ES6 转ES5"></a>ES6 转ES5</h1><ul>
<li>AST 抽象语法树：将代码逐字母解析成 树状对象 的形式<br>Babel + polyfill<br>Babel编译原理：</li>
<li>解析：babylon 将 ES6/ES7 代码解析成 AST</li>
<li>转换：babel-traverse 对 AST 进行遍历转译，得到新的 AST</li>
<li>生成：新 AST 通过 babel-generator 转换成 ES5<br>.vue文件通过webpack的vue-loader分析出script style template 再走上面的ES6转ES5流程</li>
</ul>
<h1 id="普通-for-循环的性能远远高于-forEach-的性能"><a href="#普通-for-循环的性能远远高于-forEach-的性能" class="headerlink" title="普通 for 循环的性能远远高于 forEach 的性能"></a>普通 for 循环的性能远远高于 forEach 的性能</h1><h1 id="数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少"><a href="#数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少" class="headerlink" title="数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少"></a>数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少</h1><p>数组元素的存储方式并不是连续的，而是哈希映射关系。哈希映射关系，可以通过键名 key，直接计算出值存储的位置</p>
<p>得出结论：消耗时间几乎一致，差异可以忽略不计</p>
<h1 id="对象的键名的转换"><a href="#对象的键名的转换" class="headerlink" title="对象的键名的转换"></a>对象的键名的转换</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">'123'</span>, c=<span class="number">123</span>;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);  <span class="comment">// 'c'</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>);  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);  <span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;   <span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;   <span class="comment">// 这里会把 b 覆盖掉。</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">// 'c'</span></span><br></pre></td></tr></table></figure>
<p>对象的键名只能是字符串和 Symbol 类型。<br>其他类型的键名会被转换成字符串类型。<br>对象转字符串默认会调用 Object原型上的toString 方法。</p>
<h1 id="var、let-和-const-区别的实现原理"><a href="#var、let-和-const-区别的实现原理" class="headerlink" title="var、let 和 const 区别的实现原理"></a>var、let 和 const 区别的实现原理</h1><p>变量生命周期：<strong>声明</strong>（作用域注册一个变量）、<strong>初始化</strong>（分配栈内存，初始化为undefined）、<strong>赋值</strong></p>
<ul>
<li>var：遇到有var的作用域，在任何语句执行前都已经完成了<strong>声明</strong>和<strong>初始化</strong>，也就是变量提升而且拿到undefined的原因由来</li>
<li>function： <strong>声明、初始化、赋值</strong>一开始就全部完成，所以函数的变量提升优先级更高</li>
<li>const、class、let：解析器进入一个块级作用域，发现let关键字，变量只是先完成<strong>声明</strong>，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// undefined;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);       <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><ul>
<li>let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。 </li>
<li>var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined </li>
<li>function 的创建、初始化、赋值都被提升了</li>
</ul>
<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数声明 声明和定义都会提前<br>函数表达式 var a =function(){}声明和定义不会提前</p>
<p>带函数名的函数表达式，var a =function b(){}它的函数名b只在函数内部有效，并且此绑定属于常量绑定。<br>带函数名的IIFE，var a =(function b(){})() 函数名b为 只读 状态，无法修改,变量名a在函数内部无法访问（块作用域）<br><a href="./IIFE和函数表达式.js">js样例</a></p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul>
<li>let 声明的变量的作用域是块级的；</li>
<li>let 不能重复声明已存在的变量；</li>
<li>let 有暂时死区，不会被提升。</li>
</ul>
<h1 id="js值传递"><a href="#js值传递" class="headerlink" title="js值传递"></a>js值传递</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeObjProperty</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">  o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.google.com"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> webSite = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">changeObjProperty(webSite);</span><br><span class="line"><span class="built_in">console</span>.log(webSite.siteUrl); <span class="comment">// http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<h1 id="函数的方法挂载"><a href="#函数的方法挂载" class="headerlink" title="函数的方法挂载"></a>函数的方法挂载</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Foo.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行</span></span><br><span class="line"></span><br><span class="line">Foo.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3</span></span><br><span class="line"></span><br><span class="line">Foo.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在在 Foo 上挂载了直接方法 a ，输出值为 4</span></span><br><span class="line"></span><br><span class="line">Foo.a();</span><br><span class="line"><span class="comment">// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以</span></span><br><span class="line"><span class="comment">// # 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：</span></span><br><span class="line"><span class="comment">1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。</span></span><br><span class="line"><span class="comment">2. 在新对象上挂载直接方法 a ，输出值为 2。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">obj.a();</span><br><span class="line"><span class="comment">// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，</span></span><br><span class="line"><span class="comment">// # 输出 2</span></span><br><span class="line"></span><br><span class="line">Foo.a();</span><br><span class="line"><span class="comment">// 构建方法里已经替换了全局 Foo 上的 a 方法，所以</span></span><br><span class="line"><span class="comment">// # 输出 1</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串String-‘11’-‘11’"><a href="#字符串String-‘11’-‘11’" class="headerlink" title="字符串String(‘11’) === ‘11’"></a>字符串String(‘11’) === ‘11’</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="string">'11'</span>) == <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'11'</span>); <span class="comment">// 实际运行的是 String('11') == new String('11').toString();</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">'11'</span>) === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'11'</span>);</span><br></pre></td></tr></table></figure>

<h1 id="var无视块级作用域"><a href="#var无视块级作用域" class="headerlink" title="var无视块级作用域"></a>var无视块级作用域</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Tom'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'name'</span>, name); <span class="comment">// name undefined</span></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'typeof name'</span>, <span class="keyword">typeof</span> name); <span class="comment">//typeof name undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name); <span class="comment">// Goodbye Jack</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>undefined </span></figcaption><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;typeof null &#x3D;&#x3D;&#x3D; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Tom'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'name'</span>, name); <span class="comment">// name tom</span></span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'typeof name'</span>, <span class="keyword">typeof</span> name); <span class="comment">// typeof name string</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> name == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  name = <span class="string">'Jack'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);   <span class="comment">// Hello Tom</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>1、首先在进入函数作用域当中，获取name属性<br>2、在当前作用域没有找到name<br>3、通过作用域链找到最外层，得到name属性<br>4、执行else的内容，得到Hello Tom</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p>
<ul>
<li>-、*、/、% ：一律转换成数值后计算</li>
<li>+：<ul>
<li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li>
<li>数字 + 对象， 优先调用对象的valueOf -&gt; toString</li>
<li>数字 + boolean/null -&gt; 数字</li>
<li>数字 + undefined -&gt; NaN</li>
</ul>
</li>
<li>[1].toString() === ‘1’</li>
<li>{}.toString() === ‘[object object]’</li>
<li>NaN !== NaN 、+undefined 为 NaN<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3></li>
<li>typeof （number boolean object function string undefined）<ul>
<li>NaN 的数据类型是 number</li>
<li>数组(Array)的数据类型是 object</li>
<li>日期(Date)的数据类型为 object</li>
<li><strong>null 的数据类型是 object</strong>  String(null) 来判断</li>
<li>未定义变量的数据类型为 undefined</li>
</ul>
</li>
<li>instanceof （Array Date RegExp Object）</li>
<li>constructor 返回构造函数</li>
<li>Object.prototype.toString() 返回[Object XXX] 来判断<h1 id="加性操作符，乘性操作符"><a href="#加性操作符，乘性操作符" class="headerlink" title="加性操作符，乘性操作符"></a>加性操作符，乘性操作符</h1>1 + “1”<br>加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li>
</ul>
<p>所以值为：“11”</p>
<p>2 * “2”<br>乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</p>
<p>[1, 2] + [2, 1]<br>Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。</p>
<p>所以两个数组对象的toString方法相加，值为：”1,22,1”</p>
<p>“a” + + “b”<br>后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。</p>
<h1 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'first time'</span>, t2 - t1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t3 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'two time'</span>, t3 - t2)</span><br></pre></td></tr></table></figure>

<p>两个循环的次数的是一样的，但是 j 与 k 的初始化次数是不一样的</p>
<p>第一个循环的 j 的初始化次数是 100 次，k 的初始化次数是 10w 次<br>第二个循环的 j 的初始化次数是 1w 次， k 的初始化次数是 1000w 次</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/2018/11/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof null //"object"</span></span><br><span class="line"><span class="comment">// typeof &#123;&#125; //"object"</span></span><br><span class="line"><span class="comment">// typeof [] //"object"</span></span><br><span class="line"><span class="comment">// typeof function foo()&#123;&#125; //"function" (特殊情况)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source;</span><br><span class="line">  <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); <span class="comment">// 新增代码，查哈希表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">  hash.set(source, target); <span class="comment">// 新增代码，哈希表设值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">        target[key] = cloneDeep3(source[key], hash); <span class="comment">// 新增代码，传入哈希表</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2018/11/21/WebSocket/</url>
    <content><![CDATA[<h2 id="WebSocket-Socket-IO"><a href="#WebSocket-Socket-IO" class="headerlink" title="WebSocket Socket.IO"></a>WebSocket Socket.IO</h2><p><img src="http://103.14.34.148:9000/imgs/blog/img/websocket.jpg" alt=""><br><a href="https://blog.csdn.net/feng98ren/article/details/86240287" target="_blank" rel="noopener">参考</a></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>即时通讯，推送的实现发展</p>
<ul>
<li>短轮询，client 每隔一段时间都会向 server 发送 http 请求，服务器收到请求后，将最新的数据发回给 client。</li>
<li>长轮询，client 向 server 发出请求，server 接收到请求后，server 并不一定立即发送回应给 client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 client；但如果数据没有更新，那就把这个请求保持住，等待有新的数据到来时，才将数据返回给 client。</li>
<li>流技术，一直保持连接，不需要 client 请求，当数据发生改变时，server 自动的将数据发送给 client，这种方式有一个明显的不足之处，网页会一直显示未加载完成的状态。</li>
</ul>
<h4 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>W3C 在 HTML5 中提供了一种 client 与 server 间进行<strong>全双工通讯</strong>的网络技术 WebSocket。WebSocket 是一个全新的、独立的<strong>协议</strong>，基于 TCP 协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分。</p>
<p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 <strong>server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<h3 id="node-js-Socket-WebSocket"><a href="#node-js-Socket-WebSocket" class="headerlink" title="node.js Socket WebSocket"></a>node.js Socket WebSocket</h3><p>Socket本身并不是协议，是对TCP/IP协议的封装，是一个调用接口。</p>
<p>Node.js中提供了net模块，该模块提供了对TCP、Socket的封装与支持，它包含了创建TCP服务器/客户端的方法。</p>
<p>在Node.js中可以使用http模块轻松创建HTTP服务器或HTTP客户端，https模块是其安全版本。http模块在net模块之上构建，所以net模块中的大部分功能都可以在http模块中使用。</p>
<p>WebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP）</p>
<h3 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h3><p>Socket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>io.on</li>
<li>io.emit</li>
<li>socket.emit</li>
<li>socket.on</li>
<li>socket.broadcast.emit …<br><a href="https://socket.io/docs/server-api/" target="_blank" rel="noopener">server-api</a></li>
</ul>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = io();</span><br><span class="line">socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span><br><span class="line">socket.on(<span class="string">'msg'</span>,data=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://socket.io/docs/client-api/" target="_blank" rel="noopener">client-api</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
</search>
