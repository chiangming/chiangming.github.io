<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Matt&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

</html>

  <body>
    <div id="app">
      <main class="content">
        
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Matt&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-vue源码/6.组件更新" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/6.%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/"
    >6.组件更新</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/6.%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/" class="article-date">
  <time datetime="2019-12-21T16:15:31.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><ul>
<li>在响应式数据发送改变时， 会触发 订阅的 watcher 的 更新 </li>
<li>再次调用 vm._update(vm._render(),…)</li>
<li>其中会 执行 patch ，这是因为有旧的 渲染vnode，所以 会传入 <code>vm.$el = vm.__patch__(prevVnode, vnode)</code></li>
<li>在patch的过程中，会和首次渲染不同，这次会比较新旧vnode是否相同，<code>sameVnode(oldVnode, vnode)</code>，主要通过 key ，tag …判断
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/6.%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-vue源码/3.组件化" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/3.%E7%BB%84%E4%BB%B6%E5%8C%96/"
    >3.组件化</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/3.%E7%BB%84%E4%BB%B6%E5%8C%96/" class="article-date">
  <time datetime="2019-12-21T16:15:30.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>首先一个 生成 Vue 实例，在执行其render的过程中，createComponent 会  生成 其组件vue构造函数，安装组件钩子函数,在new Vnode 传入构造函数生成 组件的 占位符 vnode</li>
<li>在 update -&gt; patch -&gt; createElm 中，通过调用 createComponent 来为 component组件占位符vnode节点 生成 vm 实例，以此触发 其 init 函数</li>
<li>在 init 函数中 会调用 vm实例的 mount 方法 -&gt; createElm ,这时的 vm实例中的 vnode不再是一个 组件，而是渲染vnode（渲染vnode就是组件最外层的标签），所以会 生成该vnode的真实dom，在对 子vnode进行渲染，执行 createChildren -&gt; createElm。<ul>
<li>如果不是 组件（组件 vnode 是有 复制的Vue对象，会有 init方法，vnode.data.hook.init） ，则 生成 真实 dom ，在 createElm 中 完成插入 父dom 中</li>
<li>如果是 组件 ，则重复上述 </li>
</ul>
</li>
<li>组件渲染完成后 ，占位符节点 在 createComponent 中 完成 插入到 dom 操作（渲染组件 vnode 由于没有parentElm （因为vuecomponent.$el 不存在），所以不会进行插入操作，渲染组件vnode.elm 会被赋值给 占位符vnode生成的vue实例 vm.$el, vm会被赋值给 占位符 vnode.componentInstance,在 占位符vnode进行插入dom时，调用 initComponent 会将占位符 vnode.componentInstance.$el 传给 占位符 vnode.elm ）</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComponent</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.data.pendingInsert)) &#123;</span><br><span class="line">        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><br><span class="line">        vnode.data.pendingInsert = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// !! --&gt; 将vue实例的dom实例 挂载到占位符vnode上</span></span><br><span class="line">      vnode.elm = vnode.componentInstance.$el; </span><br><span class="line">      <span class="comment">// &lt;-- !!</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue);</span><br><span class="line">        setScope(vnode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// empty component root.</span></span><br><span class="line">        <span class="comment">// skip all element-related modules except for ref (#3455)</span></span><br><span class="line">        registerRef(vnode);</span><br><span class="line">        <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line">        insertedVnodeQueue.push(vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="creayeElement-gt-createComponent-生成Vnode"><a href="#creayeElement-gt-createComponent-生成Vnode" class="headerlink" title="_creayeElement -&gt; createComponent 生成Vnode"></a>_creayeElement -&gt; createComponent 生成Vnode</h2><blockquote>
<p>$mount(挂载的dom实例)</p>
</blockquote>
<ol>
<li><p>根据tag类型，如果能在当前vm实例中<code>context.$options.components</code>中找到 tag ，那么这就是一个组件 ，则调用<code>createComponent()</code></p>
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/3.%E7%BB%84%E4%BB%B6%E5%8C%96/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-vue源码/2.生命周期" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >2.生命周期</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2019-12-21T16:15:29.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <ul>
<li><p>_init</p>
<ul>
<li>beforeCreate (initLifeCycle,initEvents,initRender)</li>
<li>created 可以获得data,props (initInjections,initState,initProvide)，在这里已经完成了 数据data computed的响应式处理以及 watch event的事件回调
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-vue源码/1.数据驱动" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"
    >1.数据驱动</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2019-12-21T16:15:28.000Z" itemprop="datePublished">2019-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                          <h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化，在Vue原型上部署各种方法，</li>
<li><code>new Vue</code>时执行<code>Vue.prototype._init()</code><ul>
<li>initState() =&gt; initData()</li>
</ul>
</li>
<li>执行 <code>Vue.prototype.$mount</code><ul>
<li>编译生成 render 函数</li>
<li>mountComponent <ul>
<li>new Watcher =&gt; this.get =&gt; this.getter() =&gt; vm._update(vm._render(), hydrating)</li>
</ul>
</li>
<li>Vue.prototype._render()<ul>
<li>render.call(vm._renderProxy, vm.$createElement)</li>
</ul>
</li>
<li>Vue.prototype._update()<ul>
<li>patch()
                            
                              <a class="article-more-link" href="/2019/12/22/vue%E6%BA%90%E7%A0%81/1.%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/">
                                阅读更多...
                              </a>
                              
                                

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/css" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/css/"
    >css题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/css/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现"><a href="#第1天-圣杯布局和双飞翼布局的理解和区别，并用代码实现" class="headerlink" title="第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现"></a>第1天 圣杯布局和双飞翼布局的理解和区别，并用代码实现</h1><p><a href="https://www.jianshu.com/p/81ef7e7094e8" target="_blank" rel="noopener">答案</a></p>
<h1 id="第2天-CSS3有哪些新增的特性？"><a href="#第2天-CSS3有哪些新增的特性？" class="headerlink" title="第2天 CSS3有哪些新增的特性？"></a>第2天 CSS3有哪些新增的特性？</h1><p>边框圆角<br>border-radius<br>盒子阴影<br>box-shadow<br>文字阴影<br>text-shadow<br>2d、3d变换<br>transform<br>rotate()<br>scale()<br>skew()<br>translate()<br>过度动画<br>transition<br>自定义动画<br>animation</p>
<h1 id="第3天-在页面上隐藏元素的方法有哪些？"><a href="#第3天-在页面上隐藏元素的方法有哪些？" class="headerlink" title="第3天 在页面上隐藏元素的方法有哪些？"></a>第3天 在页面上隐藏元素的方法有哪些？</h1><p>disaplay: none; 页面不会渲染<br>visibility: hidden; 页面会渲染只是不限显示<br>opacity: 0; 看不见，但是会占据空间,可以点击</p>
<h1 id="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"><a href="#CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？"></a>CSS选择器有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先？</h1><p><a href="https://blog.csdn.net/sjinsa/article/details/70768483" target="_blank" rel="noopener">答案</a></p>
<p>!important &gt; 内联样式 &gt; id &gt; class(属性选择器[]、伪类 :) &gt; 标签(伪元素) &gt; 通用选择器 &gt; 继承 &gt; 默认</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/html" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/html/"
    >html题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/html/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">"***.css"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>link是HTML标签，@import是css提供的。</li>
<li>link引入的样式页面加载时同时加载，@import引入的样式需等页面加载完成后再加载。</li>
<li>link没有兼容性问题，@import不兼容ie5以下。</li>
<li>link可以通过js操作DOM动态引入样式表改变样式，而@import不可以。</li>
</ol>
<h1 id="html的元素有哪些（包含H5）？"><a href="#html的元素有哪些（包含H5）？" class="headerlink" title="html的元素有哪些（包含H5）？"></a>html的元素有哪些（包含H5）？</h1><p>行内元素<br>a<br>b<br>span<br>i<br>em<br>strong<br>block<br>input<br>button<br>select<br>form<br>块级元素<br>div<br>p<br>ul<br>ol<br>li<br>h1~h6<br>textarea<br>H5新增<br>header<br>section<br>asize<br>footer<br>nav<br>article</p>
<h1 id="HTML5的文件离线储存怎么使用，工作原理是什么？"><a href="#HTML5的文件离线储存怎么使用，工作原理是什么？" class="headerlink" title="HTML5的文件离线储存怎么使用，工作原理是什么？"></a>HTML5的文件离线储存怎么使用，工作原理是什么？</h1><h2 id="1、cookie"><a href="#1、cookie" class="headerlink" title="1、cookie"></a>1、cookie</h2><p>（1）本身用于客户端和服务端通信<br>（2）但是它有本地存储的功能，于是就被“借用”<br>（3）document.cookie = …获取和修改即可<br>（4）cookie用于存储的缺点<br>①存储量太小，只有4kb<br>②所有http请求都带着，会影响获取资源的效率<br>③api简单，需要封装才能用document.cookie</p>
<h2 id="2、localStorage-sesseionStorage"><a href="#2、localStorage-sesseionStorage" class="headerlink" title="2、localStorage,sesseionStorage"></a>2、localStorage,sesseionStorage</h2><p>（1）html5专门为存储而设计，最大容量5M<br>（2）api简单易用<br>（3）lcoalStorage.setItem(key, value);localStorage.getItem(key);<br>（4）ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装 </p>
<h2 id="3、sessionStorage"><a href="#3、sessionStorage" class="headerlink" title="3、sessionStorage"></a>3、sessionStorage</h2><p>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h2 id="LocalForage"><a href="#LocalForage" class="headerlink" title="LocalForage"></a>LocalForage</h2><p>Mozilla 开发了一个叫 localForage 的库 ，使得离线数据存储在任何浏览器都是一项容易的任务。localForage 是一个使用非常简单的 JavaScript 库的，提供了 get，set，remove，clear 和 length 等等 API，还具有以下特点：<br>支持回调的异步 API；<br>支持 IndexedDB，WebSQL 和 localStorage 三种存储模式；<br>支持 BLOB 和任意类型的数据，让您可以存储图片，文件等。<br>支持 ES6 Promises</p>
<table>
<tr>
  <th></th><th>cookie</th><th>localstorage</th><th>sessionstorage</th><th>session</th>
</tr>
<tr>
  <td></td><td colspan="4" style="text-align:center">k-v存储 同域名可用</td>
</tr>
<tr>
  <td>存储位置</td><td colspan="3" style="text-align:center">客户端</td><td style="text-align:center">服务端</td>
</tr>
<tr>
  <td>特点</td><td style="text-align:center">随请求头每次提交</td><td style="text-align:center">不随头提交 可长时保存</td><td style="text-align:center">不随头提交页面关闭即失效</td><td style="text-align:center">安全</td>
</tr>
<tr>
  <td>跨页</td><td style="text-align:center" colspan="2">可跨页，不可跨域</td><td style="text-align:center">不可跨页，不可跨域</td><td style="text-align:center">可跨页，不可跨域</td>
</tr>
</table>


<h1 id="简述超链接target属性的取值和作用"><a href="#简述超链接target属性的取值和作用" class="headerlink" title="简述超链接target属性的取值和作用"></a>简述超链接target属性的取值和作用</h1><p><code>&lt;a&gt;</code> 标签的 target 属性规定在何处打开链接文档。</p>
<p>语法：<code>&lt;a target=&quot;value&quot;&gt;</code><br>属性值：<br>|值 |描述|<br>|–|–|<br>|_blank|在新窗口中打开被链接文档。|<br>|_self|默认。在相同的框架中打开被链接文档。|<br>|_parent|在父框架集中打开被链接文档。|<br>|_top|在整个窗口中打开被链接文档。|<br>|framename|在指定的框架中打开被链接文档。|</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/js" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/js/"
    >javascript题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/js/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"><a href="#用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值" class="headerlink" title="用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"></a>用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值</h1><blockquote>
<p>描述：这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）：<br>(a) 生成一个长度为5的空数组arr。<br>(b) 生成一个（2－32）之间的随机整数rand。<br>(c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到arr内[需要使用递归实现，不能使用for/while等循环]<br>(d) 最终输出一个长度为5，且内容不重复的数组arr。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildArray</span>(<span class="params">arr, length, min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">    <span class="keyword">if</span> (!arr.includes(num)) &#123; arr.push(num); &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length === length ? arr : buildArray(arr, length, min, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = buildArray([], <span class="number">5</span>, <span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">console</span>.table(result);</span><br></pre></td></tr></table></figure>

<h1 id="写一个方法去掉字符串中的空格"><a href="#写一个方法去掉字符串中的空格" class="headerlink" title="写一个方法去掉字符串中的空格"></a>写一个方法去掉字符串中的空格</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trim = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">str.replace(<span class="regexp">/\s*/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内所有的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内两头的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*/</span>,<span class="string">""</span>); <span class="comment">//去除字符串内左侧的空格</span></span><br><span class="line">str.replace(<span class="regexp">/(\s*$)/g</span>,<span class="string">""</span>); <span class="comment">//去除字符串内右侧的空格</span></span><br></pre></td></tr></table></figure>
<h1 id="写一个方法把下划线命名转成大驼峰命名"><a href="#写一个方法把下划线命名转成大驼峰命名" class="headerlink" title="写一个方法把下划线命名转成大驼峰命名"></a>写一个方法把下划线命名转成大驼峰命名</h1><p>function toCamelCase(str) {<br>  if (typeof str !== ‘string’) {<br>    return str;<br>  }<br>  return str<br>    .split(‘_’)<br>    .map(item =&gt; item.charAt(0).toUpperCase() + item.substr(1, item.length))<br>    .join(‘’);<br>}</p>
<h1 id="写一个把字符串大小写切换的方法"><a href="#写一个把字符串大小写切换的方法" class="headerlink" title="写一个把字符串大小写切换的方法"></a>写一个把字符串大小写切换的方法</h1><p>function caseConvertEasy(str) {<br>  return str.split(‘’).map(s =&gt; {<br>    if (s.charCodeAt() &lt;= 90) {<br>      return s.toLowerCase()<br>    }<br>    return s.toUpperCase()<br>  }).join(‘’)<br>}</p>
<h1 id="JavaScript跨域总结与解决办法"><a href="#JavaScript跨域总结与解决办法" class="headerlink" title="JavaScript跨域总结与解决办法"></a>JavaScript跨域总结与解决办法</h1><p><a href="https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3" target="_blank" rel="noopener">https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3</a></p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-interview/vue" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/23/interview/vue/"
    >Vue题目</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2019/11/23/interview/vue/" class="article-date">
  <time datetime="2019-11-22T16:15:39.000Z" itemprop="datePublished">2019-11-23</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h2 id="写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2><ul>
<li>考虑到DOM节点更改的性能问题，Vue使用vnode做虚拟dom节点进行更新</li>
<li>组件的更新，是通过每一个vue实例的watcher派发更新的，每一步更新都是更新一个vue实例对应的dom。因为update事件被推送到任务队列时，是按watcher的id从小到大进行排序，所以会先更新用户watcher，再更新父watcher，再更新子watcher</li>
<li>响应式数据的变化触发渲染watcher的updateComponment方法，执行vm._patch(vm._render,false)过程</li>
</ul>
<ol>
<li>_render() 生成当前vm实例 新的vnode</li>
<li>_update() 执行 patch方法，由于此时存在旧vnode，如果新旧vnode不同（key tag），会调用 patchVnode，如果是不同的vnode，createELm 创建新的dom，并删去旧的dom</li>
<li>patchVnode 主要是进行更新dom操作 <ul>
<li>新旧节点的孩子节点存在 且不同，调用diff算法</li>
<li>比较 新旧节点的文本，进行更新</li>
</ul>
</li>
<li>diff算法</li>
</ol>
<p>参考： <a href="https://segmentfault.com/a/1190000008782928" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008782928</a></p>
<p>在diff算法中vue只对同级的vnode节点进行比较，oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。<br>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找newStartVnode.key匹配的节点(没有设置key的话需要执行findIdxInOld方法去比较newStartVnode和所有的oldCh），所以为节点设置key可以更高效的利用dom。</p>
<p>对于带状态的组件渲染，唯一的key值在每次渲染列表时都会完全替换所有组件，使其拥有正确状态（而不是就地更新）。</p>
<h1 id="Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n"><a href="#Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n" class="headerlink" title="Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?"></a>Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ?</h1><ul>
<li>Vue的diff是同层级比较;</li>
<li>对于同一层级的一组子节点，通过分配唯一唯一id进行区分（key值）</li>
</ul>
<h1 id="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"><a href="#vuex中为什么把把异步操作封装在action，把同步操作放在mutations？" class="headerlink" title="vuex中为什么把把异步操作封装在action，把同步操作放在mutations？"></a>vuex中为什么把把异步操作封装在action，把同步操作放在mutations？</h1><p><a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="noopener">参考</a><br>尤雨溪：为了能用 devtools 追踪状态变化<br>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p>
<h1 id="双向绑定和-vuex-是否冲突？"><a href="#双向绑定和-vuex-是否冲突？" class="headerlink" title="双向绑定和 vuex 是否冲突？"></a>双向绑定和 vuex 是否冲突？</h1><p>在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案： 1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值 2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"message"</span>&gt; </span><br><span class="line">computed: &#123; </span><br><span class="line">    message: &#123; </span><br><span class="line">        <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message &#125;, <span class="keyword">set</span> (value) &#123; <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex的设计思想？"><a href="#Vuex的设计思想？" class="headerlink" title="Vuex的设计思想？"></a>Vuex的设计思想？</h1><p><img src="https://pic1.zhimg.com/80/v2-1b21813cd1d621658fe7402f0af4b104_hd.jpg" alt="vuex"><br>全局的 Store，包含着应用中的状态 State,这个 State 是单一的,子组件能通过 this.$store 访问到 state 。<br>Vuex 让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。</p>
<h2 id="Vuex初始化"><a href="#Vuex初始化" class="headerlink" title="Vuex初始化"></a>Vuex初始化</h2><p>state 的是按模块划分的，按模块的嵌套形成一颗状态树。注册对子module迭代执行初始化流程（path上附加上父路径）。<br>而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。</p>
<h2 id="mutations-只能执行同步操作"><a href="#mutations-只能执行同步操作" class="headerlink" title="mutations 只能执行同步操作"></a>mutations 只能执行同步操作</h2><p>store.commit(‘moduleA/incrementAge’)</p>
<ol>
<li>执行 store 的 commit函数</li>
<li>通过传入的 key值 来获得对应的用户自定义的mutaitons方法 <code>store._mutaitons[key]</code></li>
<li>在 store._withCommit 方法中 执行 mutations方法，为了保证对state的直接操作不会触发警告</li>
</ol>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">commit (type, payload, options) &#123;</span><br><span class="line">  <span class="comment">// check object-style commit</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = type</span><br><span class="line">    type = type.type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      handler(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!options || !options.silent) &#123;</span><br><span class="line">    <span class="keyword">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="keyword">this</span>.state))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> subscribe 订阅（注册监听）store 的 mutation，调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听</p>
<h2 id="actions-可以异步操作"><a href="#actions-可以异步操作" class="headerlink" title="actions 可以异步操作"></a>actions 可以异步操作</h2><ol>
<li>dispatch根据传入的 key 值 获得 用户自定义的 actions</li>
<li>执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">      ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">      : entry[<span class="number">0</span>](payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="keyword">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2></li>
<li>this.$store.getters.xxxgetters访问回调函数，</li>
<li>getter执行结果绑定到this.$store上。<ul>
<li>resetStoreVM 函数重置一个<strong>私有的 _vm 对象</strong>，保留<strong>state树</strong>，以及用<strong>计算属性的方式</strong>存储了 store 的 getters<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; store._vm[key]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>将数组转换成{key, val: key}的对象，将对象转换成{ key, val: obj[key] }的对象返回结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapState</span> (<span class="params">states</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">        ? val.call(<span class="keyword">this</span>, <span class="keyword">this</span>.$store.state, <span class="keyword">this</span>.$store.getters)</span><br><span class="line">        : <span class="keyword">this</span>.$store.state[val]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</h1><p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
<ul>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；(尤雨溪：defineProperty可以检测数组下标，但是收益与性能不成正比)</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
</ul>
<h1 id="Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？"><a href="#Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？" class="headerlink" title="Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？"></a>Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？</h1><p>双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view</p>
<p>vue.js 采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>要实现mvvm的双向绑定，就必须要实现以下几点： </p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 </li>
<li>实现一个指令解析器Compile(render+patch)，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br><img src="https://raw.githubusercontent.com/DMQ/mvvm/master/img/2.png" alt="MVVM"></li>
</ol>
<p>利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p>
<p>监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法</p>
<p>订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作</p>
<p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: </p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己 </li>
<li>自身必须有一个update()方法 </li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li>
</ol>
<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcher实例就能收到更新通知。</p>
<p>Component类中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._ob = observe(options.data)</span><br></pre></td></tr></table></figure>
<h2 id="model-gt-view"><a href="#model-gt-view" class="headerlink" title="model -&gt; view"></a>model -&gt; view</h2><p>数据驱动视图<br>在 vue 2.x 中 通过 </p>
<ul>
<li><p>observe添加数据响应</p>
<ul>
<li>给数据添加一个Observer对象实例附加在obj.<strong>ob</strong>上</li>
<li>defineProperty 实现的数据劫持</li>
<li>闭包形式给数据添加Dep实例</li>
</ul>
</li>
<li><p><strong>getter 收集依赖</strong></p>
<ul>
<li><strong>const dep = new Dep() // 实例化一个Dep实例</strong></li>
<li><strong>在get函数中通过dep.depend做依赖收集</strong></li>
</ul>
</li>
<li><p>什么时候触发getter收集依赖？</p>
<ul>
<li>实例化一个渲染watcher=&gt; watcher的构造函数=&gt;this.get()，<ul>
<li>get函数把Dep.target赋值为当前渲染watcher并压栈（为了恢复)</li>
</ul>
</li>
<li>vm._render()生成渲染VNode,并且在这个过程对vm上的数据访问触发getter</li>
<li>(在此期间执行Dep.target.addDep(this)方法，将watcher订阅到这个数据持有的dep的subs中，为后续数据变化时通知到哪些subs做准备)</li>
<li>每次数据变化都会vm._render()方法会再次执行，并再次触发数据</li>
</ul>
</li>
<li><p><strong>setter 调用更新回调</strong></p>
<ul>
<li><strong>childOb = !shallow &amp;&amp; observe(newVal) // 如果shallow为false的情况，会对新设置的值变成一个响应式对象</strong></li>
<li><strong>dep.notify() // 通知所有订阅者</strong></li>
</ul>
</li>
<li><p>派发过程：当我们组件中对响应的数据做了修改，就会触发setter的逻辑，最后调用dep.notify()方法，遍历依赖收集中建立的subs，也就是Watcher的实例数组【subs数组在依赖收集getter中被添加，期间通过一些逻辑处理判断保证同一数据不会被添加多次】，然后调用每一个watcher的update方法。</p>
</li>
<li><p>update函数中有个 <strong>queueWatcher(this)</strong> 方法引入了队列的概念，是vue在做派发更新时优化的一个点，它并不会每次数据改变都会触发watcher回调，而是把这些watcher先添加到一个队列中，然后在nextTick后执行watcher的run函数</p>
</li>
</ul>
<p>队列排序保证：</p>
<ul>
<li>组件的更新由父到子。父组件创建早于子组件，watcher的创建也是</li>
<li>用户自定义watcher要早于渲染watcher执行，因为用户自定义watcher是在渲染watcher前创建的</li>
<li>如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过，所以父组件的watcher应该先执行。</li>
</ul>
<p>队列遍历：排序完成后，对队列进行遍历，拿到对应的watcher,执行watcher.run()。 </p>
<ol>
<li>通过this.get()得到它当前的值,判断新旧值不同执行watcher回调</li>
<li>渲染watcher而言，在执行this.get()方法求值的时候，会执行getter方法，重新patch</li>
</ol>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul>
<li>Dep.target 全局唯一Watcher</li>
<li>this.deps = []; this.depIds = new Set()</li>
<li>this.newDeps = [];this.newDepIds = new Set()    </li>
</ul>
<h2 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h2><p><img src="https://i.loli.net/2019/07/15/5d2c20df68a3346321.jpg" alt="数据绑定"></p>
<h2 id="view-gt-model"><a href="#view-gt-model" class="headerlink" title="view -&gt; model"></a>view -&gt; model</h2><p>通过 v-model 的方式,如果一个组件有多个 v-model ，你要自己写 v-on 和 data 的修改。</p>
<p>编译时：<br>v-model的相关信息保存在AST树的atrrsList数组和指令directive属性上，生成render函数时，这些属性上的信息通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addProp(el, <span class="string">'value'</span>, <span class="string">`(<span class="subst">$&#123;value&#125;</span>)`</span>)</span><br><span class="line">addHandler(el, event, code, <span class="literal">null</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>方法添加到render的data中，v-model生成的代码作为语法糖，即通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，</p>
<figure class="highlight plain"><figcaption><span>v-model</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt;</span><br><span class="line">&#96;&#96;&#96;&lt;input v-bind:value&#x3D;&quot;message&quot; @input&#x3D;&quot;message&#x3D;$event.target.value&quot;&gt;&#96;&#96;&#96; v-model 的实现，子组件的 value prop 以及派发的 input 事件名是可配的</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">model:&#123;</span><br><span class="line">    prop:&#39;msg&#39;,</span><br><span class="line">    event:&#39;change&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v-model-表单vs组件"><a href="#v-model-表单vs组件" class="headerlink" title="v-model 表单vs组件"></a>v-model 表单vs组件</h2><table>
<thead>
<tr>
<th></th>
<th>表单</th>
<th>组件</th>
</tr>
</thead>
<tbody><tr>
<td>编译prase阶段的AST树</td>
<td>生成directives属性</td>
<td>生成 model属性</td>
</tr>
<tr>
<td>编译codegen阶段的data</td>
<td>props和event</td>
<td>model = {callback: “function ($$v) {message=$$v}”, expression: “message”, value: “(message)”}</td>
</tr>
<tr>
<td>运行阶段</td>
<td>updateDOMListeners-&gt; addEventListener</td>
<td>initEvent -&gt; 将回调函数挂载在vm实例上，并配合$emit实现</td>
</tr>
</tbody></table>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>vdom 的真正意义是为了实现跨平台，服务端渲染，以及提供一个性能还算不错 Dom 更新策略。</p>
<h1 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop？"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop？" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop？"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop？</h1><p>原因很简单，一个父组件下不只有你一个子组件。 同样，使用这份 prop 数据的也不只有你一个子组件。 如果每个子组件都能修改 prop 的话，将会导致修改数据的源头不止一处。</p>
<p>所以我们需要将修改数据的源头统一为父组件，子组件像要改 prop 只能委托父组件帮它。从而保证数据修改源唯一</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initProps()&#123;……</span><br><span class="line">defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果不是root根组件，并且不是更新子组件，那么说明更新的是props</span></span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(……）</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;……&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期顺序？"><a href="#生命周期顺序？" class="headerlink" title="生命周期顺序？"></a>生命周期顺序？</h1><p>加载渲染过程</p>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p>子组件全局状态更新过程</p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p>销毁过程</p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h2 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h2><p>创建-挂载-更新-销毁</p>
<ul>
<li>beforeCreate前，也就是new Vue的时候会初始化事件和生命周期；</li>
<li>beforeCreate和created之间会挂载Data，绑定事件；接下来会根据el挂载页面元素，如果没有设置el则生命周期结束，直到手动挂载；el挂载结束后，根据templete/outerHTML(el)渲染页面；</li>
<li>在beforeMount前虚拟DOM已经创建完成；</li>
<li>之后在mounted前，将vm.$el替换掉页面元素el;mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）；</li>
<li>之后发生数据变化时触发beforeUpdate和updated进行一些操作；</li>
<li>最后主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等；</li>
<li>destroyed时仅存在Dom节点，其他所有东西已自动销毁。</li>
</ul>
<h1 id="Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？"><a href="#Vue-router中-lt-router-link-gt-和-lt-a-href-”…”-gt-的区别？" class="headerlink" title="Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？"></a>Vue-router中&lt;router-link&gt; 和&lt;a href=”…” &gt;的区别？</h1><p>router-link 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 a 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p>
<p>&lt;router-link&gt; 比起写死的&lt;a href=”…” &gt; 会好一些，理由如下：</p>
<p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。<br>在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。<br>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写 (基路径) 了。</p>
<h1 id="v-for有必要添加事件代理吗？"><a href="#v-for有必要添加事件代理吗？" class="headerlink" title="v-for有必要添加事件代理吗？"></a>v-for有必要添加事件代理吗？</h1><p>没必要  </p>
<p>首先我们需要知道事件代理主要有什么作用？    </p>
<ul>
<li><p>事件代理能够避免我们逐个的去给元素新增和删除事件</p>
</li>
<li><p>事件代理比每一个元素都绑定一个事件性能要更好<br>从vue的角度上来看上面两点   </p>
</li>
<li><p>在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了</p>
</li>
<li><p>在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理</p>
</li>
</ul>
<h1 id="vue首屏白屏？"><a href="#vue首屏白屏？" class="headerlink" title="vue首屏白屏？"></a>vue首屏白屏？</h1><p>首页白屏的原因： 单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏</p>
<p>解决办法：</p>
<ul>
<li>优化 webpack 减少模块打包体积，code-split 按需加载</li>
<li>服务端渲染，在服务端事先拼装好首页所需的 html</li>
<li>首页加骨架屏</li>
<li>使用CDN减小代码体积加快请求速度</li>
<li>vue-router 路由懒加载</li>
<li>nginx楷gzip压缩</li>
</ul>
<h1 id="vue-是如何对数组方法进行变异的？"><a href="#vue-是如何对数组方法进行变异的？" class="headerlink" title="vue 是如何对数组方法进行变异的？"></a>vue 是如何对数组方法进行变异的？</h1><p>重写了数组中的那些方法，首先获取到这个数组的<strong>ob</strong>,也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化，然后手动调用notify，通知渲染watcher，执行update</p>
<p>Vue中默认的做法就是在数组实例与它的原型之间，插入了一个新的原型对象，这个原型方法实现了这些变异方法，也就拦截了真正数组原型上的方法（因为原型链的机制，找到了就不会继续往上找了）。 变异方法中增加了自定义逻辑，也调用了真正数组原型上的方法，即实现了目的，也不会对正常使用造成影响。</p>
<h1 id="观察者模式和发布-订阅模式有什么区别？"><a href="#观察者模式和发布-订阅模式有什么区别？" class="headerlink" title="观察者模式和发布-订阅模式有什么区别？"></a>观察者模式和发布-订阅模式有什么区别？</h1><p>观察者模式没中间商赚差价<br>发布订阅模式 有中间商赚差价</p>
<h1 id="github上的问题"><a href="#github上的问题" class="headerlink" title="github上的问题"></a>github上的问题</h1><h2 id="vue组件之间的通信都有哪些？"><a href="#vue组件之间的通信都有哪些？" class="headerlink" title="vue组件之间的通信都有哪些？"></a>vue组件之间的通信都有哪些？</h2><p>父子Coms: </p>
<ul>
<li>props</li>
<li>$emit/$on</li>
<li>( $parents/$children ) / $refs</li>
</ul>
<p>兄弟Coms:</p>
<ul>
<li>Vuex</li>
<li>Bus</li>
</ul>
<p>跨级Coms: </p>
<ul>
<li>( provide/inject )</li>
<li>( $attrs/$listeners )</li>
</ul>
<h1 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h1><p>1、Vue 是怎么知道数据改变？</p>
<ul>
<li>Object.defineProperty对get和set进行拦截</li>
</ul>
<p>2、Vue 在数据改变时，怎么知道通知哪些视图更新？</p>
<ul>
<li>data 中每个声明的属性<strong>ob</strong>，都会有一个Dep实例 专属的依赖收集器 subs</li>
<li>当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中</li>
<li>ObjectdefineProperty - get 依赖收集 dep.depned</li>
</ul>
<p>3、Vue 在数据改变时，视图怎么知道什么时候更新？</p>
<ul>
<li>Object.defineProperty - set</li>
<li>name 会遍历自己的 依赖收集器 subs，逐个通知 watcher</li>
<li>watcher render-&gt;patch 完成更新</li>
</ul>
<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"a"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testb</span> <span class="attr">:child-name</span>=<span class="string">"parentName"</span> &gt;</span><span class="tag">&lt;/<span class="name">testb</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、父组件 怎么传值给 子组件的 props?</p>
<ul>
<li>父组件的模板 会被解析成一个 模板渲染函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  <span class="comment">// 绑定大括号内代码的 变量访问作用域</span></span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">staticClass</span>:<span class="string">"a"</span>&#125;,[</span><br><span class="line">            _c(<span class="string">'testb'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"child-name"</span>:parentName&#125;&#125;)</span><br><span class="line">        ],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>模板函数会被执行，执行时会绑定 父组件为作用域</li>
<li>所以渲染函数内部所有的变量，都会从父组件对象 上去获取<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">attrs</span>: &#123; child-name: parentVm.parentName &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件保存 props</li>
<li>props 会被 保存到 实例的_props 中，并且 会逐一复制到 实例上，并且每一个属性会被设置为响应式的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VueComponent&#123;</span><br><span class="line">  childName:&quot;aaa&quot;,</span><br><span class="line">  _props:&#123;</span><br><span class="line">    childName:&quot;aaa&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2、子组件如何读取props?</li>
<li>复制的时候，会对每个属性，同时设置 get 和 set 函数，进行 访问转接 和 赋值转接<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._props[key]&#125;,    </span><br><span class="line"><span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>._props[key] = val&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问 props 其中一个值 vm.childName，其实访问的是 vm._props.childName</li>
<li>赋值 vm.childName= 5 ，其实是赋值 vm._props.childName= 5</li>
</ul>
<p>因此不会影响到父组件data</p>
<p>3、父组件 data 更新，子组件的props 如何更新</p>
<ul>
<li><p>parentName 会收集 父组件的 watcher</p>
</li>
<li><p>render函数中 _c(‘testb’,{attrs:{“child-name”:parentName}被收集依赖</p>
</li>
<li><p>渲染函数执行，开启新一轮的 props 赋值操作</p>
<p>基础类型的props不影响父组件 data，对象类型的props影响</p>
<h1 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h1><p>1、computed 也是响应式的？</p>
</li>
<li><p>给 computed 设置的 get 和 set 函数，会跟 Object.defineProperty 关联</p>
</li>
<li><p>读取computed 时，会执行你设置的 get 函数，还有一层缓存的操作</p>
</li>
</ul>
<p>2、computed 如何控制缓存？</p>
<ul>
<li>【脏数据标志位 dirty】，computed 通过 watcher.dirty 控制是否读取缓存</li>
<li>当 dirty 为 true 时，读取 computed 会重新计算<ul>
<li>computed 新建自己的watcher时，会设置 watcher.dirty = true</li>
<li>依赖的数据变化了，通知 computed 时，会设置 watcher.dirty = true</li>
</ul>
</li>
<li>当 dirty 为 false 时，读取 computed 会使用缓存<ul>
<li>computed 计算完成之后，会设置 watcher.dirty = false</li>
</ul>
</li>
</ul>
<p>3、依赖的 data 改变了，computed 如何更新？<br>computed 会让 【data依赖】 收集到 【依赖computed的watcher】，从而 data 变化时，会同时通知 computed 和 依赖computed的地方</p>
<ul>
<li>页面A 引用了 computed B，computed B 依赖了 data C</li>
<li>data C 开始变化后<ol>
<li>只会重置computed B的 脏数据标志位 dirty =true，不会计算值</li>
<li>通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算<br><img src="https://segmentfault.com/img/remote/1460000019605781?w=563&h=177" alt=""></li>
</ol>
</li>
</ul>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>1、 methods 怎么使用实例访问？</p>
<ul>
<li>遍历 methods 这个对象，然后逐个复制到 实例上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span>(<span class="params">vm, methods</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">        vm[key] = </span><br><span class="line">            methods[key] == <span class="literal">null</span> ? </span><br><span class="line">            noop : </span><br><span class="line">            bind(methods[key], vm);<span class="comment">// 使用bind固定作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"data"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;name:"matt"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、v-model 怎么给表单绑定数据？</p>
<ul>
<li>v-model 绑定的数据赋值给表单元素的 value 属性</li>
<li>value 是 v-model 解析成的原生属性，保存在属于该节点 input 的 domProps 对象存储器中</li>
<li>绑定值：创建dom input 之后-&gt;  遍历该 input 的 domProps ，逐个添加给 dom input -&gt; 插入dom input<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,[</span><br><span class="line">            _c(<span class="string">'input'</span>,</span><br><span class="line">                domProps:&#123;<span class="string">"value"</span>:name&#125; <span class="comment">// name重vm.name获取</span></span><br><span class="line">            )</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>2、v-model 绑定什么事件？</p>
<ul>
<li>change:select，checkbox，radio</li>
<li>input:默认  text、number 等 input 元素和 textarea</li>
</ul>
<p>3、v-model 怎么绑定事件？</p>
<ul>
<li>解析不同表单元素，配置相应的事件名和事件回调，在插入dom之前，addEventListener 绑定上事件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, [</span><br><span class="line">        _c(<span class="string">'input'</span>, &#123;        </span><br><span class="line">            on: &#123;             <span class="comment">// 用于addEventListener</span></span><br><span class="line">              <span class="string">"input"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">                  name = $event.target.value</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> vnode.data.on) &#123;</span><br><span class="line">        vnode.elm.addEventListener(event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.addEventListener(<span class="string">"input"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;    </span><br><span class="line">    name = $event.target.value </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、v-model 如何进行双向更新？</p>
<ul>
<li>外部变化，触发事件回调，event.target.value 赋值给model绑定的数据；</li>
<li>内部变化<ul>
<li>v-model 绑定了 name ，name 会收集到 本组件的 watcher</li>
<li>内部修改 name 变化，通知收集器内的 watcher 更新 render-&gt; patch</li>
<li>render内name更新 渲染成新的DOM</li>
</ul>
</li>
</ul>
<h1 id="代理Data"><a href="#代理Data" class="headerlink" title="代理Data"></a>代理Data</h1><ul>
<li>proxy(vm,”_data”,key)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">"name"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>]&#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123; <span class="keyword">this</span>[<span class="string">"_data"</span>][<span class="string">"name"</span>] = val;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
好处：</li>
<li>直接通过 vm 访问到data中的name</li>
<li>相比于将data中数据拷贝赋值到vm上，代理的形式减少了数据维护（method是直接赋值的）</li>
<li>不影响依赖更新和收集</li>
</ul>
<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>1、监听的数据改变的时，watch 如何工作？</p>
<ul>
<li>watch 在一开始初始化的时读取监听数值的数据，数据添加到watch的watcher上，</li>
<li>watch设置handler会放在watch的更新函数中 更新时被调用</li>
</ul>
<p>2、设置 immediate 时，watch 如何工作？</p>
<ul>
<li>初始化 watch 时，在读取了 监听的数据的值 之后，便立即调用一遍你设置的监听回调</li>
</ul>
<p>3、设置了 deep 时，watch 如何工作？<br>深度监听对象内部变化</p>
<ul>
<li>(没有设置deep)因为读取了监听的 data 的属性，watch 的 watcher 被收集在 这个属性的 收集器中</li>
<li>(设置了deep)在读取 data 属性的时候，会递归遍历这个值，把内部所有属性逐个读取一遍，于是 属性和 它的对象值内每一个属性 都会收集到 watch 的 watcher</li>
</ul>
<h1 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h1><p>1、Vue.component 注册的 【全局组件】<br>2、Vue.filter 注册的 【全局过滤器】<br>3、Vue.directive 注册的 【全局指令】<br>4、Vue.mixin 注册的 【全局mixin】   </p>
<p>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并起来</p>
<h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>A. 组件选项<br>B. 组件mixin<br>C. 全局mixin<br>权重：选项 &gt; 组件 &gt; 全局  </p>
<p>1、什么时候合并？<br>全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并。</p>
<p>2、怎么合并？</p>
<ul>
<li><p>合并成一个函数 (data，provide)：</p>
<ul>
<li>函数合并成一个函数时，选项 &gt; 组件 &gt; 全局  </li>
<li>data中数据重复的，优先级： 选项 &gt; 组件 &gt; 全局  </li>
</ul>
</li>
<li><p>数组叠加（生命周期函数，watch）：</p>
<ul>
<li>权重越大的越放后面，合并数组</li>
<li>执行时 生命周期，权重小的 先执行<br>[<br>全局 mixin - created/watch，<br>组件 mixin - created/watch，<br>组件 options - created/watch<br>]</li>
</ul>
</li>
<li><p>原型叠加（components，filters，directives）</p>
<ul>
<li>权重小的 被放到 权重大 的 的原型上</li>
<li>这样权重大的，访问快些，因为作用域链短了<ul>
<li>A: 组件选项的component</li>
<li>B: 组件mixin的component</li>
<li>C: 全局mixin的component</li>
</ul>
</li>
<li><code>A.__proto__ = B</code> 和<code>B.__proto__ = C</code>  </li>
</ul>
</li>
<li><p>覆盖叠加(props，methods，computed，inject)</p>
<ul>
<li>两个对象合并，如果有重复key，权重大的覆盖权重小的<ul>
<li>组件的 props 会替换 mixin 的props</li>
<li>组件的 methods 会替换 mixin 的methods</li>
<li>组件的 computed 会替换 mixin 的computed</li>
</ul>
</li>
</ul>
</li>
<li><p>直接替换（el，template，propData）</p>
</li>
</ul>
<h1 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;插入slot中:&#123;&#123;name&#125;&#125;&lt;<span class="regexp">/test&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">data()&#123;<span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">"matt"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test 组件</span></span><br><span class="line">&lt;main&gt;</span><br><span class="line">  我在子组件里</span><br><span class="line">  &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/m</span>ain&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，把 插槽当做 test 的子元素处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span>,        </span><br><span class="line">        children: [<span class="string">'插入slot 中'</span>] <span class="comment">//插槽节点</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [<span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>)]<span class="comment">// slot 第一步解析得到的插槽节点拿到，然后返回</span></span><br><span class="line">    <span class="comment">// children: ['我在子组件里面','插入slot 中']</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、插槽内容怎么解析?插槽如何插子页面?</p>
<ul>
<li>父组件解析<ul>
<li>子组件的插槽解析成<strong>最终节点</strong></li>
<li>保存在子组件占位符节点children中</li>
</ul>
</li>
<li>子组件占位符节点的children转移给子组件选项_renderChildren上</li>
<li>子组件选项 _renderChildren转移给子组件实例$ slot上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件$slot上获取对应的插槽节点并返回，替换占位符   </li>
</ul>
</li>
</ul>
<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><ul>
<li>父组件解析<ul>
<li>子组件的插槽，包装成<strong>函数</strong></li>
<li>保存在子组件占位符节点scopedSlots中</li>
</ul>
</li>
<li>子组件占位符节点的scopedSlots转移给子组件实例上</li>
<li>子组件解析<ul>
<li>slot 占位符变成——t函数</li>
<li>_t执行，从组件scopedSlots上获取对应的插槽函数并执行返回节点，替换占位符   </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">""</span>&gt;</span><br><span class="line">  &lt;test&gt;</span><br><span class="line">    &lt;template slot-scope=<span class="string">"slotProps"</span>&gt;插入插槽中&#123;&#123;slotProps&#125;&#125;&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>test&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件test 组件</span></span><br><span class="line"><span class="regexp">&lt;main&gt;</span></span><br><span class="line"><span class="regexp">  我在子组件里</span></span><br><span class="line"><span class="regexp">  &lt;slot :child="child"&gt;&lt;/</span>slot&gt;</span><br><span class="line">&lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件data</span></span><br><span class="line"><span class="regexp">data()&#123;</span></span><br><span class="line"><span class="regexp">  return &#123;child:11&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>父组件先解析，把 test 当做子元素处理，<strong>把 插槽包装成一个函数，保存给节点</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"div"</span>,    </span><br><span class="line">    children: [&#123;        </span><br><span class="line">        tag: <span class="string">"test"</span></span><br><span class="line">        scopeSlots:&#123;            </span><br><span class="line">            <span class="keyword">default</span>：<span class="function"><span class="keyword">function</span>(<span class="params">slotProps</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'插入slot 中'</span> + slotProps]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>,_t(<span class="string">'default'</span>,&#123;<span class="attr">child</span>:<span class="number">11</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>_t 内部执行:1. 传入的名字（’default’），拿到第一步解析插槽得到的函数 2.执行函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: <span class="string">"main"</span>,    </span><br><span class="line">    children: [</span><br><span class="line">        <span class="string">'我在子组件里面'</span>, <span class="string">'插入slot 中 &#123;child:11&#125;'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="生命周期函数-钩子函数"><a href="#生命周期函数-钩子函数" class="headerlink" title="生命周期函数 钩子函数"></a>生命周期函数 钩子函数</h1><ul>
<li>把所有同类钩子先合并成数组，然后存放在 vm.$options<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$options=&#123;</span><br><span class="line">    created:[fn,fn,fn...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化设置一些标志位，表明是否已经完成某种钩子</li>
<li>callHoock <code>vm.$options[&quot;created&quot;][i].call(vm)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">opt</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>._init(opt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype._init(opt)&#123;</span><br><span class="line">    ... 合并选项</span><br><span class="line">    ... 设置初始值 ，事件 等数据</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>);</span><br><span class="line">    ... 初始化选项等数据</span><br><span class="line">    callHook(vm, <span class="string">'created'</span>);</span><br><span class="line">    ...获取挂载的DOM 父节点</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">    ...解析模板成渲染函数，并执行渲染函数，生成DOM插入页面</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件更新时会调用这个函数</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode, hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...重新调用渲染函数，对比旧节点和新节点，得到最小差异，然后只更新这部分页面</span><br><span class="line">    callHook(vm, <span class="string">'updated'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点被移除时会调用这个函数</span></span><br><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>);</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...实例被消除，移除所有 watcher</span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    ...DOM被移除</span><br><span class="line">    callHook(vm, <span class="string">'destroyed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h1><p>1、vnode 是什么及其作用?</p>
<ul>
<li><p>是什么？<strong>JavaScript 对象</strong></p>
</li>
<li><p>什么用？</p>
<ul>
<li>1、兼容node/浏览器。</li>
<li>2、减少操作 DOM。只需要在最后一步挂载更新DOM<br>2、vnode 什么时候生成? vm._render<br>3、vnode 怎么生成?<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"href"</span>:<span class="string">"xxxx"</span>&#125;&#125;,[<span class="string">"1111"</span>]).</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
vm._c = function(a, b, c, d) {    return createElement(vm, a, b, c, d, false);};</li>
</ul>
</li>
<li><p>如果(tag是正常html标签)<br>new VNode(tag, data, children, undefined:text, undefined:elm, context);</p>
</li>
<li><p>否则（tag是组件）<br>createComponent(Ctor, data, context, children, tag);}</p>
</li>
</ul>
<p>4、vnode 存放什么信息?</p>
<ul>
<li>data(1.节点属性，class，style等 2. 绑定事件 )</li>
<li>elm(真实dom节点)<ul>
<li>elm 会在需要创建DOM 时完成赋值，具体函数在 createElm 中</li>
<li>vnode.elm = document.createElement(tag)</li>
</ul>
</li>
<li>context 如果是页面就是页面实例，如果是组件就是组件实例</li>
<li>isStatic 静态节点 不需要对比和更新</li>
<li>组件相关属性<ul>
<li>parent 组件的占位符节点</li>
<li>componentInstance 组件生成的VueComponent实例</li>
<li>componentOptions 父子组件交流的证据（props 事件 slot）</li>
</ul>
</li>
</ul>
<p>5、vnode 存放在哪里?</p>
<ul>
<li>parent：组件的父节点中的占位符节点</li>
<li>$vnode：_vnode的parent</li>
<li>_vnode:当前节点的vnode，直接映射成当前真实DOM <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...初始化组件选项等</span><br><span class="line">    mountComponent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ....解析模板，生成渲染函数</span><br><span class="line">    <span class="comment">// 用于生成VNode，生成DOM，挂载DOM</span></span><br><span class="line">    updateComponent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render());</span><br><span class="line">    &#125;;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建 watcher，保存updateComponent为更新函数，新建的时候会立即执行一遍</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, expOrFn</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn ;    </span><br><span class="line">    <span class="keyword">this</span>.getter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前面解析得到的渲染函数，返回生成的 VNode</span></span><br><span class="line">Vue.prototype._render = () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据vnode，生成DOM 挂载</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params">vnode</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;    </span><br><span class="line">    <span class="keyword">if</span> (不存在旧节点） &#123; ...使用vnode创建DOM并直接挂载 &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123; ...存在旧节点，开始比对旧节点和新节点，然后创建DOM并挂载 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="从模板到DOM的过程"><a href="#从模板到DOM的过程" class="headerlink" title="从模板到DOM的过程"></a>从模板到DOM的过程</h1><ul>
<li>init<ol>
<li>初始化选项</li>
<li>初始化实例</li>
</ol>
</li>
<li>mount<ol>
<li>解析模板，生成并保存渲染函数</li>
<li>新建watcher并立即执行更新函数vm._update(vm._render)</li>
<li>vm._render调用渲染函数生成Vnode，传给vm._update</li>
<li>vm.<em>update调用vm.<em>_patch</em></em>,根据vnode生成DOM并挂载</li>
</ol>
</li>
</ul>
<h1 id="component创建"><a href="#component创建" class="headerlink" title="component创建"></a>component创建</h1><p>1、页面解析模板得到 VNode 时：创建组件构造函数 + 生成外壳节点保存 父子关联的数据    </p>
<ul>
<li>创建外壳节点的流程：<ol>
<li>页面渲染函数执行   </li>
<li>_c(‘test’) 执行    </li>
<li>createElement 碰到 tag 是一个组件    </li>
<li>从父组件中，拿到 test 组件的options，传入createComponent （作用是创建构造函数和 VNode）    </li>
<li>createComponent 调用 Vue.extend 创建组件构造函数   </li>
<li>新建 VNode，并把构造函数和父组件给子组件的数据保存进去     </li>
<li>返回 VNode</li>
</ol>
</li>
</ul>
<p>2、页面开始挂载 DOM 时：新建建组件实例，解析组件内部模板，生成DOM挂载到父页面</p>
<ul>
<li>挂载DOM的过程<ol>
<li>父页面已经拿到了 VNode，其中会调用 createElm 根据 VNode 生成DOM，进行挂载</li>
<li>不断的递归遍历子节点，使用 createComponent 判断标签是否是组件</li>
<li>遇到组件，拿到组件外壳VNode 的data（data 保存有父组件给子组件的，事件，props，构造函数，钩子）</li>
<li>从 data 中拿到 hook，hook 中拿到 init 钩子，并执行 init 钩子</li>
<li>init 钩子中，调用 createComponentInstanceForVnode 调用组件构造函数，并返回组件</li>
<li>init 钩子中，使用上一步返回的实例，手动调用 vm.$mount 进行组件内部模板解析渲染，并挂载</li>
</ol>
</li>
</ul>
<h1 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h1><ul>
<li><p>自定义事件</p>
<ul>
<li>vm._events存放自定义事件</li>
<li>个人调用：vm.$on就是注册事件，vm.$emit 是 触发事件，vm.$off 就是 解绑事件</li>
<li>组件绑定： <code>&lt;test @test=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code></li>
</ul>
</li>
<li><p>DOM 事件</p>
<ul>
<li>addEventListeners 绑定事件</li>
<li>标签绑定：<code>&lt;div @click=&quot;this.alert(1)&quot;&gt;&lt;/div&gt;</code><ul>
<li>vm._vnode.data.on中存放DOM事件</li>
</ul>
</li>
<li>组件绑定：<code>&lt;test @click.native=&quot;this.alert(1)&quot;&gt;&lt;/test&gt;</code><ul>
<li>vm._vnode.data.nativeOn中存放DOM事件</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么子组件触发事件之后，调用父组件的方法，而父组件的方法上下文对象还是父组件?<br>因为 methods 方法已经使用 bind 绑定啦，上下文对象固定了为父组件实例的</p>
</li>
</ul>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>nextTick就是设置一个回调，用于异步执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.list =[xx,xx,xx]</span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.isLoading=<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>异步执行，比如，就是把你设置的回调放在 setTimeout 中执行，这样就算异步了，等待当时同步代码执行完毕再执行。多个异步回调没有必要使用多个setTimeout。</p>
<p>nextTick：  </p>
<ol>
<li>存在 回调数组 里。每次调用 nextTick，便往数组里面 push 设置的回调</li>
<li>只注册一个 setTimeout，时间为0，用于遍历 回调数组，然后逐个执行子项</li>
<li>同步代码执行完毕，setTimeout 自然会执行</li>
</ol>
<p>Vue 2.5.3～2.6使用宏任务+微任务<br>Vue &lt;2.4和&gt;2.6 只使用微任务 Promise 没有的话兼容到setTimeout</p>
<ul>
<li><strong>nextTick 回调 + 过滤 watcher</strong> 使得Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次<br>多次修改同一个数据的时候，会准备 push进 回调数组 多个 watcher.update，但是只有第一次是push 成功的，其他的会被过滤掉（watcher.id相同），nextTick 的回调数组中只存在唯一一个 watcher.update</li>
</ul>
<h1 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h1><ul>
<li>parse: 接收 template 原始模板，按照模板的节点 和数据 生成对应的 ast</li>
<li>optimize:遍历递归每一个ast节点，标记静态的节点（没有绑定任何动态数据），这样就知道那部分不会变化，于是在页面需要更新时，减少去比对这部分DOM从而性能优化。</li>
<li>generate：<ul>
<li>把前两步生成完善的 ast 组装成 render 字符串</li>
<li>render = new Function(render字符串)</li>
</ul>
</li>
</ul>
<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><ul>
<li>Diff 的作用?<ul>
<li>减少更新量，找到最小差异部分DOM，只更新差异部分DOM</li>
</ul>
</li>
<li>Diff 的做法？<ul>
<li>同层级比较（只有两个新旧节点是相同Vnode节点的时候，才会去比较他们各自的子节点）</li>
<li>避免过渡优化 O(n<sup>3</sup>) -&gt; O(n)</li>
</ul>
</li>
</ul>
<h1 id="Diff-流程"><a href="#Diff-流程" class="headerlink" title="Diff 流程"></a>Diff 流程</h1><p>  在同层新旧Vnode节点中</p>
<p>1、先找到 不需要移动的相同节点，消耗最小</p>
<ul>
<li>两头 新旧的头指针 后移 一位</li>
<li>两尾 新旧的尾指针 前移 一位</li>
</ul>
<p>2、再找相同但是需要移动的节点，消耗第二小</p>
<ul>
<li>老头新尾 <strong>将old start 移动到old end的后面</strong>，old start +1 ，new end -1</li>
<li>老尾新头 <strong>将old end 移动到old start的前面</strong>，old end -1 ， new start +1  </li>
<li>都不匹配 在旧的vnode数组中查找 newStartVnode 的下标，没有key的话要比较tag<ul>
<li>相同则 patchVnode并移动到oldStart前</li>
<li>不相同 新建DOM节点oldStart前   </li>
</ul>
</li>
</ul>
<p>3、最后找不到，才会去新建删除节点，保底处理  </p>
<ul>
<li>旧Vnode 树 和 新Vnode树 进行比较的过程中<br>,不会对这两棵Vode树进行修改，而是以比较的结果直接对 真实DOM 进行修改</li>
</ul>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-前端性能优化" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
    >前端性能优化</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h2 id="请求速度"><a href="#请求速度" class="headerlink" title="请求速度"></a>请求速度</h2><h2 id="缓存-路径选择"><a href="#缓存-路径选择" class="headerlink" title="缓存 路径选择"></a>缓存 路径选择</h2><h2 id="http请求大小-减少http请求"><a href="#http请求大小-减少http请求" class="headerlink" title="http请求大小 减少http请求"></a>http请求大小 减少http请求</h2><h2 id="首屏-vue服务端渲染"><a href="#首屏-vue服务端渲染" class="headerlink" title="首屏 vue服务端渲染"></a>首屏 vue服务端渲染</h2><h2 id="减少请求数量"><a href="#减少请求数量" class="headerlink" title="减少请求数量"></a>减少请求数量</h2><h2 id="减少请求大小"><a href="#减少请求大小" class="headerlink" title="减少请求大小"></a>减少请求大小</h2><h3 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h3><p>不显示空格、制表符、换行符，以及压缩注释</p>
<h3 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h3><ul>
<li>去掉回车和空格</li>
<li>无效代码删除</li>
<li>css语义合并</li>
</ul>
<h3 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h3><ul>
<li>无效字符的删除，注释回车空格</li>
<li>代码语义的缩减和优化 </li>
<li>代码混乱降低代码可读性，代码保护，防止内部逻辑泄露</li>
</ul>
<h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><p>虽然使用keep-alive保证长连接，但依旧是串行的请求，多次发送请求来获得不同的资源</p>
<p>文件合并，只需发起一次请求</p>
<p>存在问题：</p>
<ul>
<li><p>首屏渲染等待合并后的js文件加载完后才会进行渲染，首屏渲染时间增加</p>
</li>
<li><p>缓存失效，更改一小部分js代码，就需要重新下载新的合并的js文件</p>
</li>
<li><p>公共库合并，公共库代码改动较少，业务代码打包成一个文件</p>
</li>
<li><p>不同页面的js文件单独打包</p>
</li>
</ul>
<h2 id="图片相关优化"><a href="#图片相关优化" class="headerlink" title="图片相关优化"></a>图片相关优化</h2><ul>
<li>雪碧图，将多张图片合并到一张单独的图片，来减少http请求数量</li>
<li>image inline，使用base64格式保存在html页面中，减少http请求</li>
<li>使用矢量图 svg</li>
</ul>
<h2 id="css-js-加载"><a href="#css-js-加载" class="headerlink" title="css js 加载"></a>css js 加载</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><ul>
<li>顺序执行，并发加载，但是同一个域名下并发加载的数量有限</li>
<li>css header中阻塞页面的渲染，而@import所引用的 css 会等到<strong>页面加载完</strong>才被加载</li>
<li>css 阻塞js执行，不阻塞js的加载<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"****.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> <span class="string">"***.css"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><ul>
<li>直接引入的js的会阻塞页面的渲染（同步加载），（defer async异步加载）</li>
<li>js的执行不会阻塞资源的加载</li>
<li>js顺序执行，会阻塞之后的js执行</li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>较少无效的资源加载，由于同一个域名下资源的请求数量有限，防止图片的加载阻塞js文件的加载</p>
<ol>
<li>设置 data-src = url;</li>
<li>当图片进入可视区域，将 src设置为 data-src</li>
</ol>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>图片等静态资源在使用之前提前请求，当需要使用该资源时直接从缓存中加载</p>
<ul>
<li>设置 display:none</li>
<li>使用Image对象 <code>var image = new Image(); imgahe.src=url</code></li>
<li>XMLHttpRequest 请求图片,但会有跨域问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLhttpRequest()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="减少-重绘-回流"><a href="#减少-重绘-回流" class="headerlink" title="减少 重绘 回流"></a>减少 重绘 回流</h2><p>ui的渲染线程会冻结 js线程的执行</p>
<ul>
<li>将会触发回流的样式，使用不触发回流的方式实现</li>
<li>将频繁重绘回流的dom元素作为一个单独的图层，那么他的重绘回流只会影响当前图层。（少用，图层的合并计算量非常大）<ul>
<li>创建图层的条件： perspective transform video webgl canvas 动画 </li>
</ul>
</li>
<li></li>
</ul>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>域名下的所有请求都会带上cookie，造成流量的浪费， </p>
<p>解决：cdn域名和主站域名要分开，在请求静态文件时不携带cookie</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>进行本地缓存，（js方法，css，icon图片，浏览器能力检测结果）提升首屏渲染速度，以及函数调用的速度</p>
<p>setItem getItem</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>不小心将页面刷新，也能将信息从sessionStorage中读取</p>
<h3 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h3><p>存储客户端大量的结构化数据</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><p>减少前端的计算</p>
<h3 id="vue-ssr"><a href="#vue-ssr" class="headerlink" title="vue-ssr"></a>vue-ssr</h3><p>服务端渲染</p>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<h2 id="首次加载白屏时间"><a href="#首次加载白屏时间" class="headerlink" title="首次加载白屏时间"></a>首次加载白屏时间</h2><p>可以通过 perpormance 来获取相关信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> timing = performance.timing,</span><br><span class="line">    start = timing.navigationStart,</span><br><span class="line">    dnsTime = <span class="number">0</span>,</span><br><span class="line">    tcpTime = <span class="number">0</span>,</span><br><span class="line">    firstPaintTime = <span class="number">0</span>,</span><br><span class="line">    domRenderTime = <span class="number">0</span>,</span><br><span class="line">    loadTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dnsTime = timing.domainLookupEnd - timing.domainLookupStart; <span class="comment">//DNS解析时间</span></span><br><span class="line">tcpTime = timing.connectEnd - timing.connectStart; <span class="comment">//TCP建立时间</span></span><br><span class="line">firstPaintTime = timing.responseStart - start; <span class="comment">//首屏时间</span></span><br><span class="line">domRenderTime = timing.domContentLoadedEventEnd - start; <span class="comment">//dom渲染完成时间</span></span><br><span class="line">loadTime = timing.loadEventEnd - start; <span class="comment">//页面onload时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'DNS解析时间:'</span>, dnsTime, </span><br><span class="line">            <span class="string">'\nTCP建立时间:'</span>, tcpTime, </span><br><span class="line">            <span class="string">'\n首屏时间:'</span>, firstPaintTime,</span><br><span class="line">            <span class="string">'\ndom渲染完成时间:'</span>, domRenderTime, </span><br><span class="line">            <span class="string">'\n页面onload时间:'</span>, loadTime);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>减少网络请求数量和请求大小，以及传输数据的大小</p>
<ul>
<li>合并文件，文件的压缩（去除空格、注释、换行符），图片（雪碧图，image inline，base64）头部压缩</li>
<li>cdn 域名和服务器域名区分开，提高并行的请求数量，也可以减少不必要的cookie</li>
<li>缓存 DNS 结果</li>
<li>缓存一些静态资源，如icon、js通用方法到localStorage</li>
</ul>
</li>
<li><p>将javascript脚本放在底部，js的执行会阻塞页面的渲染</p>
<ul>
<li>html顺序解析执行，加载是并发的</li>
<li>css 在head中通过 link方法引入，css加载会阻塞页面的渲染</li>
<li>css 加载 阻塞 js的执行，不阻塞加载</li>
<li>直接引入的js加载会阻塞 页面渲染  （defer async）</li>
<li>js顺序执行，阻塞后续js的执行</li>
</ul>
</li>
<li><p>将CSS样式表放在顶部，因为页面的渲染需要css的加载完毕，非则会出现白屏，所以使用 <code>&lt;link&gt;</code> 来代替 @import</p>
</li>
<li><p>懒加载 预加载</p>
</li>
<li><p>减少重绘回流</p>
<ul>
<li>css <ul>
<li>尽量使用不触发回流的方式来实现样式</li>
<li>尽量修改dom树末端的dom样式</li>
<li>复杂的动画，让其脱离文档流</li>
</ul>
</li>
<li>js<ul>
<li>对于获取布局信息，尽量保存在变量中</li>
<li>一次性修改样式 display：none 脱离文档流 （现代浏览器已优化）className</li>
<li>使用 GPU 加速，transition：transform opacity</li>
</ul>
</li>
</ul>
</li>
</ul>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-同步与异步" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/22/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"
    >同步与异步</a
  >
</h2>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2018/12/22/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2018-12-21T16:15:28.000Z" itemprop="datePublished">2018-12-22</time>
</a>
              
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/">前端理论</a>
  </div>

                
                  
                    
          </div>
          

            

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h1><ul>
<li>同步 <ul>
<li>如果在函数返回的时候，调用者就能够得到预期结果</li>
<li>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</li>
</ul>
</li>
<li>异步<ul>
<li>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li>
<li>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</li>
</ul>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>new Promise直接执行，返回Promise对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这一段是 同步执行函数（resolve()和reject()是异步的）</span></span><br><span class="line">    <span class="keyword">if</span>(successed)</span><br><span class="line">    &#123;</span><br><span class="line">        resolve(value); <span class="comment">//成功返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);  <span class="comment">//失败返回错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">// resolve回调函数</span></span><br><span class="line">    consoe.log(then)</span><br><span class="line">&#125;,</span><br><span class="line">(error)=&gt;&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
例如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">//2.(tick1)主代码-同步执行函数</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">//3.(tick1)主代码-同步执行函数</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>)     <span class="comment">//5.(tick1)promise回调-微任务</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;          <span class="comment">//6.(tick2)-宏任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">//4.(tick1)主代码-宏任务</span></span><br></pre></td></tr></table></figure>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>) <span class="comment">//2.(tick1)主代码-async1</span></span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)   <span class="comment">//7.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)       <span class="comment">//3.(tick1)主代码-async2 返回Promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)     <span class="comment">//1.(tick1)主代码-宏任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)   <span class="comment">//9.(tick2)setTimeout -第二轮宏任务</span></span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     <span class="comment">// 4.(tick1)主代码</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) <span class="comment">// 5.(tick1)主代码</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) <span class="comment">// 8.(tick1)promise回调 -微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)       <span class="comment">// 6.(tick1)主代码</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)     </span><br><span class="line">        resolve()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1 end'</span>) </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise then'</span>) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="keyword">await</span> async2();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="comment">// 第三轮 9</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="comment">// 第二轮 7</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">	&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             <span class="comment">// 第二轮 6</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout3'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);        <span class="comment">// 3</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);        <span class="comment">// 5 第一轮微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);          <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>


                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%90%86%E8%AE%BA/" rel="tag">前端理论</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>


          <div class="to_top">
            <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
          </div>
      </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Matt&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/resume">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9001/" target="_blank" rel="noopener">项目展示</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
        
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['https://github.com/chiangming/','sa517144@mail.ustc.edu.cn',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
    </div>
  </body>

  </html>