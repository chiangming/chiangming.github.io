<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    interview/面试 |  Matt&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

</html>

  <body>
    <div id="app">
      <main class="content">
        <section class="outer">
  <article id="post-interview/面试" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  interview/面试
</h1>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2020/02/24/interview/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-02-24T00:04:11.241Z" itemprop="datePublished">2020-02-24</time>
</a>
              
                
                  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15分钟</span>
        </span>
    </span>
</div>

                    
          </div>
          

            
              
    <div class="tocbot"></div>





                

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h1 id="JS获取当年当月最后一天日期"><a href="#JS获取当年当月最后一天日期" class="headerlink" title="JS获取当年当月最后一天日期"></a>JS获取当年当月最后一天日期</h1><p>var new_date = new Date(new_year,new_month,1); //取当年次月中的第一天<br>return (new Date(new_date.getTime()-1000<em>60</em>60*24)).getDate();//获取当月最后一天日期 </p>
<h1 id="为什么js里需要闭包"><a href="#为什么js里需要闭包" class="headerlink" title="为什么js里需要闭包"></a>为什么js里需要闭包</h1><ul>
<li>js也采用词法作用域是在函数定义时决定的，而不是函数调用时决定的。</li>
<li>C语言这种底层编程语言中，函数中的非静态变量是储存在CPU栈中的，当函数调用结束后堆栈中的空间也由编译器自动释放。</li>
<li>js闭包函数中的该函数被定义时所有外层的变量对象的引用被放在其上下文Scope属性作为一个作用域链包含，</li>
<li>所以定义了闭包的函数虽然销毁了，但是其变量对象依然被绑定在函数inner上，保留在内存中。不被GC</li>
</ul>
<h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP:"></a>TIP:</h2><ul>
<li>变量对象与活动对象的概念是ES3提出的老概念，从ES5开始就用词法环境和变量环境替代了</li>
<li>变量环境也是词法环境，它具备词法环境所有属性，一样有环境记录EnvironmentRecord（VO）与outer外部环境引入（作用域链）。</li>
<li>作用域链是处理标识符时进行变量查询的变量对象列表</li>
<li>在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值(变量提升)，var声明被设置为了undefined，函数被设置为了自身函数，而let  const被设置为未初始化（暂时性死区）</li>
<li>变量对象是与执行上下文相关的数据作用域</li>
<li>在函数上下文中，我们用活动对象来表示变量对象 对应于 词法记录</li>
</ul>
<h1 id="js解析引擎解析"><a href="#js解析引擎解析" class="headerlink" title="js解析引擎解析"></a>js解析引擎解析</h1><ul>
<li>js是脚本语言，浏览器解析js过程分为：语法检查阶段和运行阶段。</li>
<li>语法检查：<ul>
<li>字符流 - 记号流 - AST抽象语法树</li>
</ul>
</li>
<li>运行阶段：<ul>
<li>预解析： <ul>
<li>创建执行上下文 <ul>
<li>确定this</li>
<li>创建词法环境（存储函数声明与let const声明的变量）</li>
<li>创建变量环境 (存储var声明的变量)</li>
</ul>
</li>
<li>对VO/AO预赋值 （函数的形参 &gt; 函数声明 &gt; 变量声明）</li>
</ul>
</li>
<li>执行代码<ul>
<li>VO/AO重新赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="fetch跨域-cookie"><a href="#fetch跨域-cookie" class="headerlink" title="fetch跨域 cookie"></a>fetch跨域 cookie</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">              method: <span class="string">'GET'</span>,</span><br><span class="line">              headers: myHeaders,</span><br><span class="line">              credentials: <span class="string">"include"</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<p>在后台添加。允许浏览器<br><code>response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);</code><br><code>response.setHeader(‘Access-Control-Allow-Origin’, ‘http://localhost:8080’)//不能为*</code></p>
<h1 id="express-中间件"><a href="#express-中间件" class="headerlink" title="express 中间件"></a>express 中间件</h1><p>Express框架建立在node.js内置的http模块上。<br>Express框架的核心是对http模块的再包装。<br>Express框架等于在http模块之上，加了一个中间层。<br>应用层中间件、路由中间件、内置中间件、错误处理中间件和第三方中间件</p>
<h2 id="应用层中间件"><a href="#应用层中间件" class="headerlink" title="应用层中间件"></a>应用层中间件</h2><p>app.use（[path]，function）<br>path：是路由的url，默认参数‘/‘，意义是路由到这个路径时使用这个中间件<br>function：中间件函数<br>这个中间件函数可以理解为就是function(request,response,next)</p>
<h2 id="内置中间件express-static"><a href="#内置中间件express-static" class="headerlink" title="内置中间件express.static"></a>内置中间件express.static</h2><p>express.static(__dirname + ‘/public’) // express.static 是Express目前唯一内置的一个中间件。用来处理静态资源文件。</p>
<h2 id="路由中间件-express-Router"><a href="#路由中间件-express-Router" class="headerlink" title="路由中间件 express.Router();"></a>路由中间件 express.Router();</h2><h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><p>post请求，enctype属性一般设置为“application/x-www-form-urlencoded”，用于key1=val1&amp;key2=val2 的方式进行编码<br>如果设置成multipart/form-data，则多用于文件上传<br>如果设置成application/json,用于json序列化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser=<span class="built_in">require</span>(<span class="string">"body-parser"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 解析以 application/json 和 application/x-www-form-urlencoded 提交的数据</span></span><br><span class="line"><span class="keyword">var</span> jsonParser = bodyParser.json();</span><br><span class="line"><span class="keyword">var</span> urlencodedParser = bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="动态路由-req-params"><a href="#动态路由-req-params" class="headerlink" title="动态路由 req.params"></a>动态路由 req.params</h3><h3 id="get传参-req-query-参数名"><a href="#get传参-req-query-参数名" class="headerlink" title="get传参 req.query.参数名"></a>get传参 req.query.参数名</h3><h2 id="cookie-parser"><a href="#cookie-parser" class="headerlink" title="cookie-parser"></a>cookie-parser</h2><p>const cookieParser=require(“cookie-parser”);</p>
<p>app.use(cookieParser());</p>
<p>res.cookie(“name”,’zhangsan’,{maxAge: 900000, httpOnly: true});<br>//res.cookie(名称,值,{配置信息})</p>
<h3 id="cookie加密-crypto"><a href="#cookie加密-crypto" class="headerlink" title="cookie加密 crypto"></a>cookie加密 crypto</h3><h2 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h2><h1 id="什么是事件委托吗？"><a href="#什么是事件委托吗？" class="headerlink" title="什么是事件委托吗？"></a>什么是事件委托吗？</h1><p>利用事件冒泡机制，给所有的li绑定点击事件，极为繁琐，这时候需要用到事件代理给ul绑定事件<br>element.addEventListener(event, function, useCapture)；<br>attachEvent()     //IE8及IE更早版本</p>
<ol>
<li>大量减少内存占用，减少事件注册。</li>
<li>新增元素实现动态绑定事件</li>
</ol>
<h2 id="2-对Promise了解吗？"><a href="#2-对Promise了解吗？" class="headerlink" title="2.对Promise了解吗？"></a>2.对Promise了解吗？</h2><p>promise构造函数是同步执行的，then方法是异步执行的，微任务</p>
<h2 id="3-window的onload事件和domcontentloaded谁先谁后？"><a href="#3-window的onload事件和domcontentloaded谁先谁后？" class="headerlink" title="3.window的onload事件和domcontentloaded谁先谁后？"></a>3.window的onload事件和domcontentloaded谁先谁后？</h2><ol>
<li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</li>
<li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</li>
</ol>
<h3 id="url展示的过程"><a href="#url展示的过程" class="headerlink" title="url展示的过程"></a>url展示的过程</h3><ul>
<li>DNS 解析 域名 -&gt; ip （DNS缓存 浏览器/操作系统/hosts文件 -》本地配置的首选DNS服务器 -》运营商的DNS代我们的浏览器发起迭代DNS解析请求 -》com IP -》test.com IP -&gt; <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> IP</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
<li>css是由单独的下载线程异步下载的 </li>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建） </li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）  </li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面</li>
</ul>
</li>
</ul>
<h1 id="vue的渲染过程"><a href="#vue的渲染过程" class="headerlink" title="vue的渲染过程"></a>vue的渲染过程</h1><p>把模板编译为render函数<br>实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom<br>对比虚拟dom，渲染到真实dom<br>组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3    </p>
<h1 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h1><p>（1）默认指向定义它时，所处上下文的对象的this指向。即ES6箭头函数里this的指向就是 <strong>上下文里对象this指向</strong>，偶尔没有上下文对象，this就指向window<br>（2）即使是call，apply，bind等方法也不能改变箭头函数this的指向</p>
<h1 id="for-in和-for-of"><a href="#for-in和-for-of" class="headerlink" title="for in和 for of"></a>for in和 for of</h1><p>for in会遍历数组所有的可枚举属性，包括原型。<br>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>
<p>for in来遍历对象的键名/索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">　　<span class="keyword">if</span>（myObject.hasOwnProperty(key))&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(key);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性</p>
<p>for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br></pre></td></tr></table></figure>

<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，<br>函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<h1 id="浏览器下事件循环-Event-Loop"><a href="#浏览器下事件循环-Event-Loop" class="headerlink" title="浏览器下事件循环(Event Loop)"></a>浏览器下事件循环(Event Loop)</h1><p>主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue （在执行微任务的时候，如果又有微任务进入队列，则在此次循环中执行）</li>
<li>更新 render （视图更新）</li>
<li>主线程重复执行上述步骤<br>上述为一轮事件循环</li>
</ul>
<p><img src="http://103.14.34.148:9000/imgs/blog/img/browser-deom1-excute-animate.gif" alt=""></p>
<h1 id="Http请求中的keep-alive"><a href="#Http请求中的keep-alive" class="headerlink" title="Http请求中的keep-alive"></a>Http请求中的keep-alive</h1><p>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。</p>
<h1 id="1-从输入URL到页面加载发生了什么？url展示"><a href="#1-从输入URL到页面加载发生了什么？url展示" class="headerlink" title="1. 从输入URL到页面加载发生了什么？url展示"></a>1. 从输入URL到页面加载发生了什么？url展示</h1><p>1、浏览器的地址栏输入URL并按下回车。<br>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。<br>3、DNS解析URL对应的IP。<br>4、根据IP建立TCP连接（三次握手）。<br>5、HTTP发起请求。<br>6、服务器处理请求，浏览器接收HTTP响应。<br>7、渲染页面，构建DOM树。<br>8、关闭TCP连接（四次挥手）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/22/167d5e19c54ae53e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h1 id="2-缓存相关的知识吧？"><a href="#2-缓存相关的知识吧？" class="headerlink" title="2. 缓存相关的知识吧？"></a>2. 缓存相关的知识吧？</h1><p>浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存（协商缓存）。<br>两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。</p>
<p>强制缓存判断HTTP首部字段：cache-control，Expires。</p>
<p>Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。</p>
<p>cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。</p>
<p>协商缓存通过HTTP的last-modified，Etag字段进行判断。</p>
<p>last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。</p>
<p>如果需要浏览器强缓存，我们可以这样设置：<br>res.setHeader(‘Cache-Control’, ‘public, max-age=xxx’);<br>复制代码如果需要协商缓存，则可以这样设置：<br>res.setHeader(‘Cache-Control’, ‘public, max-age=0’);<br>res.setHeader(‘Last-Modified’, xxx);<br>res.setHeader(‘ETag’, xxx);</p>
<h1 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手 四次挥手"></a>TCP 三次握手 四次挥手</h1><p><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li>1xx: 接受，继续处理</li>
<li><strong>200: 成功，并返回数据</strong></li>
<li>201: 已创建</li>
<li>202: 已接受</li>
<li>203: 成为，但未授权</li>
<li><strong>204: 成功，无内容</strong></li>
<li>205: 成功，重置内容</li>
<li>206: 成功，部分内容</li>
<li>301: 永久移动，重定向</li>
<li>302: 临时移动，可使用原有URI</li>
<li><strong>304: 资源未修改，可使用缓存</strong></li>
<li><strong>305: 需代理访问</strong></li>
<li>400: 请求语法错误</li>
<li>401: 要求身份认证</li>
<li><strong>403: 拒绝请求</strong></li>
<li><strong>404: 资源不存在</strong></li>
<li><strong>500: 服务器错误</strong><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h3></li>
</ul>
<ol>
<li>GET把参数包含在URL中，而POST将数据放在BODY中。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。</li>
<li>GET 会被历史保存记录，POST中的参数不会被保留</li>
<li>GET只能进行url编码，POST支持更多编码类型（请求头中的Content-Type属性表示编码方式）</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET能被缓存，而POST不能</li>
<li>GET是幂等(请求次数与资源无关)的。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。<br>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li>
</ol>
<ul>
<li>get: <ul>
<li>缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，</li>
<li>发送一个TCP请求 </li>
<li>幂等</li>
</ul>
</li>
<li>post: 安全、大数据、更多编码类型 发送两个TCP请求 </li>
<li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</li>
</ul>
<h1 id="X时Y分时的两针位置"><a href="#X时Y分时的两针位置" class="headerlink" title="X时Y分时的两针位置"></a>X时Y分时的两针位置</h1><p>θ=|6Y-(30X+0.5Y)|=|5.5Y-30X|,单位是度（°）；</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">    left = arr.slice(<span class="number">0</span>,index); <span class="comment">//得到下标从0~index-1的数组</span></span><br><span class="line">    right = arr.slice(index);  <span class="comment">//得到下标从index开始到末尾的数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left) , mergeSort(right));  里面采用递归</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left , right</span>) </span>&#123;   <span class="comment">//该函数与快排类似，但是仔细发现，每次left或者right都是要shift掉第一个元素，表示left或者right是会变化的，最后arr.concat，因为不知道left或者right其中一个哪个剩下元素，所以要将剩下的元素给加上</span></span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span>(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      arr.push(left.shift());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.concat(left , right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="js的bind、apply、call有什么区别"><a href="#js的bind、apply、call有什么区别" class="headerlink" title="js的bind、apply、call有什么区别"></a>js的bind、apply、call有什么区别</h1><ul>
<li>fn.call(obj,…args)转换成obj.fn(…args)</li>
<li>fn.call(obj,args) 转换成obj.fn(args)</li>
<li>return function F(){ return new fn() 或者return fn.apply(obj,args.concat(…arguments))}<a id="more"></a>
<h1 id="js的继承"><a href="#js的继承" class="headerlink" title="js的继承"></a>js的继承</h1></li>
<li>借用构造函数</li>
<li>原型链式继承</li>
<li>组合继承</li>
<li>组合寄生式继承</li>
</ul>
<h1 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h1><p>一，var定义的变量，作用域是整个封闭函数，是全域的；let定义的变量，作用域是在块级或者字块中；<br>二，变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。<br>      而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）；<br>三，只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；<br>四，let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）。<br>const用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是const声明的常量不可改变，声明时必须初始化（赋值）</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>没有this，arguments，没有prototype</p>
<h1 id="promise的then的第二个参数和catch的区别"><a href="#promise的then的第二个参数和catch的区别" class="headerlink" title="promise的then的第二个参数和catch的区别"></a>promise的then的第二个参数和catch的区别</h1><p>catch = then(null,rejected)</p>
<h1 id="手写一个promise怎么写"><a href="#手写一个promise怎么写" class="headerlink" title="手写一个promise怎么写"></a>手写一个promise怎么写</h1><p>value:null<br>成功stack：[]<br>失败stack：[]<br>this.then()=&gt;{两个栈push}<br>function resolve(value) =&gt; {成功栈遍历回调}<br>function reject(value) =&gt; {失败栈遍历回调}<br>fn(resovle,reject)</p>
<h1 id="Promise-all应用场景"><a href="#Promise-all应用场景" class="headerlink" title="Promise.all应用场景"></a>Promise.all应用场景</h1><p>返回new Promise(){}<br>遍历传入的Promise数组<br>Promise.resolve(promises[i])<br>.then(function(value) {<br>        countNum++;<br>        resolvedvalue[i] = value;<br>        if (countNum === promiseNum) {<br>          return resolve(resolvedvalue)<br>        }<br>      }, function(reason) {<br>        return reject(reason)<br>      })</p>
<h1 id="Promise-race应用场景"><a href="#Promise-race应用场景" class="headerlink" title="Promise.race应用场景"></a>Promise.race应用场景</h1><p>指定时间内没有获得结果，就将Promise的状态变为reject<br>Promise.race([<br>  fetch(‘/resource-that-may-take-a-while’),<br>  new Promise(function (resolve, reject) {<br>    setTimeout(() =&gt; reject(new Error(‘request timeout’)), 5000)<br>  })<br>]);</p>
<h1 id="promise和async-await的区别"><a href="#promise和async-await的区别" class="headerlink" title="promise和async/await的区别"></a>promise和async/await的区别</h1><p>async/await 在generater函数的基础上实现的状态机异步调用，执行到await的函数的时候暂时让出线程至函数调用完成</p>
<ul>
<li>把*换成了async，把yield换成了await</li>
<li>一个函数如果加上 async ，那么该函数就会返回一个 Promise<ul>
<li>async 就是将函数返回值使用 Promise.resolve()包裹</li>
</ul>
</li>
<li>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</li>
<li>没有依赖性的话，完全可以使用 Promise.all 的方式</li>
</ul>
<h1 id="状态码304"><a href="#状态码304" class="headerlink" title="状态码304"></a>状态码304</h1>
                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://chiangming.github.io/2020/02/24/interview/%E9%9D%A2%E8%AF%95/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/02/25/%E9%98%AE%E4%B8%80%E5%B3%B0/400/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            阮一峰/400
          
        </div>
      </a>
    
    
      <a href="/2020/02/23/interview/vue/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Vue题目</div>
      </a>
    
  </nav>


  

  

  
  
  

</article>
</section>

          <div class="to_top">
            <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
          </div>
      </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Matt&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/resume">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9001/" target="_blank" rel="noopener">项目1</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9003/" target="_blank" rel="noopener">项目2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
        
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['https://github.com/chiangming/','sa517144@mail.ustc.edu.cn',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
    </div>
  </body>

  </html>