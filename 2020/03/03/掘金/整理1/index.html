<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    掘金/整理1 |  Matt&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Matt's Blog" type="application/atom+xml">
</head>

</html>

  <body>
    <div id="app">
      <main class="content">
        <section class="outer">
  <article id="post-掘金/整理1" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
         
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  掘金/整理1
</h1>
  

      </header>
      

        
          <div class="article-meta">
            <a href="/2020/03/03/%E6%8E%98%E9%87%91/%E6%95%B4%E7%90%861/" class="article-date">
  <time datetime="2020-03-03T01:32:50.155Z" itemprop="datePublished">2020-03-03</time>
</a>
              
                
                  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">32分钟</span>
        </span>
    </span>
</div>

                    
          </div>
          

            
              
    <div class="tocbot"></div>





                

                  <div class="article-entry" itemprop="articleBody">
                    


                      

                        
                                  <h1 id="JS-基础知识点"><a href="#JS-基础知识点" class="headerlink" title="JS 基础知识点"></a>JS 基础知识点</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul>
<li><p>原始类型有哪几种？</p>
<ul>
<li>boolean null  undefined number  string  symbol bigint</li>
<li>undefined.toString() -&gt; TypeError<ul>
<li>原始类型存储的都是值，是没有函数可以调用</li>
</ul>
</li>
<li>‘1’.toString() -&gt; ‘1’<ul>
<li>强制类型转换</li>
</ul>
</li>
</ul>
</li>
<li><p>number是浮点类型的</p>
<ul>
<li>0.1 + 0.2 !== 0.3</li>
<li>使用 Math.abs(a-b) &lt; Number.EPSILON</li>
</ul>
</li>
<li><p>null 是对象嘛？</p>
<ul>
<li>不是 typeof null -&gt; object</li>
<li>js 32位系统000 开头代表是对象，然而 null 表示为全零<a id="more"></a>
<h2 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h2></li>
</ul>
</li>
<li><p>typeof 是否能正确判断类型？</p>
<ul>
<li>原始类型(除了 null) 正确</li>
<li>typeof [] // ‘object’</li>
<li>typeof {} // ‘object’</li>
<li>typeof console.log // ‘function’</li>
</ul>
</li>
<li><p>instanceof 能正确判断对象的原理是什么？</p>
<ul>
<li>原型链</li>
<li>instanceof 可以被[Symbol.hasInstance]改写不可靠</li>
</ul>
</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><p>转Boolean</p>
<ul>
<li>false： undefined， null， false， NaN， ‘’， 0， -0</li>
<li>true:其他(包括对象类型)</li>
</ul>
</li>
<li><p>对象转原始</p>
<ul>
<li>调用优先级：[Symbol.toPrimitive] &gt; valueOf(非字符串) &gt; toString</li>
</ul>
</li>
<li><p>‘+’运算</p>
<ul>
<li>遇字符串转字符串</li>
<li>否则转为数字或者字符串 <ul>
<li>4 + [1,2,3] // “41,2,3”</li>
<li>‘a’ + + ‘b’ // -&gt; “aNaN”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>new &gt; bind &gt; 对象调用 &gt; 直接调用</li>
</ul>
<h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><ul>
<li><p>== 比较值</p>
<ul>
<li>null == undefine</li>
<li>string/boolean 转number再比较<ul>
<li>1 == ‘1’     </li>
<li>‘1’ == true  </li>
</ul>
</li>
<li>对象转为基本类型再比较<ul>
<li>[] == ![] // true  <ul>
<li><code>![]</code>:boolean类型 false 转number 类型 0</li>
<li><code>[]</code>:对象类型 转string类型”” 转number类型 0 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>=== 比较值和类型</p>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>函数+词法环境</li>
<li>函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul>
<li>Object.assign({},source)</li>
<li>{ …source }</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>JSON.parse(JSON.stringify(object))<ul>
<li>函数、 undefined 或者 symbol出错</li>
<li>循环引用的对象出错</li>
</ul>
</li>
<li>lodash库</li>
<li>自定义实现：<ul>
<li><code>let isObject = o =&gt; {
return (typeof o === &#39;object&#39; || typeof o === &#39;function&#39;) &amp;&amp; o !== null
}</code>  </li>
<li><code>let isArray = Array.isArray(obj)</code></li>
</ul>
</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li>原型：共享的属性和方法</li>
<li>Object 是所有对象(包括函数)的爸爸，所有对象都可以通过 <strong>proto</strong> 找到它</li>
<li>Function 是所有函数的爸爸，所有函数都可以通过 <strong>proto</strong> 找到它<ul>
<li>Function.prototype.<strong>proto</strong> === Object.prototype</li>
<li></li>
</ul>
</li>
<li>Cat.prototype.<strong>isPrototypeOf</strong>(cat1):判断原型对象与实例关系</li>
<li>cat1.<strong>hasOwnProperty</strong>(“name”)：判断某一个属性到底是本地属性，还是继承自prototype对象的属性</li>
<li>“type” <strong>in</strong> cat1:某个实例是否含有某个(实例或原型)属性</li>
</ul>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="var、let-及-const"><a href="#var、let-及-const" class="headerlink" title="var、let 及 const"></a>var、let 及 const</h2><ul>
<li>什么是提升？<ul>
<li>变量还没有被声明，但是我们却可以使用这个未被声明的变量</li>
<li>函数会被提升，并且优先于变量提升</li>
</ul>
</li>
<li>什么是暂时性死区？</li>
<li>var、let 及 const 区别？<ul>
<li>全局作用域下let 和 const 变量不会挂载到 window|globle</li>
<li>暂时性死区（不能在声明前使用） </li>
<li>块级作用域<ul>
<li>const 声明必须赋值，赋值后不能重新赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><ul>
<li><strong>寄生组合式继承</strong>，父类的原型赋值给了子类，并且将构造函数设置为子类<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Child &#123;<span class="attr">val</span>: <span class="number">1</span>&#125;</span><br><span class="line">  val: <span class="number">1</span></span><br><span class="line">  __proto__: Parent</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ Child(value)</span><br><span class="line">    __proto__: Object</span><br></pre></td></tr></table></figure>
<h2 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h2><ul>
<li>class 只是语法糖，本质还是函数。</li>
<li>使用 extends 表明继承自哪个父类</li>
<li>子类构造函数中必须调用 super，可以看成 Parent.call(this, value)。</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>解决了命名冲突、污染全局作用域的问题<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">exports.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.a </span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure>
<h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><ul>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持</li>
<li>CommonJS 是同步导入(服务端) :文件本地，后者是异步导入(浏览器)：下载文件影响渲染</li>
<li>CommonJS值拷贝，后者实时绑定同一内存地址</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul>
<li>Vue3.0 通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式</li>
<li>无需一层层递归为每个属性添加代理，一次即可完成以上操作</li>
</ul>
<h2 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map, filter, reduce"></a>map, filter, reduce</h2><ul>
<li>array.map(function(当前索引元素,索引,原数组), this绑定)</li>
<li>array.filter(function(当前索引元素,索引,原数组), this绑定)</li>
<li>array.reduce(function(累加值, 当前索引元素, 索引, 原数组), 初始值)</li>
</ul>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul>
<li><p>回调函数有什么缺点？<br>回调地狱、不能使用 try catch 捕获错误，不能直接 return</p>
</li>
<li><p>如何解决回调地狱问题？</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>状态机，控制函数的执行</p>
</li>
<li><p>Generator 返回一个迭代器</p>
<ul>
<li>第一次 next 时，传参会被忽略</li>
<li>第二次 next 时，传入的参数等于上一个 yield 的返回值，<ul>
<li>如果不传参，yield 永远返回 undefined<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li>构造 Promise 的时候，构造函数内部的代码是立即执行的</li>
<li>无法取消 Promise，错误需要通过回调函数捕获</li>
</ul>
<h2 id="async-及-await"><a href="#async-及-await" class="headerlink" title="async 及 await"></a>async 及 await</h2><ul>
<li>把*换成了async，把yield换成了await</li>
<li>一个函数如果加上 async ，那么该函数就会返回一个 Promise<ul>
<li>async 就是将函数返回值使用 Promise.resolve()包裹</li>
</ul>
</li>
<li>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</li>
<li>没有依赖性的话，完全可以使用 Promise.all 的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConstant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncConstant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function getAsyncConstant() &#123;</span></span><br><span class="line"><span class="comment">  return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">  return 1;</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>)=&gt;</span> &#123;</span><br><span class="line">    resolved(<span class="number">1</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function getPromise() &#123;</span></span><br><span class="line"><span class="comment">  return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">    return new Promise((resolved, rejected) =&gt; &#123;</span></span><br><span class="line"><span class="comment">      resolved(1);</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line"><span class="keyword">await</span> getConstant();</span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"><span class="keyword">await</span> getPromise();</span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"><span class="keyword">await</span> getAsyncConstant();</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">function test() &#123;</span></span><br><span class="line"><span class="comment">return Promise.resolve().then(function () &#123;</span></span><br><span class="line"><span class="comment">  a = 2;</span></span><br><span class="line"><span class="comment">  c = 1;</span></span><br><span class="line"><span class="comment">  return getConstant();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  d = 3;</span></span><br><span class="line"><span class="comment">  return getPromise();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  d = 4;</span></span><br><span class="line"><span class="comment">  return getAsyncConstant();</span></span><br><span class="line"><span class="comment">&#125;).then(function () &#123;</span></span><br><span class="line"><span class="comment">  return 2;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">&#125;**/</span></span><br></pre></td></tr></table></figure>

<h2 id="setTimeout、setInterval、requestAnimationFrame"><a href="#setTimeout、setInterval、requestAnimationFrame" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame"></a>setTimeout、setInterval、requestAnimationFrame</h2><ul>
<li>setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行<ul>
<li>setInterval对自己调用的代码是否报错漠不关心。</li>
<li>setInterval无视网络延迟</li>
<li>setInterval并不定时<ul>
<li>给setTimeout设置时间后，在最后调用自身,替代setInterval</li>
</ul>
</li>
</ul>
</li>
<li>浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定<ul>
<li>requestAnimationFrame页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停</li>
<li>使用setTimeout实现的动画，浪费CPU资源。</li>
</ul>
</li>
<li>requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次</li>
</ul>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p><a href="./promise">promise</a></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>进程是cpu<strong>资源分配</strong>的最小单位</li>
<li>线程是cpu<strong>调度</strong>的最小单位</li>
</ul>
<p>进程：工厂 线程：工人</p>
<ul>
<li>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</li>
<li>工厂之间的相互独立 -&gt; 进程之间相互独立</li>
<li>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</li>
<li>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</li>
<li>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</li>
</ul>
<h3 id="SharedWorker与WebWorker"><a href="#SharedWorker与WebWorker" class="headerlink" title="SharedWorker与WebWorker"></a>SharedWorker与WebWorker</h3><ul>
<li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</li>
<li>SharedWorker是浏览器所有页面共享的</li>
<li>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</li>
</ul>
<h3 id="url展示的过程"><a href="#url展示的过程" class="headerlink" title="url展示的过程"></a>url展示的过程</h3><ul>
<li>DNS 解析 域名 -&gt; ip （DNS缓存 浏览器/操作系统/hosts文件 -》本地配置的首选DNS服务器 -》运营商的DNS代我们的浏览器发起迭代DNS解析请求 -》com IP -》test.com IP -&gt; <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> IP</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
<li>css是由单独的下载线程异步下载的 </li>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建） </li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）  </li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面</li>
</ul>
</li>
</ul>
<ul>
<li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成</li>
<li>onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li>
</ul>
<h4 id="操作-DOM-性能很差"><a href="#操作-DOM-性能很差" class="headerlink" title="操作 DOM 性能很差?"></a>操作 DOM 性能很差?</h4><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。 -&gt;线程之间的通信<br>操作 DOM 可能还会带来重绘回流</p>
<p>分批次部分渲染 DOM -&gt; requestAnimationFrame<br>只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</p>
<h4 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染?"></a>阻塞渲染?</h4><p>浏览器在解析到 script 标签时，会暂停构建 DOM -&gt; script 标签放在 body 标签底部<br>defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行<br> async一旦下载完,渲染引擎就会中断渲染,执行这个脚本以后,再继续渲染</p>
<p><img src="http://segmentfault.com/img/bVcQV0" alt="async和defer"></p>
<h4 id="回流-和-重绘"><a href="#回流-和-重绘" class="headerlink" title="回流 和 重绘"></a>回流 和 重绘</h4><p>回流必定会发生重绘，重绘不一定会引发回流。</p>
<ul>
<li>减少重绘和回流<ul>
<li>使用 transform 替代 top</li>
<li>visibility 替换 display: none</li>
<li>不使用table布局</li>
<li>动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>
<li>CSS 选择符从右往左匹配查找，避免节点层级过多</li>
</ul>
</li>
</ul>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li>JS 是单线程的，先跑<strong>执行栈里</strong>的<strong>同步任务</strong>，然后再跑<strong>任务队列</strong>的<strong>异步任务</strong>。</li>
<li>当执行栈的栈空，js会读取任务队列，<ul>
<li>执行一个宏任务(先执行同步代码)–&gt;执行所有微任务–&gt;UI render</li>
<li>宏任务：主代码块 &gt; setTimeout / setInterval &gt; IO回调 &gt; requestAnimationFrame &gt; UIrender(重绘)</li>
<li>微任务：Promise回调</li>
</ul>
</li>
</ul>
<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="built_in">window</span></span><br><span class="line">  context.fn =<span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> fn(...args,...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context,args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = object.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> Constructor = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  obj.__proto__ = Constructor.prototype</span><br><span class="line">  <span class="keyword">const</span> result = Constructor.call(obj,...args)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span>? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof2</span>(<span class="params">Left,Right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = Right.prototype</span><br><span class="line">  <span class="keyword">let</span> proto = Left.__proto__</span><br><span class="line">  <span class="keyword">while</span>(proto)&#123;</span><br><span class="line">    <span class="keyword">if</span>(proto == prototype)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 != 0.3"></a>0.1 + 0.2 != 0.3</h2><ul>
<li>parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 </li>
<li>(0.1 + 0.2 - 0.3)&lt;Number.EPSILON</li>
</ul>
<h2 id="V8垃圾回收"><a href="#V8垃圾回收" class="headerlink" title="V8垃圾回收"></a>V8垃圾回收</h2><ul>
<li>GC算法采用分段式垃圾回收机制</li>
<li>新生代算法  From 空间满了和 To 空间交换</li>
<li>老生代算法 标记清除算法和标记压缩算法</li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><ul>
<li><p>window 往事件触发处传播，遇到注册的捕获事件会触发</p>
</li>
<li><p>传播到事件触发处时触发注册的事件</p>
</li>
<li><p>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</p>
</li>
<li><p>节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p>
</li>
</ul>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span> <span class="comment">//useCapture</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>stopPropagation 阻止事件冒泡</p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><ul>
<li>节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</li>
<li>使用event.target 判断子节点</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li>协议、域名或者端口有一个不同就是跨域</li>
<li>防止 CSRF 跨站请求伪造 攻击<ul>
<li>JSONP （只限于 get 请求）</li>
<li>CORS 服务端设Access-Control-Allow-Origin</li>
<li>document.domain <ul>
<li>二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</li>
<li>只需要给页面添加 document.domain = ‘test.com</li>
</ul>
</li>
<li>postMessage<ul>
<li>用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line">  <span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>)</span><br><span class="line">  <span class="comment">// 接收消息端</span></span><br><span class="line">  <span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  mc.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>document.cookie=”username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/“;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name,day</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">let</span> datems = date.getTime() + day*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span></span><br><span class="line">  date.setTime(datems)</span><br><span class="line">  <span class="built_in">document</span>.cookie=<span class="string">"name="</span>+name+<span class="string">";expires="</span>+date.toGMTString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"matt"</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>http-only    不能通过 JS 访问 Cookie，减少 XSS 攻击</li>
<li>secure    只能在协议为 HTTPS 的请求中携带</li>
<li>same-site    规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</li>
</ul>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><ul>
<li>数据请求分为发起网络请求、后端处理、浏览器响应三个步骤</li>
<li>直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致</li>
</ul>
<p>优先级：</p>
<ul>
<li>Service Worker （HTTPS）</li>
<li>Memory Cache<ul>
<li>内存缓存读取高效，可是缓存持续性短，随进程的释放而释放</li>
<li>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</li>
</ul>
</li>
<li>Disk Cache<ul>
<li>硬盘缓存</li>
</ul>
</li>
<li>Push Cache （HTTP2.0）<ul>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
</li>
</ul>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>HTTP Header：Expires 和 Cache-Control 。<br>强缓存表示在缓存期间不需要请求，state code 为 200。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h4><p>HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。</p>
<p>Cache-Control 可以在请求头或者响应头中设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>HTTP Header 实现：Last-Modified 和 ETag<br>如果缓存过期了，就需要发起请求验证资源是否有更新。</p>
<ol>
<li>客户端请求一个页面（A）。</li>
<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。</li>
<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</li>
</ol>
<h4 id="Last-Modified（响应头）-和-If-Modified-Since（请求头）"><a href="#Last-Modified（响应头）-和-If-Modified-Since（请求头）" class="headerlink" title="Last-Modified（响应头） 和 If-Modified-Since（请求头）"></a>Last-Modified（响应头） 和 If-Modified-Since（请求头）</h4><p>本地文件最后修改日期</p>
<h4 id="ETag-响应头-和-If-None-Match-（请求头）"><a href="#ETag-响应头-和-If-None-Match-（请求头）" class="headerlink" title="ETag(响应头) 和 If-None-Match （请求头）"></a>ETag(响应头) 和 If-None-Match （请求头）</h4><p>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>频繁变动的资源 ：<br>Cache-Control: no-cache 使浏览器每次都请求服务器<br>ETag /Last-Modified 来验证资源是否有效，减少响应体积</p>
<p>代码文件：<br>Cache-Control: max-age=31536000</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h2><p>持久型：攻击的代码被服务端写入进数据库<br>非持久型：修改 URL 参数的方式加入攻击代码，诱导用户访问链接</p>
<ul>
<li>解决：<ul>
<li>escape库 转义字符 js-xss </li>
<li>CSP（Content-Security-Policy）<br>建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。<ul>
<li>设置 HTTP Header 中的 Content-Security-Policy</li>
<li>设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h2><p>攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p>
<ul>
<li>解决：<ul>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie <ul>
<li>设置 SameSite 表示 Cookie 不随着跨域请求发送</li>
</ul>
</li>
<li>阻止第三方网站请求接口<ul>
<li>验证 Referer 来判断该请求是否为第三方网站发起的</li>
</ul>
</li>
<li>请求时附带验证信息，比如验证码或者 Token<ul>
<li>服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击</p>
<ul>
<li>解决：<ul>
<li>设置X-FRAME-OPTIONS响应头</li>
<li>js： top.location = self.location</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>HTTPS解决</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li><p>content方面</p>
<ul>
<li>减少HTTP请求：合并文件、CSS精灵、inline Image</li>
<li>减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名</li>
<li>减少DOM元素数量</li>
</ul>
</li>
<li><p>Server方面</p>
<ul>
<li>使用CDN</li>
<li>配置ETag</li>
<li>对组件使用Gzip压缩</li>
</ul>
</li>
<li><p>Cookie方面</p>
<ul>
<li>减小cookie大小</li>
</ul>
</li>
<li><p>css方面</p>
<ul>
<li>将样式表放到页面顶部</li>
<li>不使用CSS表达式</li>
<li>使用<link>不使用@import</li>
</ul>
</li>
<li><p>Javascript方面</p>
<ul>
<li>将脚本放到页面底部</li>
<li>将javascript和css从外部引入</li>
<li>压缩javascript和css</li>
<li>删除不需要的脚本</li>
<li>减少DOM访问</li>
</ul>
</li>
<li><p>图片方面</p>
<ul>
<li>雪碧图</li>
<li>矢量图 svg</li>
<li>小图片转base64</li>
</ul>
</li>
</ul>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行</p>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>一定时间段内没有再触发事件，事件处理函数才会执行一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(fn,time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>一定时间内只调用一次事件处理函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载<br><code>&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;</code></p>
<ol>
<li>将加载和执行分离开，不阻塞渲染和document的onload事件</li>
<li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出的情况</li>
</ol>
<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染<br><code>&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot;&gt;</code></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>静态资源尽量使用 CDN 加载</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象<br>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。<br><img src="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul>
<li>操作 DOM 是很慢的,操作 JS 对象会快很多</li>
<li>判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM</li>
</ul>
<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面</p>
<ul>
<li>Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li>
<li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li>
<li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li>
</ul>
<h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a> 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></p>
<p>window.addEventListener(‘hashchange’, () =&gt; {… })</p>
<h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><ul>
<li>不会引起页面的刷新，只会更新浏览器的历史记录</li>
<li>HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h1><h2 id="生命周期顺序"><a href="#生命周期顺序" class="headerlink" title="生命周期顺序"></a>生命周期顺序</h2>加载渲染过程</li>
</ul>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p>子组件全局状态更新过程</p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p>销毁过程</p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h2 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h2><p>创建-挂载-更新-销毁</p>
<ul>
<li>beforeCreate前，也就是new Vue的时候会初始化事件和生命周期；（获取不到 props 或者 data 中的数据）</li>
<li>beforeCreate和created之间会挂载Data，绑定事件；接下来会根据el挂载页面元素，如果没有设置el则生命周期结束，直到手动挂载；el挂载结束后，根据templete/outerHTML(el)渲染页面；</li>
<li>在beforeMount前虚拟DOM已经创建完成；</li>
<li>之后在mounted前，将vm.$el替换掉页面元素el;mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）；</li>
<li>之后发生数据变化时触发beforeUpdate和updated进行一些操作；</li>
<li>最后主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等；</li>
<li>destroyed时仅存在Dom节点，其他所有东西已自动销毁。</li>
</ul>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ul>
<li>父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件</li>
<li>v-model</li>
<li>.sync语法糖</li>
</ul>
<p>兄弟组件通信</p>
<ul>
<li>this.$parent.$children.name</li>
</ul>
<p>跨多层级组件通信<br>任意组件</p>
<ul>
<li>Vuex 或者 Event Bus</li>
</ul>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><ul>
<li>选项合并<ul>
<li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li>
<li>同名钩子函数将合并为一个数组，，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
</li>
</ul>
<h2 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h2><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</p>
<p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。  </p>
<h2 id="keep-alive-组件"><a href="#keep-alive-组件" class="headerlink" title="keep-alive 组件"></a>keep-alive 组件</h2><p>组件切换时保存一些组件的状态防止多次渲染<br>keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p>
<h2 id="v-show-与-v-if"><a href="#v-show-与-v-if" class="headerlink" title="v-show 与 v-if"></a>v-show 与 v-if</h2><p>v-show 只是在 display: none 和 display: block 之间切换<br>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件,在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>
<h2 id="data-对象还是函数"><a href="#data-对象还是函数" class="headerlink" title="data 对象还是函数"></a>data 对象还是函数</h2><p>组件复用时所有组件实例都会共享 data，对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。</p>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>window.onerror 代码运行错误<br>异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><ul>
<li>无法复用链接，完成即断开，重新慢启动和 TCP 3次握手 <ul>
<li>TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动</li>
<li>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，</li>
</ul>
</li>
<li>head of line blocking: 线头阻塞，导致请求之间互相影响 第一个请求阻塞后，后面的请求都需要等待<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2></li>
<li>长连接(默认 keep-alive)，复用。 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>
<li>host 字段指定对应的虚拟站点 同一个IP同一个端口不同的虚拟Web站点</li>
<li>新增功能:<ul>
<li>断点续传 要求服务器从文件XXXX字节处开始传送</li>
<li>身份认证</li>
<li>状态管理</li>
<li>cache 缓存<ul>
<li>Cache-Control</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Etag<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2></li>
</ul>
</li>
</ul>
</li>
<li>多路复用。 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 双向数据流</li>
<li>二进制分帧层。应用层http和传输层tcp之间 将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码</li>
<li>首部压缩。压缩http请求报文头部 首部压缩使得整个HTTP数据包小了很多，传输也就会更快</li>
<li>服务端推送。 一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>工厂模式：vue创建组件 createComponent</li>
<li>单例模式：全局缓存、全局状态管理 vuex单例 install</li>
<li>装饰器模式： ES7 中的装饰器语法</li>
<li>发布订阅模式：实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 get 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p>!important &gt; style 属性 &gt; id &gt; class &gt; tag</p>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><ul>
<li>absolute + transform</li>
<li>flex + justify-content + align-items</li>
<li>fixed margin:auto left:0 right:0 right:0 bottom：0</li>
</ul>
<h2 id="position-float-display"><a href="#position-float-display" class="headerlink" title="position float display"></a>position float display</h2><p>position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><ul>
<li><p>垂直放置</p>
</li>
<li><p>margin重叠</p>
</li>
<li><p>margin box与包含块border box的左边相接触</p>
</li>
<li><p>不与float重叠</p>
</li>
<li><p>浮动高度</p>
</li>
<li><p>不影响外部布局</p>
</li>
<li><p>根元素</p>
</li>
<li><p>float不默认</p>
</li>
<li><p>overflow不默认</p>
</li>
<li><p>postition：absolute 和fixed</p>
</li>
<li><p>display：inline-block 和flex</p>
</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><p>获取ua</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.userAgent</span><br><span class="line"><span class="keyword">var</span> isChrome = ua.indexOf(<span class="string">'Chrome'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isChrome)</span><br></pre></td></tr></table></figure>

<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>屏幕宽高<br>screen.width + screen.height<br>可见页面宽高<br>document.body.clientWidth + document.body.clientHeight</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>获取网址、协议、path、参数、hash 等<br>// 例如当前网址是 <a href="https://juejin.im/timeline/frontend?a=10&amp;b=10#some" target="_blank" rel="noopener">https://juejin.im/timeline/frontend?a=10&amp;b=10#some</a><br>console.log(location.href)  // <a href="https://juejin.im/timeline/frontend?a=10&amp;b=10#some" target="_blank" rel="noopener">https://juejin.im/timeline/frontend?a=10&amp;b=10#some</a><br>console.log(location.protocol) // https:<br>console.log(location.pathname) // /timeline/frontend<br>console.log(location.search) // ?a=10&amp;b=10<br>console.log(location.hash) // #some</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history.back()<br>history.forward()</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取-DOM-节点"><a href="#获取-DOM-节点" class="headerlink" title="获取 DOM 节点"></a>获取 DOM 节点</h2><p>var div1 = document.getElementById(‘div1’)<br>var divList = document.getElementsByTagName(‘div’)<br>var containerList = document.getElementsByClassName(‘container’)<br>var pList = document.querySelectorAll(‘p’)</p>
<h2 id="DOM-property"><a href="#DOM-property" class="headerlink" title="DOM property"></a>DOM property</h2><p>p可以有style属性，有className nodeName nodeType属性。注意，这些都是 JS 范畴的属性，符合 JS 语法标准的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(p.style.width)  <span class="comment">// 获取样式</span></span><br><span class="line">p.style.width = <span class="string">'100px'</span>  <span class="comment">// 修改样式</span></span><br><span class="line"><span class="built_in">console</span>.log(p.className)  <span class="comment">// 获取 class</span></span><br><span class="line">p.className = <span class="string">'p1'</span>  <span class="comment">// 修改 class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 nodeName 和 nodeType</span></span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName)</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeType)</span><br></pre></td></tr></table></figure>

<h2 id="HTML-attribute"><a href="#HTML-attribute" class="headerlink" title="HTML attribute"></a>HTML attribute</h2><p>attribute 就是对 HTML 属性的 get 和 set</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</span><br><span class="line">p.getAttribute(<span class="string">'data-name'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'juejin'</span>)</span><br><span class="line">p.getAttribute(<span class="string">'style'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</span><br></pre></td></tr></table></figure>
<p>get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p>
<h2 id="常见DOM-API"><a href="#常见DOM-API" class="headerlink" title="常见DOM API"></a>常见DOM API</h2><h3 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h3><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：</p>
<p>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题 </p>
<h3 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h3><p>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<p>要注意几个特点：</p>
<p>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p>
<h3 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h3><p>document.getElementById<br>document.getElementsByTagName<br>document.getElementsByName<br>document.getElementsByClassName<br>document.querySelector和document.querySelectorAll:通过css选择器来查找元素，注意选择器要符合CSS选择器的规则,使用的深度优先搜索来获取元素</p>
<h3 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h3><ol>
<li>父关系型api</li>
</ol>
<p>parentNode：Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null<br>2. 兄弟关系型api</p>
<p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。<br>3. 子关系型api</p>
<p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。   </p>
<h3 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h3><p>setAttribute：根据名称和值修改元素的特性eg:element.setAttribute(name, value);<br>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串.</p>
<h3 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h3><p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：</p>
<p>var style = window.getComputedStyle(element[, pseudoElt]);<br>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式   </p>
<p>getBoundingClientRect   </p>
<p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：</p>
<p>var clientRect = element.getBoundingClientRect();<br>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接</p>

                                    

                                      <!-- copyright -->
                                      
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://chiangming.github.io/2020/03/03/%E6%8E%98%E9%87%91/%E6%95%B4%E7%90%861/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/03/03/%E6%8E%98%E9%87%91/promise/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            掘金/promise
          
        </div>
      </a>
    
    
      <a href="/2020/02/25/%E9%98%AE%E4%B8%80%E5%B3%B0/400/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">阮一峰/400</div>
      </a>
    
  </nav>


  

  

  
  
  

</article>
</section>

          <div class="to_top">
            <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
          </div>
      </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Matt&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/resume">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9001/" target="_blank" rel="noopener">项目1</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://103.14.34.148:9003/" target="_blank" rel="noopener">项目2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
        
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['https://github.com/chiangming/','sa517144@mail.ustc.edu.cn',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
    </div>
  </body>

  </html>