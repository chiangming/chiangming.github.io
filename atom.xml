<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matt&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chiangming.github.io/"/>
  <updated>2020-03-11T05:46:20.394Z</updated>
  <id>https://chiangming.github.io/</id>
  
  <author>
    <name>Matt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interview/木易杨</title>
    <link href="https://chiangming.github.io/2020/03/11/interview/%E6%9C%A8%E6%98%93%E6%9D%A8/"/>
    <id>https://chiangming.github.io/2020/03/11/interview/%E6%9C%A8%E6%98%93%E6%9D%A8/</id>
    <published>2020-03-11T02:25:21.186Z</published>
    <updated>2020-03-11T05:46:20.394Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://chiangming.github.io/2020/03/09/%E6%8E%98%E9%87%91/leetcode/"/>
    <id>https://chiangming.github.io/2020/03/09/%E6%8E%98%E9%87%91/leetcode/</id>
    <published>2020-03-08T16:15:28.000Z</published>
    <updated>2020-03-10T05:21:47.082Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组方法&quot;&gt;&lt;a href=&quot;#数组方法&quot; class=&quot;headerlink&quot; title=&quot;数组方法&quot;&gt;&lt;/a&gt;数组方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;splice(2,4) 从索引2开始，删除4个元素，把删除的部分以新数组返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;splice(n,0,x) 从索引n开始，不删除，把x添加到索引n的前面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;push 向末尾追加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;unshift 向开头追加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;reverse 数组反序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;concat 数组拼接&lt;/li&gt;
&lt;li&gt;sort 数组排序 （默认字典序）&lt;ul&gt;
&lt;li&gt;sort((a,b)=&amp;gt;{return a-b})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;V8 引擎 sort 函数数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;bubble排序算法&quot;&gt;&lt;a href=&quot;#bubble排序算法&quot; class=&quot;headerlink&quot; title=&quot;bubble排序算法&quot;&gt;&lt;/a&gt;bubble排序算法&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i=arr.length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; ;i&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;arr.length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[j]&amp;lt;arr[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [arr[j],arr[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]] = [arr[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;],arr[j]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://chiangming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://chiangming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>interview/二叉树</title>
    <link href="https://chiangming.github.io/2020/03/05/interview/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://chiangming.github.io/2020/03/05/interview/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-05T06:40:33.027Z</published>
    <updated>2020-03-05T08:16:10.062Z</updated>
    
    <summary type="html">
    
      
      
        
        
          let BinarySearchTree = (function() {
  class Node {
    constructor(key) {
      this.key = key;
      this.left = null;
      this.right =
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>掘金/promise</title>
    <link href="https://chiangming.github.io/2020/03/03/%E6%8E%98%E9%87%91/promise/"/>
    <id>https://chiangming.github.io/2020/03/03/%E6%8E%98%E9%87%91/promise/</id>
    <published>2020-03-03T09:00:37.788Z</published>
    <updated>2020-03-04T15:52:25.300Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;手写Promise&quot;&gt;&lt;a href=&quot;#手写Promise&quot; class=&quot;headerlink&quot; title=&quot;手写Promise&quot;&gt;&lt;/a&gt;手写Promise&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>掘金/整理1</title>
    <link href="https://chiangming.github.io/2020/03/03/%E6%8E%98%E9%87%91/%E6%95%B4%E7%90%861/"/>
    <id>https://chiangming.github.io/2020/03/03/%E6%8E%98%E9%87%91/%E6%95%B4%E7%90%861/</id>
    <published>2020-03-03T01:32:50.155Z</published>
    <updated>2020-03-11T03:38:23.346Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-基础知识点&quot;&gt;&lt;a href=&quot;#JS-基础知识点&quot; class=&quot;headerlink&quot; title=&quot;JS 基础知识点&quot;&gt;&lt;/a&gt;JS 基础知识点&lt;/h1&gt;&lt;h2 id=&quot;原始类型&quot;&gt;&lt;a href=&quot;#原始类型&quot; class=&quot;headerlink&quot; title=&quot;原始类型&quot;&gt;&lt;/a&gt;原始类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原始类型有哪几种？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boolean null  undefined number  string  symbol bigint&lt;/li&gt;
&lt;li&gt;undefined.toString() -&amp;gt; TypeError&lt;ul&gt;
&lt;li&gt;原始类型存储的都是值，是没有函数可以调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;‘1’.toString() -&amp;gt; ‘1’&lt;ul&gt;
&lt;li&gt;强制类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;number是浮点类型的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0.1 + 0.2 !== 0.3&lt;/li&gt;
&lt;li&gt;使用 Math.abs(a-b) &amp;lt; Number.EPSILON&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;null 是对象嘛？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是 typeof null -&amp;gt; object&lt;/li&gt;
&lt;li&gt;js 32位系统000 开头代表是对象，然而 null 表示为全零
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>阮一峰/400</title>
    <link href="https://chiangming.github.io/2020/02/25/%E9%98%AE%E4%B8%80%E5%B3%B0/400/"/>
    <id>https://chiangming.github.io/2020/02/25/%E9%98%AE%E4%B8%80%E5%B3%B0/400/</id>
    <published>2020-02-25T01:55:54.561Z</published>
    <updated>2020-02-25T01:57:43.656Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;node如何和MySQL进行通信&quot;&gt;&lt;a href=&quot;#node如何和MySQL进行通信&quot; class=&quot;headerlink&quot; title=&quot;node如何和MySQL进行通信&quot;&gt;&lt;/a&gt;node如何和MySQL进行通信&lt;/h2&gt;&lt;p&gt;var mysql  =
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview/面试</title>
    <link href="https://chiangming.github.io/2020/02/24/interview/%E9%9D%A2%E8%AF%95/"/>
    <id>https://chiangming.github.io/2020/02/24/interview/%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-24T00:04:11.241Z</published>
    <updated>2020-03-11T04:00:05.089Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;h1 id=&quot;JS获取当年当月最后一天日期&quot;&gt;&lt;a href=&quot;#JS获取当年当月最后一天日期&quot; class=&quot;headerlink&quot; title=&quot;JS获取当年当月最后一天日期&quot;&gt;&lt;/a&gt;JS获取当年当月最后一天日期&lt;/h1&gt;&lt;p&gt;var new_date = new Date(new_year,new_month,1); //取当年次月中的第一天&lt;br&gt;return (new Date(new_date.getTime()-1000&lt;em&gt;60&lt;/em&gt;60*24)).getDate();//获取当月最后一天日期 &lt;/p&gt;
&lt;h1 id=&quot;为什么js里需要闭包&quot;&gt;&lt;a href=&quot;#为什么js里需要闭包&quot; class=&quot;headerlink&quot; title=&quot;为什么js里需要闭包&quot;&gt;&lt;/a&gt;为什么js里需要闭包&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;js也采用词法作用域是在函数定义时决定的，而不是函数调用时决定的。&lt;/li&gt;
&lt;li&gt;C语言这种底层编程语言中，函数中的非静态变量是储存在CPU栈中的，当函数调用结束后堆栈中的空间也由编译器自动释放。&lt;/li&gt;
&lt;li&gt;js闭包函数中的该函数被定义时所有外层的变量对象的引用被放在其上下文Scope属性作为一个作用域链包含，&lt;/li&gt;
&lt;li&gt;所以定义了闭包的函数虽然销毁了，但是其变量对象依然被绑定在函数inner上，保留在内存中。不被GC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TIP&quot;&gt;&lt;a href=&quot;#TIP&quot; class=&quot;headerlink&quot; title=&quot;TIP:&quot;&gt;&lt;/a&gt;TIP:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;变量对象与活动对象的概念是ES3提出的老概念，从ES5开始就用词法环境和变量环境替代了&lt;/li&gt;
&lt;li&gt;变量环境也是词法环境，它具备词法环境所有属性，一样有环境记录EnvironmentRecord（VO）与outer外部环境引入（作用域链）。&lt;/li&gt;
&lt;li&gt;作用域链是处理标识符时进行变量查询的变量对象列表&lt;/li&gt;
&lt;li&gt;在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值(变量提升)，var声明被设置为了undefined，函数被设置为了自身函数，而let  const被设置为未初始化（暂时性死区）&lt;/li&gt;
&lt;li&gt;变量对象是与执行上下文相关的数据作用域&lt;/li&gt;
&lt;li&gt;在函数上下文中，我们用活动对象来表示变量对象 对应于 词法记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;js解析引擎解析&quot;&gt;&lt;a href=&quot;#js解析引擎解析&quot; class=&quot;headerlink&quot; title=&quot;js解析引擎解析&quot;&gt;&lt;/a&gt;js解析引擎解析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;js是脚本语言，浏览器解析js过程分为：语法检查阶段和运行阶段。&lt;/li&gt;
&lt;li&gt;语法检查：&lt;ul&gt;
&lt;li&gt;字符流 - 记号流 - AST抽象语法树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行阶段：&lt;ul&gt;
&lt;li&gt;预解析： &lt;ul&gt;
&lt;li&gt;创建执行上下文 &lt;ul&gt;
&lt;li&gt;确定this&lt;/li&gt;
&lt;li&gt;创建词法环境（存储函数声明与let const声明的变量）&lt;/li&gt;
&lt;li&gt;创建变量环境 (存储var声明的变量)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对VO/AO预赋值 （函数的形参 &amp;gt; 函数声明 &amp;gt; 变量声明）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行代码&lt;ul&gt;
&lt;li&gt;VO/AO重新赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;fetch跨域-cookie&quot;&gt;&lt;a href=&quot;#fetch跨域-cookie&quot; class=&quot;headerlink&quot; title=&quot;fetch跨域 cookie&quot;&gt;&lt;/a&gt;fetch跨域 cookie&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myHeaders = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Headers();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch(url, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              method: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              headers: myHeaders,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              credentials: &lt;span class=&quot;string&quot;&gt;&quot;include&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在后台添加。允许浏览器&lt;br&gt;&lt;code&gt;response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;,&amp;quot;true&amp;quot;);&lt;/code&gt;&lt;br&gt;&lt;code&gt;response.setHeader(‘Access-Control-Allow-Origin’, ‘http://localhost:8080’)//不能为*&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;express-中间件&quot;&gt;&lt;a href=&quot;#express-中间件&quot; class=&quot;headerlink&quot; title=&quot;express 中间件&quot;&gt;&lt;/a&gt;express 中间件&lt;/h1&gt;&lt;p&gt;Express框架建立在node.js内置的http模块上。&lt;br&gt;Express框架的核心是对http模块的再包装。&lt;br&gt;Express框架等于在http模块之上，加了一个中间层。&lt;br&gt;应用层中间件、路由中间件、内置中间件、错误处理中间件和第三方中间件&lt;/p&gt;
&lt;h2 id=&quot;应用层中间件&quot;&gt;&lt;a href=&quot;#应用层中间件&quot; class=&quot;headerlink&quot; title=&quot;应用层中间件&quot;&gt;&lt;/a&gt;应用层中间件&lt;/h2&gt;&lt;p&gt;app.use（[path]，function）&lt;br&gt;path：是路由的url，默认参数‘/‘，意义是路由到这个路径时使用这个中间件&lt;br&gt;function：中间件函数&lt;br&gt;这个中间件函数可以理解为就是function(request,response,next)&lt;/p&gt;
&lt;h2 id=&quot;内置中间件express-static&quot;&gt;&lt;a href=&quot;#内置中间件express-static&quot; class=&quot;headerlink&quot; title=&quot;内置中间件express.static&quot;&gt;&lt;/a&gt;内置中间件express.static&lt;/h2&gt;&lt;p&gt;express.static(__dirname + ‘/public’) // express.static 是Express目前唯一内置的一个中间件。用来处理静态资源文件。&lt;/p&gt;
&lt;h2 id=&quot;路由中间件-express-Router&quot;&gt;&lt;a href=&quot;#路由中间件-express-Router&quot; class=&quot;headerlink&quot; title=&quot;路由中间件 express.Router();&quot;&gt;&lt;/a&gt;路由中间件 express.Router();&lt;/h2&gt;&lt;h2 id=&quot;body-parser&quot;&gt;&lt;a href=&quot;#body-parser&quot; class=&quot;headerlink&quot; title=&quot;body-parser&quot;&gt;&lt;/a&gt;body-parser&lt;/h2&gt;&lt;p&gt;post请求，enctype属性一般设置为“application/x-www-form-urlencoded”，用于key1=val1&amp;amp;key2=val2 的方式进行编码&lt;br&gt;如果设置成multipart/form-data，则多用于文件上传&lt;br&gt;如果设置成application/json,用于json序列化&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;enctype&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;application/x-www-form-urlencoded&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; bodyParser=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;body-parser&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解析以 application/json 和 application/x-www-form-urlencoded 提交的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; jsonParser = bodyParser.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; urlencodedParser = bodyParser.urlencoded(&amp;#123; &lt;span class=&quot;attr&quot;&gt;extended&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;动态路由-req-params&quot;&gt;&lt;a href=&quot;#动态路由-req-params&quot; class=&quot;headerlink&quot; title=&quot;动态路由 req.params&quot;&gt;&lt;/a&gt;动态路由 req.params&lt;/h3&gt;&lt;h3 id=&quot;get传参-req-query-参数名&quot;&gt;&lt;a href=&quot;#get传参-req-query-参数名&quot; class=&quot;headerlink&quot; title=&quot;get传参 req.query.参数名&quot;&gt;&lt;/a&gt;get传参 req.query.参数名&lt;/h3&gt;&lt;h2 id=&quot;cookie-parser&quot;&gt;&lt;a href=&quot;#cookie-parser&quot; class=&quot;headerlink&quot; title=&quot;cookie-parser&quot;&gt;&lt;/a&gt;cookie-parser&lt;/h2&gt;&lt;p&gt;const cookieParser=require(“cookie-parser”);&lt;/p&gt;
&lt;p&gt;app.use(cookieParser());&lt;/p&gt;
&lt;p&gt;res.cookie(“name”,’zhangsan’,{maxAge: 900000, httpOnly: true});&lt;br&gt;//res.cookie(名称,值,{配置信息})&lt;/p&gt;
&lt;h3 id=&quot;cookie加密-crypto&quot;&gt;&lt;a href=&quot;#cookie加密-crypto&quot; class=&quot;headerlink&quot; title=&quot;cookie加密 crypto&quot;&gt;&lt;/a&gt;cookie加密 crypto&lt;/h3&gt;&lt;h2 id=&quot;express-session&quot;&gt;&lt;a href=&quot;#express-session&quot; class=&quot;headerlink&quot; title=&quot;express-session&quot;&gt;&lt;/a&gt;express-session&lt;/h2&gt;&lt;h1 id=&quot;什么是事件委托吗？&quot;&gt;&lt;a href=&quot;#什么是事件委托吗？&quot; class=&quot;headerlink&quot; title=&quot;什么是事件委托吗？&quot;&gt;&lt;/a&gt;什么是事件委托吗？&lt;/h1&gt;&lt;p&gt;利用事件冒泡机制，给所有的li绑定点击事件，极为繁琐，这时候需要用到事件代理给ul绑定事件&lt;br&gt;element.addEventListener(event, function, useCapture)；&lt;br&gt;attachEvent()     //IE8及IE更早版本&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大量减少内存占用，减少事件注册。&lt;/li&gt;
&lt;li&gt;新增元素实现动态绑定事件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-对Promise了解吗？&quot;&gt;&lt;a href=&quot;#2-对Promise了解吗？&quot; class=&quot;headerlink&quot; title=&quot;2.对Promise了解吗？&quot;&gt;&lt;/a&gt;2.对Promise了解吗？&lt;/h2&gt;&lt;p&gt;promise构造函数是同步执行的，then方法是异步执行的，微任务&lt;/p&gt;
&lt;h2 id=&quot;3-window的onload事件和domcontentloaded谁先谁后？&quot;&gt;&lt;a href=&quot;#3-window的onload事件和domcontentloaded谁先谁后？&quot; class=&quot;headerlink&quot; title=&quot;3.window的onload事件和domcontentloaded谁先谁后？&quot;&gt;&lt;/a&gt;3.window的onload事件和domcontentloaded谁先谁后？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。&lt;/li&gt;
&lt;li&gt;当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;url展示的过程&quot;&gt;&lt;a href=&quot;#url展示的过程&quot; class=&quot;headerlink&quot; title=&quot;url展示的过程&quot;&gt;&lt;/a&gt;url展示的过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DNS 解析 域名 -&amp;gt; ip （DNS缓存 浏览器/操作系统/hosts文件 -》本地配置的首选DNS服务器 -》运营商的DNS代我们的浏览器发起迭代DNS解析请求 -》com IP -》test.com IP -&amp;gt; &lt;a href=&quot;http://www.test.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.test.com&lt;/a&gt; IP&lt;/li&gt;
&lt;li&gt;TCP 三次握手&lt;/li&gt;
&lt;li&gt;发送请求，分析 url，设置请求报文(头，主体)&lt;/li&gt;
&lt;li&gt;服务器返回请求的文件 (html)&lt;/li&gt;
&lt;li&gt;浏览器渲染&lt;ul&gt;
&lt;li&gt;HTML parser –&amp;gt; DOM Tree&lt;ul&gt;
&lt;li&gt;标记化算法，进行元素状态的标记&lt;/li&gt;
&lt;li&gt;dom 树构建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CSS parser –&amp;gt; Style Tree&lt;ul&gt;
&lt;li&gt;解析 css 代码，生成样式树&lt;/li&gt;
&lt;li&gt;css是由单独的下载线程异步下载的 &lt;/li&gt;
&lt;li&gt;css加载不会阻塞DOM树解析（异步加载时DOM照常构建） &lt;/li&gt;
&lt;li&gt;但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;attachment –&amp;gt; Render Tree&lt;ul&gt;
&lt;li&gt;结合 dom树 与 style树，生成渲染树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;layout: 布局&lt;/li&gt;
&lt;li&gt;GPU painting: 像素绘制页面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;vue的渲染过程&quot;&gt;&lt;a href=&quot;#vue的渲染过程&quot; class=&quot;headerlink&quot; title=&quot;vue的渲染过程&quot;&gt;&lt;/a&gt;vue的渲染过程&lt;/h1&gt;&lt;p&gt;把模板编译为render函数&lt;br&gt;实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom&lt;br&gt;对比虚拟dom，渲染到真实dom&lt;br&gt;组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3    &lt;/p&gt;
&lt;h1 id=&quot;箭头函数this&quot;&gt;&lt;a href=&quot;#箭头函数this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数this&quot;&gt;&lt;/a&gt;箭头函数this&lt;/h1&gt;&lt;p&gt;（1）默认指向定义它时，所处上下文的对象的this指向。即ES6箭头函数里this的指向就是 &lt;strong&gt;上下文里对象this指向&lt;/strong&gt;，偶尔没有上下文对象，this就指向window&lt;br&gt;（2）即使是call，apply，bind等方法也不能改变箭头函数this的指向&lt;/p&gt;
&lt;h1 id=&quot;for-in和-for-of&quot;&gt;&lt;a href=&quot;#for-in和-for-of&quot; class=&quot;headerlink&quot; title=&quot;for in和 for of&quot;&gt;&lt;/a&gt;for in和 for of&lt;/h1&gt;&lt;p&gt;for in会遍历数组所有的可枚举属性，包括原型。&lt;br&gt;for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name&lt;/p&gt;
&lt;p&gt;for in来遍历对象的键名/索引&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; myObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;（myObject.hasOwnProperty(key))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性&lt;/p&gt;
&lt;p&gt;for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jQuery.prototype[&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;.iterator] = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype[&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;.iterator];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，&lt;br&gt;函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;
&lt;h1 id=&quot;浏览器下事件循环-Event-Loop&quot;&gt;&lt;a href=&quot;#浏览器下事件循环-Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;浏览器下事件循环(Event Loop)&quot;&gt;&lt;/a&gt;浏览器下事件循环(Event Loop)&lt;/h1&gt;&lt;p&gt;主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环&lt;/p&gt;
&lt;h4 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)&lt;/li&gt;
&lt;li&gt;检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue （在执行微任务的时候，如果又有微任务进入队列，则在此次循环中执行）&lt;/li&gt;
&lt;li&gt;更新 render （视图更新）&lt;/li&gt;
&lt;li&gt;主线程重复执行上述步骤&lt;br&gt;上述为一轮事件循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://103.14.34.148:9000/imgs/blog/img/browser-deom1-excute-animate.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Http请求中的keep-alive&quot;&gt;&lt;a href=&quot;#Http请求中的keep-alive&quot; class=&quot;headerlink&quot; title=&quot;Http请求中的keep-alive&quot;&gt;&lt;/a&gt;Http请求中的keep-alive&lt;/h1&gt;&lt;p&gt;在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。&lt;br&gt;使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。&lt;br&gt;但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。&lt;/p&gt;
&lt;h1 id=&quot;1-从输入URL到页面加载发生了什么？url展示&quot;&gt;&lt;a href=&quot;#1-从输入URL到页面加载发生了什么？url展示&quot; class=&quot;headerlink&quot; title=&quot;1. 从输入URL到页面加载发生了什么？url展示&quot;&gt;&lt;/a&gt;1. 从输入URL到页面加载发生了什么？url展示&lt;/h1&gt;&lt;p&gt;1、浏览器的地址栏输入URL并按下回车。&lt;br&gt;2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。&lt;br&gt;3、DNS解析URL对应的IP。&lt;br&gt;4、根据IP建立TCP连接（三次握手）。&lt;br&gt;5、HTTP发起请求。&lt;br&gt;6、服务器处理请求，浏览器接收HTTP响应。&lt;br&gt;7、渲染页面，构建DOM树。&lt;br&gt;8、关闭TCP连接（四次挥手）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/22/167d5e19c54ae53e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-缓存相关的知识吧？&quot;&gt;&lt;a href=&quot;#2-缓存相关的知识吧？&quot; class=&quot;headerlink&quot; title=&quot;2. 缓存相关的知识吧？&quot;&gt;&lt;/a&gt;2. 缓存相关的知识吧？&lt;/h1&gt;&lt;p&gt;浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存（协商缓存）。&lt;br&gt;两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。&lt;/p&gt;
&lt;p&gt;强制缓存判断HTTP首部字段：cache-control，Expires。&lt;/p&gt;
&lt;p&gt;Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。&lt;/p&gt;
&lt;p&gt;cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。&lt;/p&gt;
&lt;p&gt;协商缓存通过HTTP的last-modified，Etag字段进行判断。&lt;/p&gt;
&lt;p&gt;last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。&lt;/p&gt;
&lt;p&gt;Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。&lt;/p&gt;
&lt;p&gt;如果需要浏览器强缓存，我们可以这样设置：&lt;br&gt;res.setHeader(‘Cache-Control’, ‘public, max-age=xxx’);&lt;br&gt;复制代码如果需要协商缓存，则可以这样设置：&lt;br&gt;res.setHeader(‘Cache-Control’, ‘public, max-age=0’);&lt;br&gt;res.setHeader(‘Last-Modified’, xxx);&lt;br&gt;res.setHeader(‘ETag’, xxx);&lt;/p&gt;
&lt;h1 id=&quot;TCP-三次握手-四次挥手&quot;&gt;&lt;a href=&quot;#TCP-三次握手-四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP 三次握手 四次挥手&quot;&gt;&lt;/a&gt;TCP 三次握手 四次挥手&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38950316/article/details/81087809&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_38950316/article/details/81087809&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;常见状态码&quot;&gt;&lt;a href=&quot;#常见状态码&quot; class=&quot;headerlink&quot; title=&quot;常见状态码&quot;&gt;&lt;/a&gt;常见状态码&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1xx: 接受，继续处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;200: 成功，并返回数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;201: 已创建&lt;/li&gt;
&lt;li&gt;202: 已接受&lt;/li&gt;
&lt;li&gt;203: 成为，但未授权&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;204: 成功，无内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;205: 成功，重置内容&lt;/li&gt;
&lt;li&gt;206: 成功，部分内容&lt;/li&gt;
&lt;li&gt;301: 永久移动，重定向&lt;/li&gt;
&lt;li&gt;302: 临时移动，可使用原有URI&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;304: 资源未修改，可使用缓存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;305: 需代理访问&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;400: 请求语法错误&lt;/li&gt;
&lt;li&gt;401: 要求身份认证&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;403: 拒绝请求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404: 资源不存在&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;500: 服务器错误&lt;/strong&gt;&lt;h3 id=&quot;GET-POST&quot;&gt;&lt;a href=&quot;#GET-POST&quot; class=&quot;headerlink&quot; title=&quot;GET POST&quot;&gt;&lt;/a&gt;GET POST&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;GET把参数包含在URL中，而POST将数据放在BODY中。&lt;/li&gt;
&lt;li&gt;GET方式提交的数据有长度限制，则POST的数据则可以非常大。&lt;/li&gt;
&lt;li&gt;POST比GET安全，因为数据在地址栏上不可见。&lt;/li&gt;
&lt;li&gt;GET 会被历史保存记录，POST中的参数不会被保留&lt;/li&gt;
&lt;li&gt;GET只能进行url编码，POST支持更多编码类型（请求头中的Content-Type属性表示编码方式）&lt;/li&gt;
&lt;li&gt;对参数的数据类型，GET只接受ASCII字符，而POST没有限制&lt;/li&gt;
&lt;li&gt;GET在浏览器回退时是无害的，而POST会再次提交请求&lt;/li&gt;
&lt;li&gt;GET能被缓存，而POST不能&lt;/li&gt;
&lt;li&gt;GET是幂等(请求次数与资源无关)的。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。&lt;br&gt;GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;get: &lt;ul&gt;
&lt;li&gt;缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，&lt;/li&gt;
&lt;li&gt;发送一个TCP请求 &lt;/li&gt;
&lt;li&gt;幂等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;post: 安全、大数据、更多编码类型 发送两个TCP请求 &lt;/li&gt;
&lt;li&gt;最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;X时Y分时的两针位置&quot;&gt;&lt;a href=&quot;#X时Y分时的两针位置&quot; class=&quot;headerlink&quot; title=&quot;X时Y分时的两针位置&quot;&gt;&lt;/a&gt;X时Y分时的两针位置&lt;/h1&gt;&lt;p&gt;θ=|6Y-(30X+0.5Y)|=|5.5Y-30X|,单位是度（°）；&lt;/p&gt;
&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; len = arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(len &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(len / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    left = arr.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,index); &lt;span class=&quot;comment&quot;&gt;//得到下标从0~index-1的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    right = arr.slice(index);  &lt;span class=&quot;comment&quot;&gt;//得到下标从index开始到末尾的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; merge(mergeSort(left) , mergeSort(right));  里面采用递归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left , right&lt;/span&gt;) &lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;//该函数与快排类似，但是仔细发现，每次left或者right都是要shift掉第一个元素，表示left或者right是会变化的，最后arr.concat，因为不知道left或者right其中一个哪个剩下元素，所以要将剩下的元素给加上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(left.length &amp;amp;&amp;amp; right.length) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(left[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt; right[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      arr.push(left.shift());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      arr.push(right.shift())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr.concat(left , right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;js的bind、apply、call有什么区别&quot;&gt;&lt;a href=&quot;#js的bind、apply、call有什么区别&quot; class=&quot;headerlink&quot; title=&quot;js的bind、apply、call有什么区别&quot;&gt;&lt;/a&gt;js的bind、apply、call有什么区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fn.call(obj,…args)转换成obj.fn(…args)&lt;/li&gt;
&lt;li&gt;fn.call(obj,args) 转换成obj.fn(args)&lt;/li&gt;
&lt;li&gt;return function F(){ return new fn() 或者return fn.apply(obj,args.concat(…arguments))}
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue题目</title>
    <link href="https://chiangming.github.io/2020/02/23/interview/vue/"/>
    <id>https://chiangming.github.io/2020/02/23/interview/vue/</id>
    <published>2020-02-22T16:15:39.000Z</published>
    <updated>2020-03-10T05:38:49.505Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？&quot;&gt;&lt;a href=&quot;#写-Vue-项目时为什么要在列表组件中写-key，其作用是什么？&quot; class=&quot;headerlink&quot; title=&quot;写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？&quot;&gt;&lt;/a&gt;写 Vue 项目时为什么要在列表组件中写 key，其作用是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;考虑到DOM节点更改的性能问题，Vue使用vnode做虚拟dom节点进行更新&lt;/li&gt;
&lt;li&gt;组件的更新，是通过每一个vue实例的watcher派发更新的，每一步更新都是更新一个vue实例对应的dom。因为update事件被推送到任务队列时，是按watcher的id从小到大进行排序，所以会先更新用户watcher，再更新父watcher，再更新子watcher&lt;/li&gt;
&lt;li&gt;响应式数据的变化触发渲染watcher的updateComponment方法，执行vm._patch(vm._render,false)过程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;_render() 生成当前vm实例 新的vnode&lt;/li&gt;
&lt;li&gt;_update() 执行 patch方法，由于此时存在旧vnode，如果新旧vnode不同（key tag），会调用 patchVnode，如果是不同的vnode，createELm 创建新的dom，并删去旧的dom&lt;/li&gt;
&lt;li&gt;patchVnode 主要是进行更新dom操作 &lt;ul&gt;
&lt;li&gt;新旧节点的孩子节点存在 且不同，调用diff算法&lt;/li&gt;
&lt;li&gt;比较 新旧节点的文本，进行更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;diff算法
    
    </summary>
    
    
      <category term="面试" scheme="https://chiangming.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试题" scheme="https://chiangming.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Vue" scheme="https://chiangming.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>编程</title>
    <link href="https://chiangming.github.io/2020/02/23/interview/js%E7%BC%96%E7%A8%8B/"/>
    <id>https://chiangming.github.io/2020/02/23/interview/js%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-22T16:15:39.000Z</published>
    <updated>2020-03-05T12:07:30.437Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;将字符串中每个单词的首字母大写化&quot;&gt;&lt;a href=&quot;#将字符串中每个单词的首字母大写化&quot; class=&quot;headerlink&quot; title=&quot;将字符串中每个单词的首字母大写化&quot;&gt;&lt;/a&gt;将字符串中每个单词的首字母大写化&lt;/h2&gt;&lt;figure
        
      
    
    </summary>
    
    
      <category term="编程" scheme="https://chiangming.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://chiangming.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>interview/vue-blog</title>
    <link href="https://chiangming.github.io/2020/02/20/interview/vue-blog/"/>
    <id>https://chiangming.github.io/2020/02/20/interview/vue-blog/</id>
    <published>2020-02-20T02:11:00.675Z</published>
    <updated>2020-02-21T04:53:15.406Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;响应式系统&quot;&gt;&lt;a href=&quot;#响应式系统&quot; class=&quot;headerlink&quot; title=&quot;响应式系统&quot;&gt;&lt;/a&gt;响应式系统&lt;/h1&gt;&lt;p&gt;1、Vue
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview/js加载图片</title>
    <link href="https://chiangming.github.io/2020/02/19/interview/js%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
    <id>https://chiangming.github.io/2020/02/19/interview/js%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</id>
    <published>2020-02-19T13:32:33.080Z</published>
    <updated>2020-02-22T11:10:16.833Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javascript知识点</title>
    <link href="https://chiangming.github.io/2020/02/17/interview/javascript%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://chiangming.github.io/2020/02/17/interview/javascript%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-02-16T16:15:39.000Z</published>
    <updated>2020-02-18T06:59:00.536Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS知识点&quot;&gt;&lt;a href=&quot;#JS知识点&quot; class=&quot;headerlink&quot; title=&quot;JS知识点&quot;&gt;&lt;/a&gt;JS知识点&lt;/h1&gt;&lt;h2 id=&quot;this绑定&quot;&gt;&lt;a href=&quot;#this绑定&quot; class=&quot;headerlink&quot; title=&quot;this绑定&quot;&gt;&lt;/a&gt;this绑定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接调用，立即执行 -&amp;gt; window|gloable&lt;/li&gt;
&lt;li&gt;obj.foo() -&amp;gt; obj&lt;/li&gt;
&lt;li&gt;new Foo() -&amp;gt; foo&lt;/li&gt;
&lt;li&gt;箭头函数 -&amp;gt; 没有this、arguments、prototype&lt;/li&gt;
&lt;li&gt;bind({a:100}) -&amp;gt; {a:100} 第一个bind &lt;/li&gt;
&lt;li&gt;bind() -&amp;gt; window|gloable&lt;/li&gt;
&lt;li&gt;new &amp;gt; bind &amp;gt; 对象调用 &amp;gt; 直接调用
    
    </summary>
    
    
      <category term="面试" scheme="https://chiangming.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="javascript" scheme="https://chiangming.github.io/tags/javascript/"/>
    
      <category term="面试题" scheme="https://chiangming.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>源码模拟</title>
    <link href="https://chiangming.github.io/2020/02/17/interview/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://chiangming.github.io/2020/02/17/interview/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2020-02-16T16:15:39.000Z</published>
    <updated>2020-02-19T15:22:40.278Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;call&quot;&gt;&lt;a href=&quot;#call&quot; class=&quot;headerlink&quot; title=&quot;call&quot;&gt;&lt;/a&gt;call&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;思想: fn.call(obj,…args)转换成obj.fn(…args)&lt;figure
        
      
    
    </summary>
    
    
      <category term="面试" scheme="https://chiangming.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="javascript" scheme="https://chiangming.github.io/tags/javascript/"/>
    
      <category term="面试题" scheme="https://chiangming.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阮一峰的网络日志</title>
    <link href="https://chiangming.github.io/2020/02/17/%E9%98%AE%E4%B8%80%E5%B3%B0/1/"/>
    <id>https://chiangming.github.io/2020/02/17/%E9%98%AE%E4%B8%80%E5%B3%B0/1/</id>
    <published>2020-02-16T16:15:39.000Z</published>
    <updated>2020-02-19T14:45:42.505Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Javascript获取页面元素的位置&quot;&gt;&lt;a href=&quot;#Javascript获取页面元素的位置&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="阮一峰" scheme="https://chiangming.github.io/categories/%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    
    
      <category term="阮一峰" scheme="https://chiangming.github.io/tags/%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://chiangming.github.io/2020/02/17/%E6%8E%92%E5%BA%8F/"/>
    <id>https://chiangming.github.io/2020/02/17/%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-16T16:15:39.000Z</published>
    <updated>2020-02-18T04:02:27.706Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;参考 &lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chiangming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://chiangming.github.io/tags/javascript/"/>
    
      <category term="算法" scheme="https://chiangming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="https://chiangming.github.io/2020/02/16/es6%E7%9B%B8%E5%85%B3/"/>
    <id>https://chiangming.github.io/2020/02/16/es6%E7%9B%B8%E5%85%B3/</id>
    <published>2020-02-15T16:15:25.000Z</published>
    <updated>2020-02-19T11:59:11.479Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;let-和const&quot;&gt;&lt;a href=&quot;#let-和const&quot; class=&quot;headerlink&quot; title=&quot;let 和const&quot;&gt;&lt;/a&gt;let 和const&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;不存在变量提升
        
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://chiangming.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://chiangming.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>防抖</title>
    <link href="https://chiangming.github.io/2020/02/10/%E9%98%B2%E6%8A%96/"/>
    <id>https://chiangming.github.io/2020/02/10/%E9%98%B2%E6%8A%96/</id>
    <published>2020-02-10T06:06:27.952Z</published>
    <updated>2020-02-10T14:03:13.101Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&#39;utf-8&#39;&gt;
  &lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge&#39;&gt;
  &lt;title&gt;Page
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue整理</title>
    <link href="https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/vue/"/>
    <id>https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/vue/</id>
    <published>2019-12-21T16:15:39.000Z</published>
    <updated>2020-02-10T08:29:43.584Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23921964&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/23921964&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;响应式原理&quot;&gt;&lt;a href=&quot;#响应式原理&quot; class=&quot;headerlink&quot; title=&quot;响应式原理&quot;&gt;&lt;/a&gt;响应式原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://103.14.34.148:9000/imgs/blog/img/reactive.png&quot; alt=&quot;reactive&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Vue的初始化阶段，对vue的属性进行处理对于data和props,Vue会通过ovserve/defineReactive等系列操作，把整个data和props定义的对象每一个属性编成响应式的，同时内部持有一个dep的实例。&lt;/li&gt;
&lt;li&gt;当我们访问到响应式数据的时候，就会触发数据内部dep的depend方法来收集依赖&lt;/li&gt;
&lt;li&gt;收集依赖收集的是当前正在计算的watcher，也就是说当前的Dep.target就会作为订阅者来订阅这些数据的变化
    
    </summary>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/tags/Vue/"/>
    
      <category term="源码解析" scheme="https://chiangming.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/vue-router/"/>
    <id>https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/vue-router/</id>
    <published>2019-12-21T16:15:38.000Z</published>
    <updated>2020-02-10T08:30:34.643Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册&quot;&gt;&lt;a href=&quot;#注册&quot; class=&quot;headerlink&quot; title=&quot;注册&quot;&gt;&lt;/a&gt;注册&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;install&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;Vue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 混入 beforeCreate 钩子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Vue.mixin(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       beforeCreate () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// 在option上面存在router则代表是根组件 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isDef(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$options.router)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._routerRoot = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 定义router的根vm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._router = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$options.router&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 执行_router实例的 init 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._router.init(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 为 vue 实例定义数据劫持&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           Vue.util.defineReactive(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;_route&#39;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._router.history.current)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 非根组件则直接从父组件中获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._routerRoot = (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$parent &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$parent._routerRoot) || &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         registerInstance(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       destroyed () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         registerInstance(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(Vue.prototype, &lt;span class=&quot;string&quot;&gt;&#39;$router&#39;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;comment&quot;&gt;//Router&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; () &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._routerRoot._router &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(Vue.prototype, &lt;span class=&quot;string&quot;&gt;&#39;$route&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; () &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._routerRoot._route &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 注册 router-view 和 router-link 组件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Vue.component(&lt;span class=&quot;string&quot;&gt;&#39;RouterView&#39;&lt;/span&gt;, View)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Vue.component(&lt;span class=&quot;string&quot;&gt;&#39;RouterLink&#39;&lt;/span&gt;, Link)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// Vue钩子合并策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; strats = Vue.config.optionMergeStrategies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// use the same hook merging strategy for route hooks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/tags/Vue/"/>
    
      <category term="源码解析" scheme="https://chiangming.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>12.transition</title>
    <link href="https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/12.transition/"/>
    <id>https://chiangming.github.io/2019/12/22/vue%E6%BA%90%E7%A0%81/12.transition/</id>
    <published>2019-12-21T16:15:37.000Z</published>
    <updated>2020-02-10T08:33:27.425Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;render函数-vnode&quot;&gt;&lt;a href=&quot;#render函数-vnode&quot; class=&quot;headerlink&quot; title=&quot;render函数 vnode&quot;&gt;&lt;/a&gt;render函数 vnode&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;transition组件使用同插槽一样，调用 transition 组件的render方法，通过 &lt;code&gt;this.$slots.default&lt;/code&gt; 取得内部的vnode&lt;/li&gt;
&lt;li&gt;在 vnode的data上 生成 transition对象，保存transition标签上的 props （例如 name），listeners等属性 &lt;code&gt;vnode.data.transition&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; data: &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt; = (child.data || (child.data = &amp;#123;&amp;#125;)).transition = extractTransitionData(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 取出 transition组件 过渡动画所需的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;   (&lt;span class=&quot;params&quot;&gt;comp: Component&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;Object&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; data = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; options: ComponentOptions = comp.$options&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// props&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; options.propsData) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data[key] = comp[key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// events.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// extract listeners and pass them directly to the transition methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; listeners: ?&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt; = options._parentListeners&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listeners) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data[camelize(key)] = listeners[key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过该方法在子组件上添加动画css名，这样 child.data.transition 中就包含了过渡所需的一些数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果组件里面写了html语言（不是正常插槽的写法），那么会作为 _c的 children vnode 传入，最终vnode保存在 componentOptions.children，在 _init过程中 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;合并component配置的过程中，&lt;code&gt;opts._renderChildren = vnodeComponentOptions.children;&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;initRender 将 opts._renderChildren 挂载到 vm.$slots.default 上
    
    </summary>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://chiangming.github.io/tags/Vue/"/>
    
      <category term="源码解析" scheme="https://chiangming.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
